
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model PrivateMessages
 * 
 */
export type PrivateMessages = $Result.DefaultSelection<Prisma.$PrivateMessagesPayload>
/**
 * Model PrivateMessagesAttachment
 * 
 */
export type PrivateMessagesAttachment = $Result.DefaultSelection<Prisma.$PrivateMessagesAttachmentPayload>
/**
 * Model GroupMessages
 * 
 */
export type GroupMessages = $Result.DefaultSelection<Prisma.$GroupMessagesPayload>
/**
 * Model GroupMessagesAttachment
 * 
 */
export type GroupMessagesAttachment = $Result.DefaultSelection<Prisma.$GroupMessagesAttachmentPayload>
/**
 * Model Friends
 * 
 */
export type Friends = $Result.DefaultSelection<Prisma.$FriendsPayload>
/**
 * Model PendingFriendRequests
 * 
 */
export type PendingFriendRequests = $Result.DefaultSelection<Prisma.$PendingFriendRequestsPayload>
/**
 * Model GroupChats
 * 
 */
export type GroupChats = $Result.DefaultSelection<Prisma.$GroupChatsPayload>
/**
 * Model Blocks
 * 
 */
export type Blocks = $Result.DefaultSelection<Prisma.$BlocksPayload>
/**
 * Model GroupMembers
 * 
 */
export type GroupMembers = $Result.DefaultSelection<Prisma.$GroupMembersPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privateMessages`: Exposes CRUD operations for the **PrivateMessages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivateMessages
    * const privateMessages = await prisma.privateMessages.findMany()
    * ```
    */
  get privateMessages(): Prisma.PrivateMessagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privateMessagesAttachment`: Exposes CRUD operations for the **PrivateMessagesAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivateMessagesAttachments
    * const privateMessagesAttachments = await prisma.privateMessagesAttachment.findMany()
    * ```
    */
  get privateMessagesAttachment(): Prisma.PrivateMessagesAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMessages`: Exposes CRUD operations for the **GroupMessages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMessages
    * const groupMessages = await prisma.groupMessages.findMany()
    * ```
    */
  get groupMessages(): Prisma.GroupMessagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMessagesAttachment`: Exposes CRUD operations for the **GroupMessagesAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMessagesAttachments
    * const groupMessagesAttachments = await prisma.groupMessagesAttachment.findMany()
    * ```
    */
  get groupMessagesAttachment(): Prisma.GroupMessagesAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.friends`: Exposes CRUD operations for the **Friends** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friends
    * const friends = await prisma.friends.findMany()
    * ```
    */
  get friends(): Prisma.FriendsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingFriendRequests`: Exposes CRUD operations for the **PendingFriendRequests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingFriendRequests
    * const pendingFriendRequests = await prisma.pendingFriendRequests.findMany()
    * ```
    */
  get pendingFriendRequests(): Prisma.PendingFriendRequestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupChats`: Exposes CRUD operations for the **GroupChats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupChats
    * const groupChats = await prisma.groupChats.findMany()
    * ```
    */
  get groupChats(): Prisma.GroupChatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blocks`: Exposes CRUD operations for the **Blocks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.blocks.findMany()
    * ```
    */
  get blocks(): Prisma.BlocksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMembers`: Exposes CRUD operations for the **GroupMembers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMembers
    * const groupMembers = await prisma.groupMembers.findMany()
    * ```
    */
  get groupMembers(): Prisma.GroupMembersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Users: 'Users',
    PrivateMessages: 'PrivateMessages',
    PrivateMessagesAttachment: 'PrivateMessagesAttachment',
    GroupMessages: 'GroupMessages',
    GroupMessagesAttachment: 'GroupMessagesAttachment',
    Friends: 'Friends',
    PendingFriendRequests: 'PendingFriendRequests',
    GroupChats: 'GroupChats',
    Blocks: 'Blocks',
    GroupMembers: 'GroupMembers'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "privateMessages" | "privateMessagesAttachment" | "groupMessages" | "groupMessagesAttachment" | "friends" | "pendingFriendRequests" | "groupChats" | "blocks" | "groupMembers"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      PrivateMessages: {
        payload: Prisma.$PrivateMessagesPayload<ExtArgs>
        fields: Prisma.PrivateMessagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivateMessagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivateMessagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesPayload>
          }
          findFirst: {
            args: Prisma.PrivateMessagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivateMessagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesPayload>
          }
          findMany: {
            args: Prisma.PrivateMessagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesPayload>[]
          }
          create: {
            args: Prisma.PrivateMessagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesPayload>
          }
          createMany: {
            args: Prisma.PrivateMessagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivateMessagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesPayload>[]
          }
          delete: {
            args: Prisma.PrivateMessagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesPayload>
          }
          update: {
            args: Prisma.PrivateMessagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesPayload>
          }
          deleteMany: {
            args: Prisma.PrivateMessagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivateMessagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrivateMessagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesPayload>[]
          }
          upsert: {
            args: Prisma.PrivateMessagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesPayload>
          }
          aggregate: {
            args: Prisma.PrivateMessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivateMessages>
          }
          groupBy: {
            args: Prisma.PrivateMessagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivateMessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivateMessagesCountArgs<ExtArgs>
            result: $Utils.Optional<PrivateMessagesCountAggregateOutputType> | number
          }
        }
      }
      PrivateMessagesAttachment: {
        payload: Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>
        fields: Prisma.PrivateMessagesAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivateMessagesAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivateMessagesAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesAttachmentPayload>
          }
          findFirst: {
            args: Prisma.PrivateMessagesAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivateMessagesAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesAttachmentPayload>
          }
          findMany: {
            args: Prisma.PrivateMessagesAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesAttachmentPayload>[]
          }
          create: {
            args: Prisma.PrivateMessagesAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesAttachmentPayload>
          }
          createMany: {
            args: Prisma.PrivateMessagesAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivateMessagesAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesAttachmentPayload>[]
          }
          delete: {
            args: Prisma.PrivateMessagesAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesAttachmentPayload>
          }
          update: {
            args: Prisma.PrivateMessagesAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.PrivateMessagesAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivateMessagesAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrivateMessagesAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.PrivateMessagesAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagesAttachmentPayload>
          }
          aggregate: {
            args: Prisma.PrivateMessagesAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivateMessagesAttachment>
          }
          groupBy: {
            args: Prisma.PrivateMessagesAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivateMessagesAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivateMessagesAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<PrivateMessagesAttachmentCountAggregateOutputType> | number
          }
        }
      }
      GroupMessages: {
        payload: Prisma.$GroupMessagesPayload<ExtArgs>
        fields: Prisma.GroupMessagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMessagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMessagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesPayload>
          }
          findFirst: {
            args: Prisma.GroupMessagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMessagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesPayload>
          }
          findMany: {
            args: Prisma.GroupMessagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesPayload>[]
          }
          create: {
            args: Prisma.GroupMessagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesPayload>
          }
          createMany: {
            args: Prisma.GroupMessagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMessagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesPayload>[]
          }
          delete: {
            args: Prisma.GroupMessagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesPayload>
          }
          update: {
            args: Prisma.GroupMessagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesPayload>
          }
          deleteMany: {
            args: Prisma.GroupMessagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMessagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupMessagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesPayload>[]
          }
          upsert: {
            args: Prisma.GroupMessagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesPayload>
          }
          aggregate: {
            args: Prisma.GroupMessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMessages>
          }
          groupBy: {
            args: Prisma.GroupMessagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMessagesCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMessagesCountAggregateOutputType> | number
          }
        }
      }
      GroupMessagesAttachment: {
        payload: Prisma.$GroupMessagesAttachmentPayload<ExtArgs>
        fields: Prisma.GroupMessagesAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMessagesAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMessagesAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesAttachmentPayload>
          }
          findFirst: {
            args: Prisma.GroupMessagesAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMessagesAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesAttachmentPayload>
          }
          findMany: {
            args: Prisma.GroupMessagesAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesAttachmentPayload>[]
          }
          create: {
            args: Prisma.GroupMessagesAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesAttachmentPayload>
          }
          createMany: {
            args: Prisma.GroupMessagesAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMessagesAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesAttachmentPayload>[]
          }
          delete: {
            args: Prisma.GroupMessagesAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesAttachmentPayload>
          }
          update: {
            args: Prisma.GroupMessagesAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.GroupMessagesAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMessagesAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupMessagesAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.GroupMessagesAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagesAttachmentPayload>
          }
          aggregate: {
            args: Prisma.GroupMessagesAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMessagesAttachment>
          }
          groupBy: {
            args: Prisma.GroupMessagesAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMessagesAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMessagesAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMessagesAttachmentCountAggregateOutputType> | number
          }
        }
      }
      Friends: {
        payload: Prisma.$FriendsPayload<ExtArgs>
        fields: Prisma.FriendsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          findFirst: {
            args: Prisma.FriendsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          findMany: {
            args: Prisma.FriendsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>[]
          }
          create: {
            args: Prisma.FriendsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          createMany: {
            args: Prisma.FriendsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>[]
          }
          delete: {
            args: Prisma.FriendsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          update: {
            args: Prisma.FriendsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          deleteMany: {
            args: Prisma.FriendsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FriendsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>[]
          }
          upsert: {
            args: Prisma.FriendsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          aggregate: {
            args: Prisma.FriendsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriends>
          }
          groupBy: {
            args: Prisma.FriendsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendsCountArgs<ExtArgs>
            result: $Utils.Optional<FriendsCountAggregateOutputType> | number
          }
        }
      }
      PendingFriendRequests: {
        payload: Prisma.$PendingFriendRequestsPayload<ExtArgs>
        fields: Prisma.PendingFriendRequestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingFriendRequestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingFriendRequestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingFriendRequestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingFriendRequestsPayload>
          }
          findFirst: {
            args: Prisma.PendingFriendRequestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingFriendRequestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingFriendRequestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingFriendRequestsPayload>
          }
          findMany: {
            args: Prisma.PendingFriendRequestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingFriendRequestsPayload>[]
          }
          create: {
            args: Prisma.PendingFriendRequestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingFriendRequestsPayload>
          }
          createMany: {
            args: Prisma.PendingFriendRequestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingFriendRequestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingFriendRequestsPayload>[]
          }
          delete: {
            args: Prisma.PendingFriendRequestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingFriendRequestsPayload>
          }
          update: {
            args: Prisma.PendingFriendRequestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingFriendRequestsPayload>
          }
          deleteMany: {
            args: Prisma.PendingFriendRequestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingFriendRequestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingFriendRequestsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingFriendRequestsPayload>[]
          }
          upsert: {
            args: Prisma.PendingFriendRequestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingFriendRequestsPayload>
          }
          aggregate: {
            args: Prisma.PendingFriendRequestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingFriendRequests>
          }
          groupBy: {
            args: Prisma.PendingFriendRequestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingFriendRequestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingFriendRequestsCountArgs<ExtArgs>
            result: $Utils.Optional<PendingFriendRequestsCountAggregateOutputType> | number
          }
        }
      }
      GroupChats: {
        payload: Prisma.$GroupChatsPayload<ExtArgs>
        fields: Prisma.GroupChatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupChatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupChatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupChatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupChatsPayload>
          }
          findFirst: {
            args: Prisma.GroupChatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupChatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupChatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupChatsPayload>
          }
          findMany: {
            args: Prisma.GroupChatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupChatsPayload>[]
          }
          create: {
            args: Prisma.GroupChatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupChatsPayload>
          }
          createMany: {
            args: Prisma.GroupChatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupChatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupChatsPayload>[]
          }
          delete: {
            args: Prisma.GroupChatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupChatsPayload>
          }
          update: {
            args: Prisma.GroupChatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupChatsPayload>
          }
          deleteMany: {
            args: Prisma.GroupChatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupChatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupChatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupChatsPayload>[]
          }
          upsert: {
            args: Prisma.GroupChatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupChatsPayload>
          }
          aggregate: {
            args: Prisma.GroupChatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupChats>
          }
          groupBy: {
            args: Prisma.GroupChatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupChatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupChatsCountArgs<ExtArgs>
            result: $Utils.Optional<GroupChatsCountAggregateOutputType> | number
          }
        }
      }
      Blocks: {
        payload: Prisma.$BlocksPayload<ExtArgs>
        fields: Prisma.BlocksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlocksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlocksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocksPayload>
          }
          findFirst: {
            args: Prisma.BlocksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlocksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocksPayload>
          }
          findMany: {
            args: Prisma.BlocksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocksPayload>[]
          }
          create: {
            args: Prisma.BlocksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocksPayload>
          }
          createMany: {
            args: Prisma.BlocksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlocksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocksPayload>[]
          }
          delete: {
            args: Prisma.BlocksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocksPayload>
          }
          update: {
            args: Prisma.BlocksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocksPayload>
          }
          deleteMany: {
            args: Prisma.BlocksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlocksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlocksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocksPayload>[]
          }
          upsert: {
            args: Prisma.BlocksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocksPayload>
          }
          aggregate: {
            args: Prisma.BlocksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlocks>
          }
          groupBy: {
            args: Prisma.BlocksGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlocksGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlocksCountArgs<ExtArgs>
            result: $Utils.Optional<BlocksCountAggregateOutputType> | number
          }
        }
      }
      GroupMembers: {
        payload: Prisma.$GroupMembersPayload<ExtArgs>
        fields: Prisma.GroupMembersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMembersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMembersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembersPayload>
          }
          findFirst: {
            args: Prisma.GroupMembersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMembersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembersPayload>
          }
          findMany: {
            args: Prisma.GroupMembersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembersPayload>[]
          }
          create: {
            args: Prisma.GroupMembersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembersPayload>
          }
          createMany: {
            args: Prisma.GroupMembersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMembersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembersPayload>[]
          }
          delete: {
            args: Prisma.GroupMembersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembersPayload>
          }
          update: {
            args: Prisma.GroupMembersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembersPayload>
          }
          deleteMany: {
            args: Prisma.GroupMembersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMembersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupMembersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembersPayload>[]
          }
          upsert: {
            args: Prisma.GroupMembersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembersPayload>
          }
          aggregate: {
            args: Prisma.GroupMembersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMembers>
          }
          groupBy: {
            args: Prisma.GroupMembersGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMembersGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMembersCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMembersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: UsersOmit
    privateMessages?: PrivateMessagesOmit
    privateMessagesAttachment?: PrivateMessagesAttachmentOmit
    groupMessages?: GroupMessagesOmit
    groupMessagesAttachment?: GroupMessagesAttachmentOmit
    friends?: FriendsOmit
    pendingFriendRequests?: PendingFriendRequestsOmit
    groupChats?: GroupChatsOmit
    blocks?: BlocksOmit
    groupMembers?: GroupMembersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    messagesSent: number
    messagesReceived: number
    friends: number
    pendingRequestsSent: number
    pendingRequestsReceived: number
    Friends: number
    GroupChats: number
    GroupMembers: number
    GroupMessages: number
    blocking: number
    blockedBy: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messagesSent?: boolean | UsersCountOutputTypeCountMessagesSentArgs
    messagesReceived?: boolean | UsersCountOutputTypeCountMessagesReceivedArgs
    friends?: boolean | UsersCountOutputTypeCountFriendsArgs
    pendingRequestsSent?: boolean | UsersCountOutputTypeCountPendingRequestsSentArgs
    pendingRequestsReceived?: boolean | UsersCountOutputTypeCountPendingRequestsReceivedArgs
    Friends?: boolean | UsersCountOutputTypeCountFriendsArgs
    GroupChats?: boolean | UsersCountOutputTypeCountGroupChatsArgs
    GroupMembers?: boolean | UsersCountOutputTypeCountGroupMembersArgs
    GroupMessages?: boolean | UsersCountOutputTypeCountGroupMessagesArgs
    blocking?: boolean | UsersCountOutputTypeCountBlockingArgs
    blockedBy?: boolean | UsersCountOutputTypeCountBlockedByArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFriendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPendingRequestsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingFriendRequestsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPendingRequestsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingFriendRequestsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFriendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGroupChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupChatsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGroupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMembersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGroupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMessagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBlockingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlocksWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBlockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlocksWhereInput
  }


  /**
   * Count Type PrivateMessagesCountOutputType
   */

  export type PrivateMessagesCountOutputType = {
    attachments: number
  }

  export type PrivateMessagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | PrivateMessagesCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * PrivateMessagesCountOutputType without action
   */
  export type PrivateMessagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesCountOutputType
     */
    select?: PrivateMessagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrivateMessagesCountOutputType without action
   */
  export type PrivateMessagesCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessagesAttachmentWhereInput
  }


  /**
   * Count Type GroupMessagesCountOutputType
   */

  export type GroupMessagesCountOutputType = {
    attachments: number
  }

  export type GroupMessagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | GroupMessagesCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * GroupMessagesCountOutputType without action
   */
  export type GroupMessagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesCountOutputType
     */
    select?: GroupMessagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupMessagesCountOutputType without action
   */
  export type GroupMessagesCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMessagesAttachmentWhereInput
  }


  /**
   * Count Type GroupChatsCountOutputType
   */

  export type GroupChatsCountOutputType = {
    GroupMembers: number
    GroupMessages: number
  }

  export type GroupChatsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    GroupMembers?: boolean | GroupChatsCountOutputTypeCountGroupMembersArgs
    GroupMessages?: boolean | GroupChatsCountOutputTypeCountGroupMessagesArgs
  }

  // Custom InputTypes
  /**
   * GroupChatsCountOutputType without action
   */
  export type GroupChatsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChatsCountOutputType
     */
    select?: GroupChatsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupChatsCountOutputType without action
   */
  export type GroupChatsCountOutputTypeCountGroupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMembersWhereInput
  }

  /**
   * GroupChatsCountOutputType without action
   */
  export type GroupChatsCountOutputTypeCountGroupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMessagesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    email: string | null
    bio: string | null
    avatar: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    email: string | null
    bio: string | null
    avatar: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    username: number
    password: number
    email: number
    bio: number
    avatar: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    bio?: true
    avatar?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    bio?: true
    avatar?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    bio?: true
    avatar?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    username: string
    password: string
    email: string
    bio: string | null
    avatar: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    bio?: boolean
    avatar?: boolean
    messagesSent?: boolean | Users$messagesSentArgs<ExtArgs>
    messagesReceived?: boolean | Users$messagesReceivedArgs<ExtArgs>
    friends?: boolean | Users$friendsArgs<ExtArgs>
    pendingRequestsSent?: boolean | Users$pendingRequestsSentArgs<ExtArgs>
    pendingRequestsReceived?: boolean | Users$pendingRequestsReceivedArgs<ExtArgs>
    Friends?: boolean | Users$FriendsArgs<ExtArgs>
    GroupChats?: boolean | Users$GroupChatsArgs<ExtArgs>
    GroupMembers?: boolean | Users$GroupMembersArgs<ExtArgs>
    GroupMessages?: boolean | Users$GroupMessagesArgs<ExtArgs>
    blocking?: boolean | Users$blockingArgs<ExtArgs>
    blockedBy?: boolean | Users$blockedByArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    bio?: boolean
    avatar?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    bio?: boolean
    avatar?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    bio?: boolean
    avatar?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "email" | "bio" | "avatar", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messagesSent?: boolean | Users$messagesSentArgs<ExtArgs>
    messagesReceived?: boolean | Users$messagesReceivedArgs<ExtArgs>
    friends?: boolean | Users$friendsArgs<ExtArgs>
    pendingRequestsSent?: boolean | Users$pendingRequestsSentArgs<ExtArgs>
    pendingRequestsReceived?: boolean | Users$pendingRequestsReceivedArgs<ExtArgs>
    Friends?: boolean | Users$FriendsArgs<ExtArgs>
    GroupChats?: boolean | Users$GroupChatsArgs<ExtArgs>
    GroupMembers?: boolean | Users$GroupMembersArgs<ExtArgs>
    GroupMessages?: boolean | Users$GroupMessagesArgs<ExtArgs>
    blocking?: boolean | Users$blockingArgs<ExtArgs>
    blockedBy?: boolean | Users$blockedByArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      messagesSent: Prisma.$PrivateMessagesPayload<ExtArgs>[]
      messagesReceived: Prisma.$PrivateMessagesPayload<ExtArgs>[]
      friends: Prisma.$FriendsPayload<ExtArgs>[]
      pendingRequestsSent: Prisma.$PendingFriendRequestsPayload<ExtArgs>[]
      pendingRequestsReceived: Prisma.$PendingFriendRequestsPayload<ExtArgs>[]
      Friends: Prisma.$FriendsPayload<ExtArgs>[]
      GroupChats: Prisma.$GroupChatsPayload<ExtArgs>[]
      GroupMembers: Prisma.$GroupMembersPayload<ExtArgs>[]
      GroupMessages: Prisma.$GroupMessagesPayload<ExtArgs>[]
      blocking: Prisma.$BlocksPayload<ExtArgs>[]
      blockedBy: Prisma.$BlocksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      email: string
      bio: string | null
      avatar: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messagesSent<T extends Users$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, Users$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messagesReceived<T extends Users$messagesReceivedArgs<ExtArgs> = {}>(args?: Subset<T, Users$messagesReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friends<T extends Users$friendsArgs<ExtArgs> = {}>(args?: Subset<T, Users$friendsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pendingRequestsSent<T extends Users$pendingRequestsSentArgs<ExtArgs> = {}>(args?: Subset<T, Users$pendingRequestsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pendingRequestsReceived<T extends Users$pendingRequestsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, Users$pendingRequestsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Friends<T extends Users$FriendsArgs<ExtArgs> = {}>(args?: Subset<T, Users$FriendsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GroupChats<T extends Users$GroupChatsArgs<ExtArgs> = {}>(args?: Subset<T, Users$GroupChatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GroupMembers<T extends Users$GroupMembersArgs<ExtArgs> = {}>(args?: Subset<T, Users$GroupMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GroupMessages<T extends Users$GroupMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Users$GroupMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blocking<T extends Users$blockingArgs<ExtArgs> = {}>(args?: Subset<T, Users$blockingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blockedBy<T extends Users$blockedByArgs<ExtArgs> = {}>(args?: Subset<T, Users$blockedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'Int'>
    readonly username: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly bio: FieldRef<"Users", 'String'>
    readonly avatar: FieldRef<"Users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.messagesSent
   */
  export type Users$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
    where?: PrivateMessagesWhereInput
    orderBy?: PrivateMessagesOrderByWithRelationInput | PrivateMessagesOrderByWithRelationInput[]
    cursor?: PrivateMessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateMessagesScalarFieldEnum | PrivateMessagesScalarFieldEnum[]
  }

  /**
   * Users.messagesReceived
   */
  export type Users$messagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
    where?: PrivateMessagesWhereInput
    orderBy?: PrivateMessagesOrderByWithRelationInput | PrivateMessagesOrderByWithRelationInput[]
    cursor?: PrivateMessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateMessagesScalarFieldEnum | PrivateMessagesScalarFieldEnum[]
  }

  /**
   * Users.friends
   */
  export type Users$friendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    where?: FriendsWhereInput
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    cursor?: FriendsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Users.pendingRequestsSent
   */
  export type Users$pendingRequestsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
    where?: PendingFriendRequestsWhereInput
    orderBy?: PendingFriendRequestsOrderByWithRelationInput | PendingFriendRequestsOrderByWithRelationInput[]
    cursor?: PendingFriendRequestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingFriendRequestsScalarFieldEnum | PendingFriendRequestsScalarFieldEnum[]
  }

  /**
   * Users.pendingRequestsReceived
   */
  export type Users$pendingRequestsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
    where?: PendingFriendRequestsWhereInput
    orderBy?: PendingFriendRequestsOrderByWithRelationInput | PendingFriendRequestsOrderByWithRelationInput[]
    cursor?: PendingFriendRequestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingFriendRequestsScalarFieldEnum | PendingFriendRequestsScalarFieldEnum[]
  }

  /**
   * Users.Friends
   */
  export type Users$FriendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    where?: FriendsWhereInput
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    cursor?: FriendsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Users.GroupChats
   */
  export type Users$GroupChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsInclude<ExtArgs> | null
    where?: GroupChatsWhereInput
    orderBy?: GroupChatsOrderByWithRelationInput | GroupChatsOrderByWithRelationInput[]
    cursor?: GroupChatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupChatsScalarFieldEnum | GroupChatsScalarFieldEnum[]
  }

  /**
   * Users.GroupMembers
   */
  export type Users$GroupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
    where?: GroupMembersWhereInput
    orderBy?: GroupMembersOrderByWithRelationInput | GroupMembersOrderByWithRelationInput[]
    cursor?: GroupMembersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMembersScalarFieldEnum | GroupMembersScalarFieldEnum[]
  }

  /**
   * Users.GroupMessages
   */
  export type Users$GroupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
    where?: GroupMessagesWhereInput
    orderBy?: GroupMessagesOrderByWithRelationInput | GroupMessagesOrderByWithRelationInput[]
    cursor?: GroupMessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMessagesScalarFieldEnum | GroupMessagesScalarFieldEnum[]
  }

  /**
   * Users.blocking
   */
  export type Users$blockingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
    where?: BlocksWhereInput
    orderBy?: BlocksOrderByWithRelationInput | BlocksOrderByWithRelationInput[]
    cursor?: BlocksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * Users.blockedBy
   */
  export type Users$blockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
    where?: BlocksWhereInput
    orderBy?: BlocksOrderByWithRelationInput | BlocksOrderByWithRelationInput[]
    cursor?: BlocksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model PrivateMessages
   */

  export type AggregatePrivateMessages = {
    _count: PrivateMessagesCountAggregateOutputType | null
    _avg: PrivateMessagesAvgAggregateOutputType | null
    _sum: PrivateMessagesSumAggregateOutputType | null
    _min: PrivateMessagesMinAggregateOutputType | null
    _max: PrivateMessagesMaxAggregateOutputType | null
  }

  export type PrivateMessagesAvgAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
  }

  export type PrivateMessagesSumAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
  }

  export type PrivateMessagesMinAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
    content: string | null
    created_at: Date | null
  }

  export type PrivateMessagesMaxAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
    content: string | null
    created_at: Date | null
  }

  export type PrivateMessagesCountAggregateOutputType = {
    id: number
    sender_id: number
    receiver_id: number
    content: number
    created_at: number
    _all: number
  }


  export type PrivateMessagesAvgAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
  }

  export type PrivateMessagesSumAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
  }

  export type PrivateMessagesMinAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    content?: true
    created_at?: true
  }

  export type PrivateMessagesMaxAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    content?: true
    created_at?: true
  }

  export type PrivateMessagesCountAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    content?: true
    created_at?: true
    _all?: true
  }

  export type PrivateMessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateMessages to aggregate.
     */
    where?: PrivateMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessages to fetch.
     */
    orderBy?: PrivateMessagesOrderByWithRelationInput | PrivateMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivateMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivateMessages
    **/
    _count?: true | PrivateMessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrivateMessagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrivateMessagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivateMessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivateMessagesMaxAggregateInputType
  }

  export type GetPrivateMessagesAggregateType<T extends PrivateMessagesAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivateMessages[P]>
      : GetScalarType<T[P], AggregatePrivateMessages[P]>
  }




  export type PrivateMessagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessagesWhereInput
    orderBy?: PrivateMessagesOrderByWithAggregationInput | PrivateMessagesOrderByWithAggregationInput[]
    by: PrivateMessagesScalarFieldEnum[] | PrivateMessagesScalarFieldEnum
    having?: PrivateMessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivateMessagesCountAggregateInputType | true
    _avg?: PrivateMessagesAvgAggregateInputType
    _sum?: PrivateMessagesSumAggregateInputType
    _min?: PrivateMessagesMinAggregateInputType
    _max?: PrivateMessagesMaxAggregateInputType
  }

  export type PrivateMessagesGroupByOutputType = {
    id: number
    sender_id: number
    receiver_id: number
    content: string
    created_at: Date
    _count: PrivateMessagesCountAggregateOutputType | null
    _avg: PrivateMessagesAvgAggregateOutputType | null
    _sum: PrivateMessagesSumAggregateOutputType | null
    _min: PrivateMessagesMinAggregateOutputType | null
    _max: PrivateMessagesMaxAggregateOutputType | null
  }

  type GetPrivateMessagesGroupByPayload<T extends PrivateMessagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivateMessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivateMessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivateMessagesGroupByOutputType[P]>
            : GetScalarType<T[P], PrivateMessagesGroupByOutputType[P]>
        }
      >
    >


  export type PrivateMessagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    content?: boolean
    created_at?: boolean
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
    attachments?: boolean | PrivateMessages$attachmentsArgs<ExtArgs>
    _count?: boolean | PrivateMessagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessages"]>

  export type PrivateMessagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    content?: boolean
    created_at?: boolean
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessages"]>

  export type PrivateMessagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    content?: boolean
    created_at?: boolean
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessages"]>

  export type PrivateMessagesSelectScalar = {
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    content?: boolean
    created_at?: boolean
  }

  export type PrivateMessagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sender_id" | "receiver_id" | "content" | "created_at", ExtArgs["result"]["privateMessages"]>
  export type PrivateMessagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
    attachments?: boolean | PrivateMessages$attachmentsArgs<ExtArgs>
    _count?: boolean | PrivateMessagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrivateMessagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type PrivateMessagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $PrivateMessagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivateMessages"
    objects: {
      sender: Prisma.$UsersPayload<ExtArgs>
      receiver: Prisma.$UsersPayload<ExtArgs>
      attachments: Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sender_id: number
      receiver_id: number
      content: string
      created_at: Date
    }, ExtArgs["result"]["privateMessages"]>
    composites: {}
  }

  type PrivateMessagesGetPayload<S extends boolean | null | undefined | PrivateMessagesDefaultArgs> = $Result.GetResult<Prisma.$PrivateMessagesPayload, S>

  type PrivateMessagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivateMessagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivateMessagesCountAggregateInputType | true
    }

  export interface PrivateMessagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivateMessages'], meta: { name: 'PrivateMessages' } }
    /**
     * Find zero or one PrivateMessages that matches the filter.
     * @param {PrivateMessagesFindUniqueArgs} args - Arguments to find a PrivateMessages
     * @example
     * // Get one PrivateMessages
     * const privateMessages = await prisma.privateMessages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivateMessagesFindUniqueArgs>(args: SelectSubset<T, PrivateMessagesFindUniqueArgs<ExtArgs>>): Prisma__PrivateMessagesClient<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivateMessages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivateMessagesFindUniqueOrThrowArgs} args - Arguments to find a PrivateMessages
     * @example
     * // Get one PrivateMessages
     * const privateMessages = await prisma.privateMessages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivateMessagesFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivateMessagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivateMessagesClient<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesFindFirstArgs} args - Arguments to find a PrivateMessages
     * @example
     * // Get one PrivateMessages
     * const privateMessages = await prisma.privateMessages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivateMessagesFindFirstArgs>(args?: SelectSubset<T, PrivateMessagesFindFirstArgs<ExtArgs>>): Prisma__PrivateMessagesClient<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateMessages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesFindFirstOrThrowArgs} args - Arguments to find a PrivateMessages
     * @example
     * // Get one PrivateMessages
     * const privateMessages = await prisma.privateMessages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivateMessagesFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivateMessagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivateMessagesClient<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivateMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivateMessages
     * const privateMessages = await prisma.privateMessages.findMany()
     * 
     * // Get first 10 PrivateMessages
     * const privateMessages = await prisma.privateMessages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privateMessagesWithIdOnly = await prisma.privateMessages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivateMessagesFindManyArgs>(args?: SelectSubset<T, PrivateMessagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivateMessages.
     * @param {PrivateMessagesCreateArgs} args - Arguments to create a PrivateMessages.
     * @example
     * // Create one PrivateMessages
     * const PrivateMessages = await prisma.privateMessages.create({
     *   data: {
     *     // ... data to create a PrivateMessages
     *   }
     * })
     * 
     */
    create<T extends PrivateMessagesCreateArgs>(args: SelectSubset<T, PrivateMessagesCreateArgs<ExtArgs>>): Prisma__PrivateMessagesClient<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivateMessages.
     * @param {PrivateMessagesCreateManyArgs} args - Arguments to create many PrivateMessages.
     * @example
     * // Create many PrivateMessages
     * const privateMessages = await prisma.privateMessages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivateMessagesCreateManyArgs>(args?: SelectSubset<T, PrivateMessagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrivateMessages and returns the data saved in the database.
     * @param {PrivateMessagesCreateManyAndReturnArgs} args - Arguments to create many PrivateMessages.
     * @example
     * // Create many PrivateMessages
     * const privateMessages = await prisma.privateMessages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrivateMessages and only return the `id`
     * const privateMessagesWithIdOnly = await prisma.privateMessages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivateMessagesCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivateMessagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrivateMessages.
     * @param {PrivateMessagesDeleteArgs} args - Arguments to delete one PrivateMessages.
     * @example
     * // Delete one PrivateMessages
     * const PrivateMessages = await prisma.privateMessages.delete({
     *   where: {
     *     // ... filter to delete one PrivateMessages
     *   }
     * })
     * 
     */
    delete<T extends PrivateMessagesDeleteArgs>(args: SelectSubset<T, PrivateMessagesDeleteArgs<ExtArgs>>): Prisma__PrivateMessagesClient<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivateMessages.
     * @param {PrivateMessagesUpdateArgs} args - Arguments to update one PrivateMessages.
     * @example
     * // Update one PrivateMessages
     * const privateMessages = await prisma.privateMessages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivateMessagesUpdateArgs>(args: SelectSubset<T, PrivateMessagesUpdateArgs<ExtArgs>>): Prisma__PrivateMessagesClient<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivateMessages.
     * @param {PrivateMessagesDeleteManyArgs} args - Arguments to filter PrivateMessages to delete.
     * @example
     * // Delete a few PrivateMessages
     * const { count } = await prisma.privateMessages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivateMessagesDeleteManyArgs>(args?: SelectSubset<T, PrivateMessagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivateMessages
     * const privateMessages = await prisma.privateMessages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivateMessagesUpdateManyArgs>(args: SelectSubset<T, PrivateMessagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateMessages and returns the data updated in the database.
     * @param {PrivateMessagesUpdateManyAndReturnArgs} args - Arguments to update many PrivateMessages.
     * @example
     * // Update many PrivateMessages
     * const privateMessages = await prisma.privateMessages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrivateMessages and only return the `id`
     * const privateMessagesWithIdOnly = await prisma.privateMessages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrivateMessagesUpdateManyAndReturnArgs>(args: SelectSubset<T, PrivateMessagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrivateMessages.
     * @param {PrivateMessagesUpsertArgs} args - Arguments to update or create a PrivateMessages.
     * @example
     * // Update or create a PrivateMessages
     * const privateMessages = await prisma.privateMessages.upsert({
     *   create: {
     *     // ... data to create a PrivateMessages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivateMessages we want to update
     *   }
     * })
     */
    upsert<T extends PrivateMessagesUpsertArgs>(args: SelectSubset<T, PrivateMessagesUpsertArgs<ExtArgs>>): Prisma__PrivateMessagesClient<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivateMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesCountArgs} args - Arguments to filter PrivateMessages to count.
     * @example
     * // Count the number of PrivateMessages
     * const count = await prisma.privateMessages.count({
     *   where: {
     *     // ... the filter for the PrivateMessages we want to count
     *   }
     * })
    **/
    count<T extends PrivateMessagesCountArgs>(
      args?: Subset<T, PrivateMessagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivateMessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivateMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivateMessagesAggregateArgs>(args: Subset<T, PrivateMessagesAggregateArgs>): Prisma.PrismaPromise<GetPrivateMessagesAggregateType<T>>

    /**
     * Group by PrivateMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivateMessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivateMessagesGroupByArgs['orderBy'] }
        : { orderBy?: PrivateMessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivateMessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivateMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivateMessages model
   */
  readonly fields: PrivateMessagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivateMessages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivateMessagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends PrivateMessages$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, PrivateMessages$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivateMessages model
   */
  interface PrivateMessagesFieldRefs {
    readonly id: FieldRef<"PrivateMessages", 'Int'>
    readonly sender_id: FieldRef<"PrivateMessages", 'Int'>
    readonly receiver_id: FieldRef<"PrivateMessages", 'Int'>
    readonly content: FieldRef<"PrivateMessages", 'String'>
    readonly created_at: FieldRef<"PrivateMessages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivateMessages findUnique
   */
  export type PrivateMessagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessages to fetch.
     */
    where: PrivateMessagesWhereUniqueInput
  }

  /**
   * PrivateMessages findUniqueOrThrow
   */
  export type PrivateMessagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessages to fetch.
     */
    where: PrivateMessagesWhereUniqueInput
  }

  /**
   * PrivateMessages findFirst
   */
  export type PrivateMessagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessages to fetch.
     */
    where?: PrivateMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessages to fetch.
     */
    orderBy?: PrivateMessagesOrderByWithRelationInput | PrivateMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateMessages.
     */
    cursor?: PrivateMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateMessages.
     */
    distinct?: PrivateMessagesScalarFieldEnum | PrivateMessagesScalarFieldEnum[]
  }

  /**
   * PrivateMessages findFirstOrThrow
   */
  export type PrivateMessagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessages to fetch.
     */
    where?: PrivateMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessages to fetch.
     */
    orderBy?: PrivateMessagesOrderByWithRelationInput | PrivateMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateMessages.
     */
    cursor?: PrivateMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateMessages.
     */
    distinct?: PrivateMessagesScalarFieldEnum | PrivateMessagesScalarFieldEnum[]
  }

  /**
   * PrivateMessages findMany
   */
  export type PrivateMessagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessages to fetch.
     */
    where?: PrivateMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessages to fetch.
     */
    orderBy?: PrivateMessagesOrderByWithRelationInput | PrivateMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivateMessages.
     */
    cursor?: PrivateMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessages.
     */
    skip?: number
    distinct?: PrivateMessagesScalarFieldEnum | PrivateMessagesScalarFieldEnum[]
  }

  /**
   * PrivateMessages create
   */
  export type PrivateMessagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
    /**
     * The data needed to create a PrivateMessages.
     */
    data: XOR<PrivateMessagesCreateInput, PrivateMessagesUncheckedCreateInput>
  }

  /**
   * PrivateMessages createMany
   */
  export type PrivateMessagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivateMessages.
     */
    data: PrivateMessagesCreateManyInput | PrivateMessagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivateMessages createManyAndReturn
   */
  export type PrivateMessagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * The data used to create many PrivateMessages.
     */
    data: PrivateMessagesCreateManyInput | PrivateMessagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateMessages update
   */
  export type PrivateMessagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
    /**
     * The data needed to update a PrivateMessages.
     */
    data: XOR<PrivateMessagesUpdateInput, PrivateMessagesUncheckedUpdateInput>
    /**
     * Choose, which PrivateMessages to update.
     */
    where: PrivateMessagesWhereUniqueInput
  }

  /**
   * PrivateMessages updateMany
   */
  export type PrivateMessagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivateMessages.
     */
    data: XOR<PrivateMessagesUpdateManyMutationInput, PrivateMessagesUncheckedUpdateManyInput>
    /**
     * Filter which PrivateMessages to update
     */
    where?: PrivateMessagesWhereInput
    /**
     * Limit how many PrivateMessages to update.
     */
    limit?: number
  }

  /**
   * PrivateMessages updateManyAndReturn
   */
  export type PrivateMessagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * The data used to update PrivateMessages.
     */
    data: XOR<PrivateMessagesUpdateManyMutationInput, PrivateMessagesUncheckedUpdateManyInput>
    /**
     * Filter which PrivateMessages to update
     */
    where?: PrivateMessagesWhereInput
    /**
     * Limit how many PrivateMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateMessages upsert
   */
  export type PrivateMessagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
    /**
     * The filter to search for the PrivateMessages to update in case it exists.
     */
    where: PrivateMessagesWhereUniqueInput
    /**
     * In case the PrivateMessages found by the `where` argument doesn't exist, create a new PrivateMessages with this data.
     */
    create: XOR<PrivateMessagesCreateInput, PrivateMessagesUncheckedCreateInput>
    /**
     * In case the PrivateMessages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivateMessagesUpdateInput, PrivateMessagesUncheckedUpdateInput>
  }

  /**
   * PrivateMessages delete
   */
  export type PrivateMessagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
    /**
     * Filter which PrivateMessages to delete.
     */
    where: PrivateMessagesWhereUniqueInput
  }

  /**
   * PrivateMessages deleteMany
   */
  export type PrivateMessagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateMessages to delete
     */
    where?: PrivateMessagesWhereInput
    /**
     * Limit how many PrivateMessages to delete.
     */
    limit?: number
  }

  /**
   * PrivateMessages.attachments
   */
  export type PrivateMessages$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentInclude<ExtArgs> | null
    where?: PrivateMessagesAttachmentWhereInput
    orderBy?: PrivateMessagesAttachmentOrderByWithRelationInput | PrivateMessagesAttachmentOrderByWithRelationInput[]
    cursor?: PrivateMessagesAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateMessagesAttachmentScalarFieldEnum | PrivateMessagesAttachmentScalarFieldEnum[]
  }

  /**
   * PrivateMessages without action
   */
  export type PrivateMessagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessages
     */
    select?: PrivateMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessages
     */
    omit?: PrivateMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesInclude<ExtArgs> | null
  }


  /**
   * Model PrivateMessagesAttachment
   */

  export type AggregatePrivateMessagesAttachment = {
    _count: PrivateMessagesAttachmentCountAggregateOutputType | null
    _avg: PrivateMessagesAttachmentAvgAggregateOutputType | null
    _sum: PrivateMessagesAttachmentSumAggregateOutputType | null
    _min: PrivateMessagesAttachmentMinAggregateOutputType | null
    _max: PrivateMessagesAttachmentMaxAggregateOutputType | null
  }

  export type PrivateMessagesAttachmentAvgAggregateOutputType = {
    id: number | null
    message_id: number | null
    size: number | null
  }

  export type PrivateMessagesAttachmentSumAggregateOutputType = {
    id: number | null
    message_id: number | null
    size: number | null
  }

  export type PrivateMessagesAttachmentMinAggregateOutputType = {
    id: number | null
    message_id: number | null
    size: number | null
    path: string | null
    originalName: string | null
    uniqueFileName: string | null
    created_at: Date | null
  }

  export type PrivateMessagesAttachmentMaxAggregateOutputType = {
    id: number | null
    message_id: number | null
    size: number | null
    path: string | null
    originalName: string | null
    uniqueFileName: string | null
    created_at: Date | null
  }

  export type PrivateMessagesAttachmentCountAggregateOutputType = {
    id: number
    message_id: number
    size: number
    path: number
    originalName: number
    uniqueFileName: number
    created_at: number
    _all: number
  }


  export type PrivateMessagesAttachmentAvgAggregateInputType = {
    id?: true
    message_id?: true
    size?: true
  }

  export type PrivateMessagesAttachmentSumAggregateInputType = {
    id?: true
    message_id?: true
    size?: true
  }

  export type PrivateMessagesAttachmentMinAggregateInputType = {
    id?: true
    message_id?: true
    size?: true
    path?: true
    originalName?: true
    uniqueFileName?: true
    created_at?: true
  }

  export type PrivateMessagesAttachmentMaxAggregateInputType = {
    id?: true
    message_id?: true
    size?: true
    path?: true
    originalName?: true
    uniqueFileName?: true
    created_at?: true
  }

  export type PrivateMessagesAttachmentCountAggregateInputType = {
    id?: true
    message_id?: true
    size?: true
    path?: true
    originalName?: true
    uniqueFileName?: true
    created_at?: true
    _all?: true
  }

  export type PrivateMessagesAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateMessagesAttachment to aggregate.
     */
    where?: PrivateMessagesAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessagesAttachments to fetch.
     */
    orderBy?: PrivateMessagesAttachmentOrderByWithRelationInput | PrivateMessagesAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivateMessagesAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessagesAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessagesAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivateMessagesAttachments
    **/
    _count?: true | PrivateMessagesAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrivateMessagesAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrivateMessagesAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivateMessagesAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivateMessagesAttachmentMaxAggregateInputType
  }

  export type GetPrivateMessagesAttachmentAggregateType<T extends PrivateMessagesAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivateMessagesAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivateMessagesAttachment[P]>
      : GetScalarType<T[P], AggregatePrivateMessagesAttachment[P]>
  }




  export type PrivateMessagesAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessagesAttachmentWhereInput
    orderBy?: PrivateMessagesAttachmentOrderByWithAggregationInput | PrivateMessagesAttachmentOrderByWithAggregationInput[]
    by: PrivateMessagesAttachmentScalarFieldEnum[] | PrivateMessagesAttachmentScalarFieldEnum
    having?: PrivateMessagesAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivateMessagesAttachmentCountAggregateInputType | true
    _avg?: PrivateMessagesAttachmentAvgAggregateInputType
    _sum?: PrivateMessagesAttachmentSumAggregateInputType
    _min?: PrivateMessagesAttachmentMinAggregateInputType
    _max?: PrivateMessagesAttachmentMaxAggregateInputType
  }

  export type PrivateMessagesAttachmentGroupByOutputType = {
    id: number
    message_id: number
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at: Date
    _count: PrivateMessagesAttachmentCountAggregateOutputType | null
    _avg: PrivateMessagesAttachmentAvgAggregateOutputType | null
    _sum: PrivateMessagesAttachmentSumAggregateOutputType | null
    _min: PrivateMessagesAttachmentMinAggregateOutputType | null
    _max: PrivateMessagesAttachmentMaxAggregateOutputType | null
  }

  type GetPrivateMessagesAttachmentGroupByPayload<T extends PrivateMessagesAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivateMessagesAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivateMessagesAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivateMessagesAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], PrivateMessagesAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type PrivateMessagesAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_id?: boolean
    size?: boolean
    path?: boolean
    originalName?: boolean
    uniqueFileName?: boolean
    created_at?: boolean
    privateMessage?: boolean | PrivateMessagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessagesAttachment"]>

  export type PrivateMessagesAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_id?: boolean
    size?: boolean
    path?: boolean
    originalName?: boolean
    uniqueFileName?: boolean
    created_at?: boolean
    privateMessage?: boolean | PrivateMessagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessagesAttachment"]>

  export type PrivateMessagesAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_id?: boolean
    size?: boolean
    path?: boolean
    originalName?: boolean
    uniqueFileName?: boolean
    created_at?: boolean
    privateMessage?: boolean | PrivateMessagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessagesAttachment"]>

  export type PrivateMessagesAttachmentSelectScalar = {
    id?: boolean
    message_id?: boolean
    size?: boolean
    path?: boolean
    originalName?: boolean
    uniqueFileName?: boolean
    created_at?: boolean
  }

  export type PrivateMessagesAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message_id" | "size" | "path" | "originalName" | "uniqueFileName" | "created_at", ExtArgs["result"]["privateMessagesAttachment"]>
  export type PrivateMessagesAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    privateMessage?: boolean | PrivateMessagesDefaultArgs<ExtArgs>
  }
  export type PrivateMessagesAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    privateMessage?: boolean | PrivateMessagesDefaultArgs<ExtArgs>
  }
  export type PrivateMessagesAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    privateMessage?: boolean | PrivateMessagesDefaultArgs<ExtArgs>
  }

  export type $PrivateMessagesAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivateMessagesAttachment"
    objects: {
      privateMessage: Prisma.$PrivateMessagesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      message_id: number
      size: number
      path: string
      originalName: string
      uniqueFileName: string
      created_at: Date
    }, ExtArgs["result"]["privateMessagesAttachment"]>
    composites: {}
  }

  type PrivateMessagesAttachmentGetPayload<S extends boolean | null | undefined | PrivateMessagesAttachmentDefaultArgs> = $Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload, S>

  type PrivateMessagesAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivateMessagesAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivateMessagesAttachmentCountAggregateInputType | true
    }

  export interface PrivateMessagesAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivateMessagesAttachment'], meta: { name: 'PrivateMessagesAttachment' } }
    /**
     * Find zero or one PrivateMessagesAttachment that matches the filter.
     * @param {PrivateMessagesAttachmentFindUniqueArgs} args - Arguments to find a PrivateMessagesAttachment
     * @example
     * // Get one PrivateMessagesAttachment
     * const privateMessagesAttachment = await prisma.privateMessagesAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivateMessagesAttachmentFindUniqueArgs>(args: SelectSubset<T, PrivateMessagesAttachmentFindUniqueArgs<ExtArgs>>): Prisma__PrivateMessagesAttachmentClient<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivateMessagesAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivateMessagesAttachmentFindUniqueOrThrowArgs} args - Arguments to find a PrivateMessagesAttachment
     * @example
     * // Get one PrivateMessagesAttachment
     * const privateMessagesAttachment = await prisma.privateMessagesAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivateMessagesAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivateMessagesAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivateMessagesAttachmentClient<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateMessagesAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesAttachmentFindFirstArgs} args - Arguments to find a PrivateMessagesAttachment
     * @example
     * // Get one PrivateMessagesAttachment
     * const privateMessagesAttachment = await prisma.privateMessagesAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivateMessagesAttachmentFindFirstArgs>(args?: SelectSubset<T, PrivateMessagesAttachmentFindFirstArgs<ExtArgs>>): Prisma__PrivateMessagesAttachmentClient<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateMessagesAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesAttachmentFindFirstOrThrowArgs} args - Arguments to find a PrivateMessagesAttachment
     * @example
     * // Get one PrivateMessagesAttachment
     * const privateMessagesAttachment = await prisma.privateMessagesAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivateMessagesAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivateMessagesAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivateMessagesAttachmentClient<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivateMessagesAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivateMessagesAttachments
     * const privateMessagesAttachments = await prisma.privateMessagesAttachment.findMany()
     * 
     * // Get first 10 PrivateMessagesAttachments
     * const privateMessagesAttachments = await prisma.privateMessagesAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privateMessagesAttachmentWithIdOnly = await prisma.privateMessagesAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivateMessagesAttachmentFindManyArgs>(args?: SelectSubset<T, PrivateMessagesAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivateMessagesAttachment.
     * @param {PrivateMessagesAttachmentCreateArgs} args - Arguments to create a PrivateMessagesAttachment.
     * @example
     * // Create one PrivateMessagesAttachment
     * const PrivateMessagesAttachment = await prisma.privateMessagesAttachment.create({
     *   data: {
     *     // ... data to create a PrivateMessagesAttachment
     *   }
     * })
     * 
     */
    create<T extends PrivateMessagesAttachmentCreateArgs>(args: SelectSubset<T, PrivateMessagesAttachmentCreateArgs<ExtArgs>>): Prisma__PrivateMessagesAttachmentClient<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivateMessagesAttachments.
     * @param {PrivateMessagesAttachmentCreateManyArgs} args - Arguments to create many PrivateMessagesAttachments.
     * @example
     * // Create many PrivateMessagesAttachments
     * const privateMessagesAttachment = await prisma.privateMessagesAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivateMessagesAttachmentCreateManyArgs>(args?: SelectSubset<T, PrivateMessagesAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrivateMessagesAttachments and returns the data saved in the database.
     * @param {PrivateMessagesAttachmentCreateManyAndReturnArgs} args - Arguments to create many PrivateMessagesAttachments.
     * @example
     * // Create many PrivateMessagesAttachments
     * const privateMessagesAttachment = await prisma.privateMessagesAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrivateMessagesAttachments and only return the `id`
     * const privateMessagesAttachmentWithIdOnly = await prisma.privateMessagesAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivateMessagesAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivateMessagesAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrivateMessagesAttachment.
     * @param {PrivateMessagesAttachmentDeleteArgs} args - Arguments to delete one PrivateMessagesAttachment.
     * @example
     * // Delete one PrivateMessagesAttachment
     * const PrivateMessagesAttachment = await prisma.privateMessagesAttachment.delete({
     *   where: {
     *     // ... filter to delete one PrivateMessagesAttachment
     *   }
     * })
     * 
     */
    delete<T extends PrivateMessagesAttachmentDeleteArgs>(args: SelectSubset<T, PrivateMessagesAttachmentDeleteArgs<ExtArgs>>): Prisma__PrivateMessagesAttachmentClient<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivateMessagesAttachment.
     * @param {PrivateMessagesAttachmentUpdateArgs} args - Arguments to update one PrivateMessagesAttachment.
     * @example
     * // Update one PrivateMessagesAttachment
     * const privateMessagesAttachment = await prisma.privateMessagesAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivateMessagesAttachmentUpdateArgs>(args: SelectSubset<T, PrivateMessagesAttachmentUpdateArgs<ExtArgs>>): Prisma__PrivateMessagesAttachmentClient<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivateMessagesAttachments.
     * @param {PrivateMessagesAttachmentDeleteManyArgs} args - Arguments to filter PrivateMessagesAttachments to delete.
     * @example
     * // Delete a few PrivateMessagesAttachments
     * const { count } = await prisma.privateMessagesAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivateMessagesAttachmentDeleteManyArgs>(args?: SelectSubset<T, PrivateMessagesAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateMessagesAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivateMessagesAttachments
     * const privateMessagesAttachment = await prisma.privateMessagesAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivateMessagesAttachmentUpdateManyArgs>(args: SelectSubset<T, PrivateMessagesAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateMessagesAttachments and returns the data updated in the database.
     * @param {PrivateMessagesAttachmentUpdateManyAndReturnArgs} args - Arguments to update many PrivateMessagesAttachments.
     * @example
     * // Update many PrivateMessagesAttachments
     * const privateMessagesAttachment = await prisma.privateMessagesAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrivateMessagesAttachments and only return the `id`
     * const privateMessagesAttachmentWithIdOnly = await prisma.privateMessagesAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrivateMessagesAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, PrivateMessagesAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrivateMessagesAttachment.
     * @param {PrivateMessagesAttachmentUpsertArgs} args - Arguments to update or create a PrivateMessagesAttachment.
     * @example
     * // Update or create a PrivateMessagesAttachment
     * const privateMessagesAttachment = await prisma.privateMessagesAttachment.upsert({
     *   create: {
     *     // ... data to create a PrivateMessagesAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivateMessagesAttachment we want to update
     *   }
     * })
     */
    upsert<T extends PrivateMessagesAttachmentUpsertArgs>(args: SelectSubset<T, PrivateMessagesAttachmentUpsertArgs<ExtArgs>>): Prisma__PrivateMessagesAttachmentClient<$Result.GetResult<Prisma.$PrivateMessagesAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivateMessagesAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesAttachmentCountArgs} args - Arguments to filter PrivateMessagesAttachments to count.
     * @example
     * // Count the number of PrivateMessagesAttachments
     * const count = await prisma.privateMessagesAttachment.count({
     *   where: {
     *     // ... the filter for the PrivateMessagesAttachments we want to count
     *   }
     * })
    **/
    count<T extends PrivateMessagesAttachmentCountArgs>(
      args?: Subset<T, PrivateMessagesAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivateMessagesAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivateMessagesAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivateMessagesAttachmentAggregateArgs>(args: Subset<T, PrivateMessagesAttachmentAggregateArgs>): Prisma.PrismaPromise<GetPrivateMessagesAttachmentAggregateType<T>>

    /**
     * Group by PrivateMessagesAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessagesAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivateMessagesAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivateMessagesAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: PrivateMessagesAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivateMessagesAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivateMessagesAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivateMessagesAttachment model
   */
  readonly fields: PrivateMessagesAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivateMessagesAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivateMessagesAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    privateMessage<T extends PrivateMessagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrivateMessagesDefaultArgs<ExtArgs>>): Prisma__PrivateMessagesClient<$Result.GetResult<Prisma.$PrivateMessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivateMessagesAttachment model
   */
  interface PrivateMessagesAttachmentFieldRefs {
    readonly id: FieldRef<"PrivateMessagesAttachment", 'Int'>
    readonly message_id: FieldRef<"PrivateMessagesAttachment", 'Int'>
    readonly size: FieldRef<"PrivateMessagesAttachment", 'Int'>
    readonly path: FieldRef<"PrivateMessagesAttachment", 'String'>
    readonly originalName: FieldRef<"PrivateMessagesAttachment", 'String'>
    readonly uniqueFileName: FieldRef<"PrivateMessagesAttachment", 'String'>
    readonly created_at: FieldRef<"PrivateMessagesAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivateMessagesAttachment findUnique
   */
  export type PrivateMessagesAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessagesAttachment to fetch.
     */
    where: PrivateMessagesAttachmentWhereUniqueInput
  }

  /**
   * PrivateMessagesAttachment findUniqueOrThrow
   */
  export type PrivateMessagesAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessagesAttachment to fetch.
     */
    where: PrivateMessagesAttachmentWhereUniqueInput
  }

  /**
   * PrivateMessagesAttachment findFirst
   */
  export type PrivateMessagesAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessagesAttachment to fetch.
     */
    where?: PrivateMessagesAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessagesAttachments to fetch.
     */
    orderBy?: PrivateMessagesAttachmentOrderByWithRelationInput | PrivateMessagesAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateMessagesAttachments.
     */
    cursor?: PrivateMessagesAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessagesAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessagesAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateMessagesAttachments.
     */
    distinct?: PrivateMessagesAttachmentScalarFieldEnum | PrivateMessagesAttachmentScalarFieldEnum[]
  }

  /**
   * PrivateMessagesAttachment findFirstOrThrow
   */
  export type PrivateMessagesAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessagesAttachment to fetch.
     */
    where?: PrivateMessagesAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessagesAttachments to fetch.
     */
    orderBy?: PrivateMessagesAttachmentOrderByWithRelationInput | PrivateMessagesAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateMessagesAttachments.
     */
    cursor?: PrivateMessagesAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessagesAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessagesAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateMessagesAttachments.
     */
    distinct?: PrivateMessagesAttachmentScalarFieldEnum | PrivateMessagesAttachmentScalarFieldEnum[]
  }

  /**
   * PrivateMessagesAttachment findMany
   */
  export type PrivateMessagesAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessagesAttachments to fetch.
     */
    where?: PrivateMessagesAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessagesAttachments to fetch.
     */
    orderBy?: PrivateMessagesAttachmentOrderByWithRelationInput | PrivateMessagesAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivateMessagesAttachments.
     */
    cursor?: PrivateMessagesAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessagesAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessagesAttachments.
     */
    skip?: number
    distinct?: PrivateMessagesAttachmentScalarFieldEnum | PrivateMessagesAttachmentScalarFieldEnum[]
  }

  /**
   * PrivateMessagesAttachment create
   */
  export type PrivateMessagesAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PrivateMessagesAttachment.
     */
    data: XOR<PrivateMessagesAttachmentCreateInput, PrivateMessagesAttachmentUncheckedCreateInput>
  }

  /**
   * PrivateMessagesAttachment createMany
   */
  export type PrivateMessagesAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivateMessagesAttachments.
     */
    data: PrivateMessagesAttachmentCreateManyInput | PrivateMessagesAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivateMessagesAttachment createManyAndReturn
   */
  export type PrivateMessagesAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many PrivateMessagesAttachments.
     */
    data: PrivateMessagesAttachmentCreateManyInput | PrivateMessagesAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateMessagesAttachment update
   */
  export type PrivateMessagesAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PrivateMessagesAttachment.
     */
    data: XOR<PrivateMessagesAttachmentUpdateInput, PrivateMessagesAttachmentUncheckedUpdateInput>
    /**
     * Choose, which PrivateMessagesAttachment to update.
     */
    where: PrivateMessagesAttachmentWhereUniqueInput
  }

  /**
   * PrivateMessagesAttachment updateMany
   */
  export type PrivateMessagesAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivateMessagesAttachments.
     */
    data: XOR<PrivateMessagesAttachmentUpdateManyMutationInput, PrivateMessagesAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which PrivateMessagesAttachments to update
     */
    where?: PrivateMessagesAttachmentWhereInput
    /**
     * Limit how many PrivateMessagesAttachments to update.
     */
    limit?: number
  }

  /**
   * PrivateMessagesAttachment updateManyAndReturn
   */
  export type PrivateMessagesAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update PrivateMessagesAttachments.
     */
    data: XOR<PrivateMessagesAttachmentUpdateManyMutationInput, PrivateMessagesAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which PrivateMessagesAttachments to update
     */
    where?: PrivateMessagesAttachmentWhereInput
    /**
     * Limit how many PrivateMessagesAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateMessagesAttachment upsert
   */
  export type PrivateMessagesAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PrivateMessagesAttachment to update in case it exists.
     */
    where: PrivateMessagesAttachmentWhereUniqueInput
    /**
     * In case the PrivateMessagesAttachment found by the `where` argument doesn't exist, create a new PrivateMessagesAttachment with this data.
     */
    create: XOR<PrivateMessagesAttachmentCreateInput, PrivateMessagesAttachmentUncheckedCreateInput>
    /**
     * In case the PrivateMessagesAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivateMessagesAttachmentUpdateInput, PrivateMessagesAttachmentUncheckedUpdateInput>
  }

  /**
   * PrivateMessagesAttachment delete
   */
  export type PrivateMessagesAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter which PrivateMessagesAttachment to delete.
     */
    where: PrivateMessagesAttachmentWhereUniqueInput
  }

  /**
   * PrivateMessagesAttachment deleteMany
   */
  export type PrivateMessagesAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateMessagesAttachments to delete
     */
    where?: PrivateMessagesAttachmentWhereInput
    /**
     * Limit how many PrivateMessagesAttachments to delete.
     */
    limit?: number
  }

  /**
   * PrivateMessagesAttachment without action
   */
  export type PrivateMessagesAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessagesAttachment
     */
    select?: PrivateMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessagesAttachment
     */
    omit?: PrivateMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessagesAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model GroupMessages
   */

  export type AggregateGroupMessages = {
    _count: GroupMessagesCountAggregateOutputType | null
    _avg: GroupMessagesAvgAggregateOutputType | null
    _sum: GroupMessagesSumAggregateOutputType | null
    _min: GroupMessagesMinAggregateOutputType | null
    _max: GroupMessagesMaxAggregateOutputType | null
  }

  export type GroupMessagesAvgAggregateOutputType = {
    id: number | null
    sender_id: number | null
    group_id: number | null
  }

  export type GroupMessagesSumAggregateOutputType = {
    id: number | null
    sender_id: number | null
    group_id: number | null
  }

  export type GroupMessagesMinAggregateOutputType = {
    id: number | null
    sender_id: number | null
    group_id: number | null
    content: string | null
    created_at: Date | null
  }

  export type GroupMessagesMaxAggregateOutputType = {
    id: number | null
    sender_id: number | null
    group_id: number | null
    content: string | null
    created_at: Date | null
  }

  export type GroupMessagesCountAggregateOutputType = {
    id: number
    sender_id: number
    group_id: number
    content: number
    created_at: number
    _all: number
  }


  export type GroupMessagesAvgAggregateInputType = {
    id?: true
    sender_id?: true
    group_id?: true
  }

  export type GroupMessagesSumAggregateInputType = {
    id?: true
    sender_id?: true
    group_id?: true
  }

  export type GroupMessagesMinAggregateInputType = {
    id?: true
    sender_id?: true
    group_id?: true
    content?: true
    created_at?: true
  }

  export type GroupMessagesMaxAggregateInputType = {
    id?: true
    sender_id?: true
    group_id?: true
    content?: true
    created_at?: true
  }

  export type GroupMessagesCountAggregateInputType = {
    id?: true
    sender_id?: true
    group_id?: true
    content?: true
    created_at?: true
    _all?: true
  }

  export type GroupMessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMessages to aggregate.
     */
    where?: GroupMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessages to fetch.
     */
    orderBy?: GroupMessagesOrderByWithRelationInput | GroupMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMessages
    **/
    _count?: true | GroupMessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupMessagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupMessagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMessagesMaxAggregateInputType
  }

  export type GetGroupMessagesAggregateType<T extends GroupMessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMessages[P]>
      : GetScalarType<T[P], AggregateGroupMessages[P]>
  }




  export type GroupMessagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMessagesWhereInput
    orderBy?: GroupMessagesOrderByWithAggregationInput | GroupMessagesOrderByWithAggregationInput[]
    by: GroupMessagesScalarFieldEnum[] | GroupMessagesScalarFieldEnum
    having?: GroupMessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMessagesCountAggregateInputType | true
    _avg?: GroupMessagesAvgAggregateInputType
    _sum?: GroupMessagesSumAggregateInputType
    _min?: GroupMessagesMinAggregateInputType
    _max?: GroupMessagesMaxAggregateInputType
  }

  export type GroupMessagesGroupByOutputType = {
    id: number
    sender_id: number
    group_id: number
    content: string
    created_at: Date
    _count: GroupMessagesCountAggregateOutputType | null
    _avg: GroupMessagesAvgAggregateOutputType | null
    _sum: GroupMessagesSumAggregateOutputType | null
    _min: GroupMessagesMinAggregateOutputType | null
    _max: GroupMessagesMaxAggregateOutputType | null
  }

  type GetGroupMessagesGroupByPayload<T extends GroupMessagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMessagesGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMessagesGroupByOutputType[P]>
        }
      >
    >


  export type GroupMessagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    group_id?: boolean
    content?: boolean
    created_at?: boolean
    group?: boolean | GroupChatsDefaultArgs<ExtArgs>
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    attachments?: boolean | GroupMessages$attachmentsArgs<ExtArgs>
    _count?: boolean | GroupMessagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessages"]>

  export type GroupMessagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    group_id?: boolean
    content?: boolean
    created_at?: boolean
    group?: boolean | GroupChatsDefaultArgs<ExtArgs>
    sender?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessages"]>

  export type GroupMessagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    group_id?: boolean
    content?: boolean
    created_at?: boolean
    group?: boolean | GroupChatsDefaultArgs<ExtArgs>
    sender?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessages"]>

  export type GroupMessagesSelectScalar = {
    id?: boolean
    sender_id?: boolean
    group_id?: boolean
    content?: boolean
    created_at?: boolean
  }

  export type GroupMessagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sender_id" | "group_id" | "content" | "created_at", ExtArgs["result"]["groupMessages"]>
  export type GroupMessagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupChatsDefaultArgs<ExtArgs>
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    attachments?: boolean | GroupMessages$attachmentsArgs<ExtArgs>
    _count?: boolean | GroupMessagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupMessagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupChatsDefaultArgs<ExtArgs>
    sender?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type GroupMessagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupChatsDefaultArgs<ExtArgs>
    sender?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $GroupMessagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMessages"
    objects: {
      group: Prisma.$GroupChatsPayload<ExtArgs>
      sender: Prisma.$UsersPayload<ExtArgs>
      attachments: Prisma.$GroupMessagesAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sender_id: number
      group_id: number
      content: string
      created_at: Date
    }, ExtArgs["result"]["groupMessages"]>
    composites: {}
  }

  type GroupMessagesGetPayload<S extends boolean | null | undefined | GroupMessagesDefaultArgs> = $Result.GetResult<Prisma.$GroupMessagesPayload, S>

  type GroupMessagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMessagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMessagesCountAggregateInputType | true
    }

  export interface GroupMessagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMessages'], meta: { name: 'GroupMessages' } }
    /**
     * Find zero or one GroupMessages that matches the filter.
     * @param {GroupMessagesFindUniqueArgs} args - Arguments to find a GroupMessages
     * @example
     * // Get one GroupMessages
     * const groupMessages = await prisma.groupMessages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMessagesFindUniqueArgs>(args: SelectSubset<T, GroupMessagesFindUniqueArgs<ExtArgs>>): Prisma__GroupMessagesClient<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMessages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMessagesFindUniqueOrThrowArgs} args - Arguments to find a GroupMessages
     * @example
     * // Get one GroupMessages
     * const groupMessages = await prisma.groupMessages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMessagesFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMessagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMessagesClient<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesFindFirstArgs} args - Arguments to find a GroupMessages
     * @example
     * // Get one GroupMessages
     * const groupMessages = await prisma.groupMessages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMessagesFindFirstArgs>(args?: SelectSubset<T, GroupMessagesFindFirstArgs<ExtArgs>>): Prisma__GroupMessagesClient<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMessages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesFindFirstOrThrowArgs} args - Arguments to find a GroupMessages
     * @example
     * // Get one GroupMessages
     * const groupMessages = await prisma.groupMessages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMessagesFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMessagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMessagesClient<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMessages
     * const groupMessages = await prisma.groupMessages.findMany()
     * 
     * // Get first 10 GroupMessages
     * const groupMessages = await prisma.groupMessages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMessagesWithIdOnly = await prisma.groupMessages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMessagesFindManyArgs>(args?: SelectSubset<T, GroupMessagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMessages.
     * @param {GroupMessagesCreateArgs} args - Arguments to create a GroupMessages.
     * @example
     * // Create one GroupMessages
     * const GroupMessages = await prisma.groupMessages.create({
     *   data: {
     *     // ... data to create a GroupMessages
     *   }
     * })
     * 
     */
    create<T extends GroupMessagesCreateArgs>(args: SelectSubset<T, GroupMessagesCreateArgs<ExtArgs>>): Prisma__GroupMessagesClient<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMessages.
     * @param {GroupMessagesCreateManyArgs} args - Arguments to create many GroupMessages.
     * @example
     * // Create many GroupMessages
     * const groupMessages = await prisma.groupMessages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMessagesCreateManyArgs>(args?: SelectSubset<T, GroupMessagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMessages and returns the data saved in the database.
     * @param {GroupMessagesCreateManyAndReturnArgs} args - Arguments to create many GroupMessages.
     * @example
     * // Create many GroupMessages
     * const groupMessages = await prisma.groupMessages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMessages and only return the `id`
     * const groupMessagesWithIdOnly = await prisma.groupMessages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMessagesCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMessagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupMessages.
     * @param {GroupMessagesDeleteArgs} args - Arguments to delete one GroupMessages.
     * @example
     * // Delete one GroupMessages
     * const GroupMessages = await prisma.groupMessages.delete({
     *   where: {
     *     // ... filter to delete one GroupMessages
     *   }
     * })
     * 
     */
    delete<T extends GroupMessagesDeleteArgs>(args: SelectSubset<T, GroupMessagesDeleteArgs<ExtArgs>>): Prisma__GroupMessagesClient<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMessages.
     * @param {GroupMessagesUpdateArgs} args - Arguments to update one GroupMessages.
     * @example
     * // Update one GroupMessages
     * const groupMessages = await prisma.groupMessages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMessagesUpdateArgs>(args: SelectSubset<T, GroupMessagesUpdateArgs<ExtArgs>>): Prisma__GroupMessagesClient<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMessages.
     * @param {GroupMessagesDeleteManyArgs} args - Arguments to filter GroupMessages to delete.
     * @example
     * // Delete a few GroupMessages
     * const { count } = await prisma.groupMessages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMessagesDeleteManyArgs>(args?: SelectSubset<T, GroupMessagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMessages
     * const groupMessages = await prisma.groupMessages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMessagesUpdateManyArgs>(args: SelectSubset<T, GroupMessagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMessages and returns the data updated in the database.
     * @param {GroupMessagesUpdateManyAndReturnArgs} args - Arguments to update many GroupMessages.
     * @example
     * // Update many GroupMessages
     * const groupMessages = await prisma.groupMessages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMessages and only return the `id`
     * const groupMessagesWithIdOnly = await prisma.groupMessages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupMessagesUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupMessagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupMessages.
     * @param {GroupMessagesUpsertArgs} args - Arguments to update or create a GroupMessages.
     * @example
     * // Update or create a GroupMessages
     * const groupMessages = await prisma.groupMessages.upsert({
     *   create: {
     *     // ... data to create a GroupMessages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMessages we want to update
     *   }
     * })
     */
    upsert<T extends GroupMessagesUpsertArgs>(args: SelectSubset<T, GroupMessagesUpsertArgs<ExtArgs>>): Prisma__GroupMessagesClient<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesCountArgs} args - Arguments to filter GroupMessages to count.
     * @example
     * // Count the number of GroupMessages
     * const count = await prisma.groupMessages.count({
     *   where: {
     *     // ... the filter for the GroupMessages we want to count
     *   }
     * })
    **/
    count<T extends GroupMessagesCountArgs>(
      args?: Subset<T, GroupMessagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMessagesAggregateArgs>(args: Subset<T, GroupMessagesAggregateArgs>): Prisma.PrismaPromise<GetGroupMessagesAggregateType<T>>

    /**
     * Group by GroupMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMessagesGroupByArgs['orderBy'] }
        : { orderBy?: GroupMessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMessages model
   */
  readonly fields: GroupMessagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMessages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMessagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupChatsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupChatsDefaultArgs<ExtArgs>>): Prisma__GroupChatsClient<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends GroupMessages$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, GroupMessages$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMessages model
   */
  interface GroupMessagesFieldRefs {
    readonly id: FieldRef<"GroupMessages", 'Int'>
    readonly sender_id: FieldRef<"GroupMessages", 'Int'>
    readonly group_id: FieldRef<"GroupMessages", 'Int'>
    readonly content: FieldRef<"GroupMessages", 'String'>
    readonly created_at: FieldRef<"GroupMessages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMessages findUnique
   */
  export type GroupMessagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessages to fetch.
     */
    where: GroupMessagesWhereUniqueInput
  }

  /**
   * GroupMessages findUniqueOrThrow
   */
  export type GroupMessagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessages to fetch.
     */
    where: GroupMessagesWhereUniqueInput
  }

  /**
   * GroupMessages findFirst
   */
  export type GroupMessagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessages to fetch.
     */
    where?: GroupMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessages to fetch.
     */
    orderBy?: GroupMessagesOrderByWithRelationInput | GroupMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMessages.
     */
    cursor?: GroupMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMessages.
     */
    distinct?: GroupMessagesScalarFieldEnum | GroupMessagesScalarFieldEnum[]
  }

  /**
   * GroupMessages findFirstOrThrow
   */
  export type GroupMessagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessages to fetch.
     */
    where?: GroupMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessages to fetch.
     */
    orderBy?: GroupMessagesOrderByWithRelationInput | GroupMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMessages.
     */
    cursor?: GroupMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMessages.
     */
    distinct?: GroupMessagesScalarFieldEnum | GroupMessagesScalarFieldEnum[]
  }

  /**
   * GroupMessages findMany
   */
  export type GroupMessagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessages to fetch.
     */
    where?: GroupMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessages to fetch.
     */
    orderBy?: GroupMessagesOrderByWithRelationInput | GroupMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMessages.
     */
    cursor?: GroupMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessages.
     */
    skip?: number
    distinct?: GroupMessagesScalarFieldEnum | GroupMessagesScalarFieldEnum[]
  }

  /**
   * GroupMessages create
   */
  export type GroupMessagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMessages.
     */
    data: XOR<GroupMessagesCreateInput, GroupMessagesUncheckedCreateInput>
  }

  /**
   * GroupMessages createMany
   */
  export type GroupMessagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMessages.
     */
    data: GroupMessagesCreateManyInput | GroupMessagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMessages createManyAndReturn
   */
  export type GroupMessagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * The data used to create many GroupMessages.
     */
    data: GroupMessagesCreateManyInput | GroupMessagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMessages update
   */
  export type GroupMessagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMessages.
     */
    data: XOR<GroupMessagesUpdateInput, GroupMessagesUncheckedUpdateInput>
    /**
     * Choose, which GroupMessages to update.
     */
    where: GroupMessagesWhereUniqueInput
  }

  /**
   * GroupMessages updateMany
   */
  export type GroupMessagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMessages.
     */
    data: XOR<GroupMessagesUpdateManyMutationInput, GroupMessagesUncheckedUpdateManyInput>
    /**
     * Filter which GroupMessages to update
     */
    where?: GroupMessagesWhereInput
    /**
     * Limit how many GroupMessages to update.
     */
    limit?: number
  }

  /**
   * GroupMessages updateManyAndReturn
   */
  export type GroupMessagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * The data used to update GroupMessages.
     */
    data: XOR<GroupMessagesUpdateManyMutationInput, GroupMessagesUncheckedUpdateManyInput>
    /**
     * Filter which GroupMessages to update
     */
    where?: GroupMessagesWhereInput
    /**
     * Limit how many GroupMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMessages upsert
   */
  export type GroupMessagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMessages to update in case it exists.
     */
    where: GroupMessagesWhereUniqueInput
    /**
     * In case the GroupMessages found by the `where` argument doesn't exist, create a new GroupMessages with this data.
     */
    create: XOR<GroupMessagesCreateInput, GroupMessagesUncheckedCreateInput>
    /**
     * In case the GroupMessages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMessagesUpdateInput, GroupMessagesUncheckedUpdateInput>
  }

  /**
   * GroupMessages delete
   */
  export type GroupMessagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
    /**
     * Filter which GroupMessages to delete.
     */
    where: GroupMessagesWhereUniqueInput
  }

  /**
   * GroupMessages deleteMany
   */
  export type GroupMessagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMessages to delete
     */
    where?: GroupMessagesWhereInput
    /**
     * Limit how many GroupMessages to delete.
     */
    limit?: number
  }

  /**
   * GroupMessages.attachments
   */
  export type GroupMessages$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentInclude<ExtArgs> | null
    where?: GroupMessagesAttachmentWhereInput
    orderBy?: GroupMessagesAttachmentOrderByWithRelationInput | GroupMessagesAttachmentOrderByWithRelationInput[]
    cursor?: GroupMessagesAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMessagesAttachmentScalarFieldEnum | GroupMessagesAttachmentScalarFieldEnum[]
  }

  /**
   * GroupMessages without action
   */
  export type GroupMessagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
  }


  /**
   * Model GroupMessagesAttachment
   */

  export type AggregateGroupMessagesAttachment = {
    _count: GroupMessagesAttachmentCountAggregateOutputType | null
    _avg: GroupMessagesAttachmentAvgAggregateOutputType | null
    _sum: GroupMessagesAttachmentSumAggregateOutputType | null
    _min: GroupMessagesAttachmentMinAggregateOutputType | null
    _max: GroupMessagesAttachmentMaxAggregateOutputType | null
  }

  export type GroupMessagesAttachmentAvgAggregateOutputType = {
    id: number | null
    message_id: number | null
    size: number | null
  }

  export type GroupMessagesAttachmentSumAggregateOutputType = {
    id: number | null
    message_id: number | null
    size: number | null
  }

  export type GroupMessagesAttachmentMinAggregateOutputType = {
    id: number | null
    message_id: number | null
    size: number | null
    path: string | null
    originalName: string | null
    uniqueFileName: string | null
    created_at: Date | null
  }

  export type GroupMessagesAttachmentMaxAggregateOutputType = {
    id: number | null
    message_id: number | null
    size: number | null
    path: string | null
    originalName: string | null
    uniqueFileName: string | null
    created_at: Date | null
  }

  export type GroupMessagesAttachmentCountAggregateOutputType = {
    id: number
    message_id: number
    size: number
    path: number
    originalName: number
    uniqueFileName: number
    created_at: number
    _all: number
  }


  export type GroupMessagesAttachmentAvgAggregateInputType = {
    id?: true
    message_id?: true
    size?: true
  }

  export type GroupMessagesAttachmentSumAggregateInputType = {
    id?: true
    message_id?: true
    size?: true
  }

  export type GroupMessagesAttachmentMinAggregateInputType = {
    id?: true
    message_id?: true
    size?: true
    path?: true
    originalName?: true
    uniqueFileName?: true
    created_at?: true
  }

  export type GroupMessagesAttachmentMaxAggregateInputType = {
    id?: true
    message_id?: true
    size?: true
    path?: true
    originalName?: true
    uniqueFileName?: true
    created_at?: true
  }

  export type GroupMessagesAttachmentCountAggregateInputType = {
    id?: true
    message_id?: true
    size?: true
    path?: true
    originalName?: true
    uniqueFileName?: true
    created_at?: true
    _all?: true
  }

  export type GroupMessagesAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMessagesAttachment to aggregate.
     */
    where?: GroupMessagesAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessagesAttachments to fetch.
     */
    orderBy?: GroupMessagesAttachmentOrderByWithRelationInput | GroupMessagesAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMessagesAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessagesAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessagesAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMessagesAttachments
    **/
    _count?: true | GroupMessagesAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupMessagesAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupMessagesAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMessagesAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMessagesAttachmentMaxAggregateInputType
  }

  export type GetGroupMessagesAttachmentAggregateType<T extends GroupMessagesAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMessagesAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMessagesAttachment[P]>
      : GetScalarType<T[P], AggregateGroupMessagesAttachment[P]>
  }




  export type GroupMessagesAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMessagesAttachmentWhereInput
    orderBy?: GroupMessagesAttachmentOrderByWithAggregationInput | GroupMessagesAttachmentOrderByWithAggregationInput[]
    by: GroupMessagesAttachmentScalarFieldEnum[] | GroupMessagesAttachmentScalarFieldEnum
    having?: GroupMessagesAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMessagesAttachmentCountAggregateInputType | true
    _avg?: GroupMessagesAttachmentAvgAggregateInputType
    _sum?: GroupMessagesAttachmentSumAggregateInputType
    _min?: GroupMessagesAttachmentMinAggregateInputType
    _max?: GroupMessagesAttachmentMaxAggregateInputType
  }

  export type GroupMessagesAttachmentGroupByOutputType = {
    id: number
    message_id: number
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at: Date
    _count: GroupMessagesAttachmentCountAggregateOutputType | null
    _avg: GroupMessagesAttachmentAvgAggregateOutputType | null
    _sum: GroupMessagesAttachmentSumAggregateOutputType | null
    _min: GroupMessagesAttachmentMinAggregateOutputType | null
    _max: GroupMessagesAttachmentMaxAggregateOutputType | null
  }

  type GetGroupMessagesAttachmentGroupByPayload<T extends GroupMessagesAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMessagesAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMessagesAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMessagesAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMessagesAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type GroupMessagesAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_id?: boolean
    size?: boolean
    path?: boolean
    originalName?: boolean
    uniqueFileName?: boolean
    created_at?: boolean
    groupMessage?: boolean | GroupMessagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessagesAttachment"]>

  export type GroupMessagesAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_id?: boolean
    size?: boolean
    path?: boolean
    originalName?: boolean
    uniqueFileName?: boolean
    created_at?: boolean
    groupMessage?: boolean | GroupMessagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessagesAttachment"]>

  export type GroupMessagesAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_id?: boolean
    size?: boolean
    path?: boolean
    originalName?: boolean
    uniqueFileName?: boolean
    created_at?: boolean
    groupMessage?: boolean | GroupMessagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessagesAttachment"]>

  export type GroupMessagesAttachmentSelectScalar = {
    id?: boolean
    message_id?: boolean
    size?: boolean
    path?: boolean
    originalName?: boolean
    uniqueFileName?: boolean
    created_at?: boolean
  }

  export type GroupMessagesAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message_id" | "size" | "path" | "originalName" | "uniqueFileName" | "created_at", ExtArgs["result"]["groupMessagesAttachment"]>
  export type GroupMessagesAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupMessage?: boolean | GroupMessagesDefaultArgs<ExtArgs>
  }
  export type GroupMessagesAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupMessage?: boolean | GroupMessagesDefaultArgs<ExtArgs>
  }
  export type GroupMessagesAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupMessage?: boolean | GroupMessagesDefaultArgs<ExtArgs>
  }

  export type $GroupMessagesAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMessagesAttachment"
    objects: {
      groupMessage: Prisma.$GroupMessagesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      message_id: number
      size: number
      path: string
      originalName: string
      uniqueFileName: string
      created_at: Date
    }, ExtArgs["result"]["groupMessagesAttachment"]>
    composites: {}
  }

  type GroupMessagesAttachmentGetPayload<S extends boolean | null | undefined | GroupMessagesAttachmentDefaultArgs> = $Result.GetResult<Prisma.$GroupMessagesAttachmentPayload, S>

  type GroupMessagesAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMessagesAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMessagesAttachmentCountAggregateInputType | true
    }

  export interface GroupMessagesAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMessagesAttachment'], meta: { name: 'GroupMessagesAttachment' } }
    /**
     * Find zero or one GroupMessagesAttachment that matches the filter.
     * @param {GroupMessagesAttachmentFindUniqueArgs} args - Arguments to find a GroupMessagesAttachment
     * @example
     * // Get one GroupMessagesAttachment
     * const groupMessagesAttachment = await prisma.groupMessagesAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMessagesAttachmentFindUniqueArgs>(args: SelectSubset<T, GroupMessagesAttachmentFindUniqueArgs<ExtArgs>>): Prisma__GroupMessagesAttachmentClient<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMessagesAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMessagesAttachmentFindUniqueOrThrowArgs} args - Arguments to find a GroupMessagesAttachment
     * @example
     * // Get one GroupMessagesAttachment
     * const groupMessagesAttachment = await prisma.groupMessagesAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMessagesAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMessagesAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMessagesAttachmentClient<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMessagesAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesAttachmentFindFirstArgs} args - Arguments to find a GroupMessagesAttachment
     * @example
     * // Get one GroupMessagesAttachment
     * const groupMessagesAttachment = await prisma.groupMessagesAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMessagesAttachmentFindFirstArgs>(args?: SelectSubset<T, GroupMessagesAttachmentFindFirstArgs<ExtArgs>>): Prisma__GroupMessagesAttachmentClient<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMessagesAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesAttachmentFindFirstOrThrowArgs} args - Arguments to find a GroupMessagesAttachment
     * @example
     * // Get one GroupMessagesAttachment
     * const groupMessagesAttachment = await prisma.groupMessagesAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMessagesAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMessagesAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMessagesAttachmentClient<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMessagesAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMessagesAttachments
     * const groupMessagesAttachments = await prisma.groupMessagesAttachment.findMany()
     * 
     * // Get first 10 GroupMessagesAttachments
     * const groupMessagesAttachments = await prisma.groupMessagesAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMessagesAttachmentWithIdOnly = await prisma.groupMessagesAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMessagesAttachmentFindManyArgs>(args?: SelectSubset<T, GroupMessagesAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMessagesAttachment.
     * @param {GroupMessagesAttachmentCreateArgs} args - Arguments to create a GroupMessagesAttachment.
     * @example
     * // Create one GroupMessagesAttachment
     * const GroupMessagesAttachment = await prisma.groupMessagesAttachment.create({
     *   data: {
     *     // ... data to create a GroupMessagesAttachment
     *   }
     * })
     * 
     */
    create<T extends GroupMessagesAttachmentCreateArgs>(args: SelectSubset<T, GroupMessagesAttachmentCreateArgs<ExtArgs>>): Prisma__GroupMessagesAttachmentClient<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMessagesAttachments.
     * @param {GroupMessagesAttachmentCreateManyArgs} args - Arguments to create many GroupMessagesAttachments.
     * @example
     * // Create many GroupMessagesAttachments
     * const groupMessagesAttachment = await prisma.groupMessagesAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMessagesAttachmentCreateManyArgs>(args?: SelectSubset<T, GroupMessagesAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMessagesAttachments and returns the data saved in the database.
     * @param {GroupMessagesAttachmentCreateManyAndReturnArgs} args - Arguments to create many GroupMessagesAttachments.
     * @example
     * // Create many GroupMessagesAttachments
     * const groupMessagesAttachment = await prisma.groupMessagesAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMessagesAttachments and only return the `id`
     * const groupMessagesAttachmentWithIdOnly = await prisma.groupMessagesAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMessagesAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMessagesAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupMessagesAttachment.
     * @param {GroupMessagesAttachmentDeleteArgs} args - Arguments to delete one GroupMessagesAttachment.
     * @example
     * // Delete one GroupMessagesAttachment
     * const GroupMessagesAttachment = await prisma.groupMessagesAttachment.delete({
     *   where: {
     *     // ... filter to delete one GroupMessagesAttachment
     *   }
     * })
     * 
     */
    delete<T extends GroupMessagesAttachmentDeleteArgs>(args: SelectSubset<T, GroupMessagesAttachmentDeleteArgs<ExtArgs>>): Prisma__GroupMessagesAttachmentClient<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMessagesAttachment.
     * @param {GroupMessagesAttachmentUpdateArgs} args - Arguments to update one GroupMessagesAttachment.
     * @example
     * // Update one GroupMessagesAttachment
     * const groupMessagesAttachment = await prisma.groupMessagesAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMessagesAttachmentUpdateArgs>(args: SelectSubset<T, GroupMessagesAttachmentUpdateArgs<ExtArgs>>): Prisma__GroupMessagesAttachmentClient<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMessagesAttachments.
     * @param {GroupMessagesAttachmentDeleteManyArgs} args - Arguments to filter GroupMessagesAttachments to delete.
     * @example
     * // Delete a few GroupMessagesAttachments
     * const { count } = await prisma.groupMessagesAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMessagesAttachmentDeleteManyArgs>(args?: SelectSubset<T, GroupMessagesAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMessagesAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMessagesAttachments
     * const groupMessagesAttachment = await prisma.groupMessagesAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMessagesAttachmentUpdateManyArgs>(args: SelectSubset<T, GroupMessagesAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMessagesAttachments and returns the data updated in the database.
     * @param {GroupMessagesAttachmentUpdateManyAndReturnArgs} args - Arguments to update many GroupMessagesAttachments.
     * @example
     * // Update many GroupMessagesAttachments
     * const groupMessagesAttachment = await prisma.groupMessagesAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMessagesAttachments and only return the `id`
     * const groupMessagesAttachmentWithIdOnly = await prisma.groupMessagesAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupMessagesAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupMessagesAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupMessagesAttachment.
     * @param {GroupMessagesAttachmentUpsertArgs} args - Arguments to update or create a GroupMessagesAttachment.
     * @example
     * // Update or create a GroupMessagesAttachment
     * const groupMessagesAttachment = await prisma.groupMessagesAttachment.upsert({
     *   create: {
     *     // ... data to create a GroupMessagesAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMessagesAttachment we want to update
     *   }
     * })
     */
    upsert<T extends GroupMessagesAttachmentUpsertArgs>(args: SelectSubset<T, GroupMessagesAttachmentUpsertArgs<ExtArgs>>): Prisma__GroupMessagesAttachmentClient<$Result.GetResult<Prisma.$GroupMessagesAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMessagesAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesAttachmentCountArgs} args - Arguments to filter GroupMessagesAttachments to count.
     * @example
     * // Count the number of GroupMessagesAttachments
     * const count = await prisma.groupMessagesAttachment.count({
     *   where: {
     *     // ... the filter for the GroupMessagesAttachments we want to count
     *   }
     * })
    **/
    count<T extends GroupMessagesAttachmentCountArgs>(
      args?: Subset<T, GroupMessagesAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMessagesAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMessagesAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMessagesAttachmentAggregateArgs>(args: Subset<T, GroupMessagesAttachmentAggregateArgs>): Prisma.PrismaPromise<GetGroupMessagesAttachmentAggregateType<T>>

    /**
     * Group by GroupMessagesAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessagesAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMessagesAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMessagesAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: GroupMessagesAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMessagesAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMessagesAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMessagesAttachment model
   */
  readonly fields: GroupMessagesAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMessagesAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMessagesAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groupMessage<T extends GroupMessagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupMessagesDefaultArgs<ExtArgs>>): Prisma__GroupMessagesClient<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMessagesAttachment model
   */
  interface GroupMessagesAttachmentFieldRefs {
    readonly id: FieldRef<"GroupMessagesAttachment", 'Int'>
    readonly message_id: FieldRef<"GroupMessagesAttachment", 'Int'>
    readonly size: FieldRef<"GroupMessagesAttachment", 'Int'>
    readonly path: FieldRef<"GroupMessagesAttachment", 'String'>
    readonly originalName: FieldRef<"GroupMessagesAttachment", 'String'>
    readonly uniqueFileName: FieldRef<"GroupMessagesAttachment", 'String'>
    readonly created_at: FieldRef<"GroupMessagesAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMessagesAttachment findUnique
   */
  export type GroupMessagesAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessagesAttachment to fetch.
     */
    where: GroupMessagesAttachmentWhereUniqueInput
  }

  /**
   * GroupMessagesAttachment findUniqueOrThrow
   */
  export type GroupMessagesAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessagesAttachment to fetch.
     */
    where: GroupMessagesAttachmentWhereUniqueInput
  }

  /**
   * GroupMessagesAttachment findFirst
   */
  export type GroupMessagesAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessagesAttachment to fetch.
     */
    where?: GroupMessagesAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessagesAttachments to fetch.
     */
    orderBy?: GroupMessagesAttachmentOrderByWithRelationInput | GroupMessagesAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMessagesAttachments.
     */
    cursor?: GroupMessagesAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessagesAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessagesAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMessagesAttachments.
     */
    distinct?: GroupMessagesAttachmentScalarFieldEnum | GroupMessagesAttachmentScalarFieldEnum[]
  }

  /**
   * GroupMessagesAttachment findFirstOrThrow
   */
  export type GroupMessagesAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessagesAttachment to fetch.
     */
    where?: GroupMessagesAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessagesAttachments to fetch.
     */
    orderBy?: GroupMessagesAttachmentOrderByWithRelationInput | GroupMessagesAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMessagesAttachments.
     */
    cursor?: GroupMessagesAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessagesAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessagesAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMessagesAttachments.
     */
    distinct?: GroupMessagesAttachmentScalarFieldEnum | GroupMessagesAttachmentScalarFieldEnum[]
  }

  /**
   * GroupMessagesAttachment findMany
   */
  export type GroupMessagesAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessagesAttachments to fetch.
     */
    where?: GroupMessagesAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessagesAttachments to fetch.
     */
    orderBy?: GroupMessagesAttachmentOrderByWithRelationInput | GroupMessagesAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMessagesAttachments.
     */
    cursor?: GroupMessagesAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessagesAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessagesAttachments.
     */
    skip?: number
    distinct?: GroupMessagesAttachmentScalarFieldEnum | GroupMessagesAttachmentScalarFieldEnum[]
  }

  /**
   * GroupMessagesAttachment create
   */
  export type GroupMessagesAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMessagesAttachment.
     */
    data: XOR<GroupMessagesAttachmentCreateInput, GroupMessagesAttachmentUncheckedCreateInput>
  }

  /**
   * GroupMessagesAttachment createMany
   */
  export type GroupMessagesAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMessagesAttachments.
     */
    data: GroupMessagesAttachmentCreateManyInput | GroupMessagesAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMessagesAttachment createManyAndReturn
   */
  export type GroupMessagesAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many GroupMessagesAttachments.
     */
    data: GroupMessagesAttachmentCreateManyInput | GroupMessagesAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMessagesAttachment update
   */
  export type GroupMessagesAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMessagesAttachment.
     */
    data: XOR<GroupMessagesAttachmentUpdateInput, GroupMessagesAttachmentUncheckedUpdateInput>
    /**
     * Choose, which GroupMessagesAttachment to update.
     */
    where: GroupMessagesAttachmentWhereUniqueInput
  }

  /**
   * GroupMessagesAttachment updateMany
   */
  export type GroupMessagesAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMessagesAttachments.
     */
    data: XOR<GroupMessagesAttachmentUpdateManyMutationInput, GroupMessagesAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which GroupMessagesAttachments to update
     */
    where?: GroupMessagesAttachmentWhereInput
    /**
     * Limit how many GroupMessagesAttachments to update.
     */
    limit?: number
  }

  /**
   * GroupMessagesAttachment updateManyAndReturn
   */
  export type GroupMessagesAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update GroupMessagesAttachments.
     */
    data: XOR<GroupMessagesAttachmentUpdateManyMutationInput, GroupMessagesAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which GroupMessagesAttachments to update
     */
    where?: GroupMessagesAttachmentWhereInput
    /**
     * Limit how many GroupMessagesAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMessagesAttachment upsert
   */
  export type GroupMessagesAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMessagesAttachment to update in case it exists.
     */
    where: GroupMessagesAttachmentWhereUniqueInput
    /**
     * In case the GroupMessagesAttachment found by the `where` argument doesn't exist, create a new GroupMessagesAttachment with this data.
     */
    create: XOR<GroupMessagesAttachmentCreateInput, GroupMessagesAttachmentUncheckedCreateInput>
    /**
     * In case the GroupMessagesAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMessagesAttachmentUpdateInput, GroupMessagesAttachmentUncheckedUpdateInput>
  }

  /**
   * GroupMessagesAttachment delete
   */
  export type GroupMessagesAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentInclude<ExtArgs> | null
    /**
     * Filter which GroupMessagesAttachment to delete.
     */
    where: GroupMessagesAttachmentWhereUniqueInput
  }

  /**
   * GroupMessagesAttachment deleteMany
   */
  export type GroupMessagesAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMessagesAttachments to delete
     */
    where?: GroupMessagesAttachmentWhereInput
    /**
     * Limit how many GroupMessagesAttachments to delete.
     */
    limit?: number
  }

  /**
   * GroupMessagesAttachment without action
   */
  export type GroupMessagesAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessagesAttachment
     */
    select?: GroupMessagesAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessagesAttachment
     */
    omit?: GroupMessagesAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Friends
   */

  export type AggregateFriends = {
    _count: FriendsCountAggregateOutputType | null
    _avg: FriendsAvgAggregateOutputType | null
    _sum: FriendsSumAggregateOutputType | null
    _min: FriendsMinAggregateOutputType | null
    _max: FriendsMaxAggregateOutputType | null
  }

  export type FriendsAvgAggregateOutputType = {
    user_id: number | null
    friend_id: number | null
  }

  export type FriendsSumAggregateOutputType = {
    user_id: number | null
    friend_id: number | null
  }

  export type FriendsMinAggregateOutputType = {
    user_id: number | null
    friend_id: number | null
  }

  export type FriendsMaxAggregateOutputType = {
    user_id: number | null
    friend_id: number | null
  }

  export type FriendsCountAggregateOutputType = {
    user_id: number
    friend_id: number
    _all: number
  }


  export type FriendsAvgAggregateInputType = {
    user_id?: true
    friend_id?: true
  }

  export type FriendsSumAggregateInputType = {
    user_id?: true
    friend_id?: true
  }

  export type FriendsMinAggregateInputType = {
    user_id?: true
    friend_id?: true
  }

  export type FriendsMaxAggregateInputType = {
    user_id?: true
    friend_id?: true
  }

  export type FriendsCountAggregateInputType = {
    user_id?: true
    friend_id?: true
    _all?: true
  }

  export type FriendsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friends to aggregate.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friends
    **/
    _count?: true | FriendsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FriendsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FriendsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendsMaxAggregateInputType
  }

  export type GetFriendsAggregateType<T extends FriendsAggregateArgs> = {
        [P in keyof T & keyof AggregateFriends]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriends[P]>
      : GetScalarType<T[P], AggregateFriends[P]>
  }




  export type FriendsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendsWhereInput
    orderBy?: FriendsOrderByWithAggregationInput | FriendsOrderByWithAggregationInput[]
    by: FriendsScalarFieldEnum[] | FriendsScalarFieldEnum
    having?: FriendsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendsCountAggregateInputType | true
    _avg?: FriendsAvgAggregateInputType
    _sum?: FriendsSumAggregateInputType
    _min?: FriendsMinAggregateInputType
    _max?: FriendsMaxAggregateInputType
  }

  export type FriendsGroupByOutputType = {
    user_id: number
    friend_id: number
    _count: FriendsCountAggregateOutputType | null
    _avg: FriendsAvgAggregateOutputType | null
    _sum: FriendsSumAggregateOutputType | null
    _min: FriendsMinAggregateOutputType | null
    _max: FriendsMaxAggregateOutputType | null
  }

  type GetFriendsGroupByPayload<T extends FriendsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendsGroupByOutputType[P]>
            : GetScalarType<T[P], FriendsGroupByOutputType[P]>
        }
      >
    >


  export type FriendsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    friend_id?: boolean
    User?: boolean | UsersDefaultArgs<ExtArgs>
    Friend?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friends"]>

  export type FriendsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    friend_id?: boolean
    User?: boolean | UsersDefaultArgs<ExtArgs>
    Friend?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friends"]>

  export type FriendsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    friend_id?: boolean
    User?: boolean | UsersDefaultArgs<ExtArgs>
    Friend?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friends"]>

  export type FriendsSelectScalar = {
    user_id?: boolean
    friend_id?: boolean
  }

  export type FriendsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "friend_id", ExtArgs["result"]["friends"]>
  export type FriendsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UsersDefaultArgs<ExtArgs>
    Friend?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type FriendsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UsersDefaultArgs<ExtArgs>
    Friend?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type FriendsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UsersDefaultArgs<ExtArgs>
    Friend?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $FriendsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friends"
    objects: {
      User: Prisma.$UsersPayload<ExtArgs>
      Friend: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      friend_id: number
    }, ExtArgs["result"]["friends"]>
    composites: {}
  }

  type FriendsGetPayload<S extends boolean | null | undefined | FriendsDefaultArgs> = $Result.GetResult<Prisma.$FriendsPayload, S>

  type FriendsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FriendsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FriendsCountAggregateInputType | true
    }

  export interface FriendsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friends'], meta: { name: 'Friends' } }
    /**
     * Find zero or one Friends that matches the filter.
     * @param {FriendsFindUniqueArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendsFindUniqueArgs>(args: SelectSubset<T, FriendsFindUniqueArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Friends that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FriendsFindUniqueOrThrowArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendsFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindFirstArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendsFindFirstArgs>(args?: SelectSubset<T, FriendsFindFirstArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friends that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindFirstOrThrowArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendsFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Friends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friends
     * const friends = await prisma.friends.findMany()
     * 
     * // Get first 10 Friends
     * const friends = await prisma.friends.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const friendsWithUser_idOnly = await prisma.friends.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends FriendsFindManyArgs>(args?: SelectSubset<T, FriendsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Friends.
     * @param {FriendsCreateArgs} args - Arguments to create a Friends.
     * @example
     * // Create one Friends
     * const Friends = await prisma.friends.create({
     *   data: {
     *     // ... data to create a Friends
     *   }
     * })
     * 
     */
    create<T extends FriendsCreateArgs>(args: SelectSubset<T, FriendsCreateArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Friends.
     * @param {FriendsCreateManyArgs} args - Arguments to create many Friends.
     * @example
     * // Create many Friends
     * const friends = await prisma.friends.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendsCreateManyArgs>(args?: SelectSubset<T, FriendsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friends and returns the data saved in the database.
     * @param {FriendsCreateManyAndReturnArgs} args - Arguments to create many Friends.
     * @example
     * // Create many Friends
     * const friends = await prisma.friends.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friends and only return the `user_id`
     * const friendsWithUser_idOnly = await prisma.friends.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendsCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Friends.
     * @param {FriendsDeleteArgs} args - Arguments to delete one Friends.
     * @example
     * // Delete one Friends
     * const Friends = await prisma.friends.delete({
     *   where: {
     *     // ... filter to delete one Friends
     *   }
     * })
     * 
     */
    delete<T extends FriendsDeleteArgs>(args: SelectSubset<T, FriendsDeleteArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Friends.
     * @param {FriendsUpdateArgs} args - Arguments to update one Friends.
     * @example
     * // Update one Friends
     * const friends = await prisma.friends.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendsUpdateArgs>(args: SelectSubset<T, FriendsUpdateArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Friends.
     * @param {FriendsDeleteManyArgs} args - Arguments to filter Friends to delete.
     * @example
     * // Delete a few Friends
     * const { count } = await prisma.friends.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendsDeleteManyArgs>(args?: SelectSubset<T, FriendsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friends
     * const friends = await prisma.friends.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendsUpdateManyArgs>(args: SelectSubset<T, FriendsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friends and returns the data updated in the database.
     * @param {FriendsUpdateManyAndReturnArgs} args - Arguments to update many Friends.
     * @example
     * // Update many Friends
     * const friends = await prisma.friends.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Friends and only return the `user_id`
     * const friendsWithUser_idOnly = await prisma.friends.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FriendsUpdateManyAndReturnArgs>(args: SelectSubset<T, FriendsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Friends.
     * @param {FriendsUpsertArgs} args - Arguments to update or create a Friends.
     * @example
     * // Update or create a Friends
     * const friends = await prisma.friends.upsert({
     *   create: {
     *     // ... data to create a Friends
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friends we want to update
     *   }
     * })
     */
    upsert<T extends FriendsUpsertArgs>(args: SelectSubset<T, FriendsUpsertArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsCountArgs} args - Arguments to filter Friends to count.
     * @example
     * // Count the number of Friends
     * const count = await prisma.friends.count({
     *   where: {
     *     // ... the filter for the Friends we want to count
     *   }
     * })
    **/
    count<T extends FriendsCountArgs>(
      args?: Subset<T, FriendsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendsAggregateArgs>(args: Subset<T, FriendsAggregateArgs>): Prisma.PrismaPromise<GetFriendsAggregateType<T>>

    /**
     * Group by Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendsGroupByArgs['orderBy'] }
        : { orderBy?: FriendsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friends model
   */
  readonly fields: FriendsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friends.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Friend<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friends model
   */
  interface FriendsFieldRefs {
    readonly user_id: FieldRef<"Friends", 'Int'>
    readonly friend_id: FieldRef<"Friends", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Friends findUnique
   */
  export type FriendsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends findUniqueOrThrow
   */
  export type FriendsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends findFirst
   */
  export type FriendsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friends.
     */
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends findFirstOrThrow
   */
  export type FriendsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friends.
     */
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends findMany
   */
  export type FriendsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends create
   */
  export type FriendsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The data needed to create a Friends.
     */
    data: XOR<FriendsCreateInput, FriendsUncheckedCreateInput>
  }

  /**
   * Friends createMany
   */
  export type FriendsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friends.
     */
    data: FriendsCreateManyInput | FriendsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friends createManyAndReturn
   */
  export type FriendsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * The data used to create many Friends.
     */
    data: FriendsCreateManyInput | FriendsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friends update
   */
  export type FriendsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The data needed to update a Friends.
     */
    data: XOR<FriendsUpdateInput, FriendsUncheckedUpdateInput>
    /**
     * Choose, which Friends to update.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends updateMany
   */
  export type FriendsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friends.
     */
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyInput>
    /**
     * Filter which Friends to update
     */
    where?: FriendsWhereInput
    /**
     * Limit how many Friends to update.
     */
    limit?: number
  }

  /**
   * Friends updateManyAndReturn
   */
  export type FriendsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * The data used to update Friends.
     */
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyInput>
    /**
     * Filter which Friends to update
     */
    where?: FriendsWhereInput
    /**
     * Limit how many Friends to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friends upsert
   */
  export type FriendsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The filter to search for the Friends to update in case it exists.
     */
    where: FriendsWhereUniqueInput
    /**
     * In case the Friends found by the `where` argument doesn't exist, create a new Friends with this data.
     */
    create: XOR<FriendsCreateInput, FriendsUncheckedCreateInput>
    /**
     * In case the Friends was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendsUpdateInput, FriendsUncheckedUpdateInput>
  }

  /**
   * Friends delete
   */
  export type FriendsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter which Friends to delete.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends deleteMany
   */
  export type FriendsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friends to delete
     */
    where?: FriendsWhereInput
    /**
     * Limit how many Friends to delete.
     */
    limit?: number
  }

  /**
   * Friends without action
   */
  export type FriendsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
  }


  /**
   * Model PendingFriendRequests
   */

  export type AggregatePendingFriendRequests = {
    _count: PendingFriendRequestsCountAggregateOutputType | null
    _avg: PendingFriendRequestsAvgAggregateOutputType | null
    _sum: PendingFriendRequestsSumAggregateOutputType | null
    _min: PendingFriendRequestsMinAggregateOutputType | null
    _max: PendingFriendRequestsMaxAggregateOutputType | null
  }

  export type PendingFriendRequestsAvgAggregateOutputType = {
    sender_id: number | null
    receiver_id: number | null
  }

  export type PendingFriendRequestsSumAggregateOutputType = {
    sender_id: number | null
    receiver_id: number | null
  }

  export type PendingFriendRequestsMinAggregateOutputType = {
    sender_id: number | null
    receiver_id: number | null
  }

  export type PendingFriendRequestsMaxAggregateOutputType = {
    sender_id: number | null
    receiver_id: number | null
  }

  export type PendingFriendRequestsCountAggregateOutputType = {
    sender_id: number
    receiver_id: number
    _all: number
  }


  export type PendingFriendRequestsAvgAggregateInputType = {
    sender_id?: true
    receiver_id?: true
  }

  export type PendingFriendRequestsSumAggregateInputType = {
    sender_id?: true
    receiver_id?: true
  }

  export type PendingFriendRequestsMinAggregateInputType = {
    sender_id?: true
    receiver_id?: true
  }

  export type PendingFriendRequestsMaxAggregateInputType = {
    sender_id?: true
    receiver_id?: true
  }

  export type PendingFriendRequestsCountAggregateInputType = {
    sender_id?: true
    receiver_id?: true
    _all?: true
  }

  export type PendingFriendRequestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingFriendRequests to aggregate.
     */
    where?: PendingFriendRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingFriendRequests to fetch.
     */
    orderBy?: PendingFriendRequestsOrderByWithRelationInput | PendingFriendRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingFriendRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingFriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingFriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingFriendRequests
    **/
    _count?: true | PendingFriendRequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingFriendRequestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingFriendRequestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingFriendRequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingFriendRequestsMaxAggregateInputType
  }

  export type GetPendingFriendRequestsAggregateType<T extends PendingFriendRequestsAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingFriendRequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingFriendRequests[P]>
      : GetScalarType<T[P], AggregatePendingFriendRequests[P]>
  }




  export type PendingFriendRequestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingFriendRequestsWhereInput
    orderBy?: PendingFriendRequestsOrderByWithAggregationInput | PendingFriendRequestsOrderByWithAggregationInput[]
    by: PendingFriendRequestsScalarFieldEnum[] | PendingFriendRequestsScalarFieldEnum
    having?: PendingFriendRequestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingFriendRequestsCountAggregateInputType | true
    _avg?: PendingFriendRequestsAvgAggregateInputType
    _sum?: PendingFriendRequestsSumAggregateInputType
    _min?: PendingFriendRequestsMinAggregateInputType
    _max?: PendingFriendRequestsMaxAggregateInputType
  }

  export type PendingFriendRequestsGroupByOutputType = {
    sender_id: number
    receiver_id: number
    _count: PendingFriendRequestsCountAggregateOutputType | null
    _avg: PendingFriendRequestsAvgAggregateOutputType | null
    _sum: PendingFriendRequestsSumAggregateOutputType | null
    _min: PendingFriendRequestsMinAggregateOutputType | null
    _max: PendingFriendRequestsMaxAggregateOutputType | null
  }

  type GetPendingFriendRequestsGroupByPayload<T extends PendingFriendRequestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingFriendRequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingFriendRequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingFriendRequestsGroupByOutputType[P]>
            : GetScalarType<T[P], PendingFriendRequestsGroupByOutputType[P]>
        }
      >
    >


  export type PendingFriendRequestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sender_id?: boolean
    receiver_id?: boolean
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingFriendRequests"]>

  export type PendingFriendRequestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sender_id?: boolean
    receiver_id?: boolean
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingFriendRequests"]>

  export type PendingFriendRequestsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sender_id?: boolean
    receiver_id?: boolean
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingFriendRequests"]>

  export type PendingFriendRequestsSelectScalar = {
    sender_id?: boolean
    receiver_id?: boolean
  }

  export type PendingFriendRequestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sender_id" | "receiver_id", ExtArgs["result"]["pendingFriendRequests"]>
  export type PendingFriendRequestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type PendingFriendRequestsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type PendingFriendRequestsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $PendingFriendRequestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingFriendRequests"
    objects: {
      Sender: Prisma.$UsersPayload<ExtArgs>
      Receiver: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sender_id: number
      receiver_id: number
    }, ExtArgs["result"]["pendingFriendRequests"]>
    composites: {}
  }

  type PendingFriendRequestsGetPayload<S extends boolean | null | undefined | PendingFriendRequestsDefaultArgs> = $Result.GetResult<Prisma.$PendingFriendRequestsPayload, S>

  type PendingFriendRequestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingFriendRequestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingFriendRequestsCountAggregateInputType | true
    }

  export interface PendingFriendRequestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingFriendRequests'], meta: { name: 'PendingFriendRequests' } }
    /**
     * Find zero or one PendingFriendRequests that matches the filter.
     * @param {PendingFriendRequestsFindUniqueArgs} args - Arguments to find a PendingFriendRequests
     * @example
     * // Get one PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingFriendRequestsFindUniqueArgs>(args: SelectSubset<T, PendingFriendRequestsFindUniqueArgs<ExtArgs>>): Prisma__PendingFriendRequestsClient<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PendingFriendRequests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingFriendRequestsFindUniqueOrThrowArgs} args - Arguments to find a PendingFriendRequests
     * @example
     * // Get one PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingFriendRequestsFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingFriendRequestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingFriendRequestsClient<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingFriendRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingFriendRequestsFindFirstArgs} args - Arguments to find a PendingFriendRequests
     * @example
     * // Get one PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingFriendRequestsFindFirstArgs>(args?: SelectSubset<T, PendingFriendRequestsFindFirstArgs<ExtArgs>>): Prisma__PendingFriendRequestsClient<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingFriendRequests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingFriendRequestsFindFirstOrThrowArgs} args - Arguments to find a PendingFriendRequests
     * @example
     * // Get one PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingFriendRequestsFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingFriendRequestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingFriendRequestsClient<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PendingFriendRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingFriendRequestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.findMany()
     * 
     * // Get first 10 PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.findMany({ take: 10 })
     * 
     * // Only select the `sender_id`
     * const pendingFriendRequestsWithSender_idOnly = await prisma.pendingFriendRequests.findMany({ select: { sender_id: true } })
     * 
     */
    findMany<T extends PendingFriendRequestsFindManyArgs>(args?: SelectSubset<T, PendingFriendRequestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PendingFriendRequests.
     * @param {PendingFriendRequestsCreateArgs} args - Arguments to create a PendingFriendRequests.
     * @example
     * // Create one PendingFriendRequests
     * const PendingFriendRequests = await prisma.pendingFriendRequests.create({
     *   data: {
     *     // ... data to create a PendingFriendRequests
     *   }
     * })
     * 
     */
    create<T extends PendingFriendRequestsCreateArgs>(args: SelectSubset<T, PendingFriendRequestsCreateArgs<ExtArgs>>): Prisma__PendingFriendRequestsClient<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PendingFriendRequests.
     * @param {PendingFriendRequestsCreateManyArgs} args - Arguments to create many PendingFriendRequests.
     * @example
     * // Create many PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingFriendRequestsCreateManyArgs>(args?: SelectSubset<T, PendingFriendRequestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingFriendRequests and returns the data saved in the database.
     * @param {PendingFriendRequestsCreateManyAndReturnArgs} args - Arguments to create many PendingFriendRequests.
     * @example
     * // Create many PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingFriendRequests and only return the `sender_id`
     * const pendingFriendRequestsWithSender_idOnly = await prisma.pendingFriendRequests.createManyAndReturn({
     *   select: { sender_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingFriendRequestsCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingFriendRequestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PendingFriendRequests.
     * @param {PendingFriendRequestsDeleteArgs} args - Arguments to delete one PendingFriendRequests.
     * @example
     * // Delete one PendingFriendRequests
     * const PendingFriendRequests = await prisma.pendingFriendRequests.delete({
     *   where: {
     *     // ... filter to delete one PendingFriendRequests
     *   }
     * })
     * 
     */
    delete<T extends PendingFriendRequestsDeleteArgs>(args: SelectSubset<T, PendingFriendRequestsDeleteArgs<ExtArgs>>): Prisma__PendingFriendRequestsClient<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PendingFriendRequests.
     * @param {PendingFriendRequestsUpdateArgs} args - Arguments to update one PendingFriendRequests.
     * @example
     * // Update one PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingFriendRequestsUpdateArgs>(args: SelectSubset<T, PendingFriendRequestsUpdateArgs<ExtArgs>>): Prisma__PendingFriendRequestsClient<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PendingFriendRequests.
     * @param {PendingFriendRequestsDeleteManyArgs} args - Arguments to filter PendingFriendRequests to delete.
     * @example
     * // Delete a few PendingFriendRequests
     * const { count } = await prisma.pendingFriendRequests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingFriendRequestsDeleteManyArgs>(args?: SelectSubset<T, PendingFriendRequestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingFriendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingFriendRequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingFriendRequestsUpdateManyArgs>(args: SelectSubset<T, PendingFriendRequestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingFriendRequests and returns the data updated in the database.
     * @param {PendingFriendRequestsUpdateManyAndReturnArgs} args - Arguments to update many PendingFriendRequests.
     * @example
     * // Update many PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingFriendRequests and only return the `sender_id`
     * const pendingFriendRequestsWithSender_idOnly = await prisma.pendingFriendRequests.updateManyAndReturn({
     *   select: { sender_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingFriendRequestsUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingFriendRequestsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PendingFriendRequests.
     * @param {PendingFriendRequestsUpsertArgs} args - Arguments to update or create a PendingFriendRequests.
     * @example
     * // Update or create a PendingFriendRequests
     * const pendingFriendRequests = await prisma.pendingFriendRequests.upsert({
     *   create: {
     *     // ... data to create a PendingFriendRequests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingFriendRequests we want to update
     *   }
     * })
     */
    upsert<T extends PendingFriendRequestsUpsertArgs>(args: SelectSubset<T, PendingFriendRequestsUpsertArgs<ExtArgs>>): Prisma__PendingFriendRequestsClient<$Result.GetResult<Prisma.$PendingFriendRequestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PendingFriendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingFriendRequestsCountArgs} args - Arguments to filter PendingFriendRequests to count.
     * @example
     * // Count the number of PendingFriendRequests
     * const count = await prisma.pendingFriendRequests.count({
     *   where: {
     *     // ... the filter for the PendingFriendRequests we want to count
     *   }
     * })
    **/
    count<T extends PendingFriendRequestsCountArgs>(
      args?: Subset<T, PendingFriendRequestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingFriendRequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingFriendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingFriendRequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingFriendRequestsAggregateArgs>(args: Subset<T, PendingFriendRequestsAggregateArgs>): Prisma.PrismaPromise<GetPendingFriendRequestsAggregateType<T>>

    /**
     * Group by PendingFriendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingFriendRequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingFriendRequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingFriendRequestsGroupByArgs['orderBy'] }
        : { orderBy?: PendingFriendRequestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingFriendRequestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingFriendRequestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingFriendRequests model
   */
  readonly fields: PendingFriendRequestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingFriendRequests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingFriendRequestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Sender<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Receiver<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingFriendRequests model
   */
  interface PendingFriendRequestsFieldRefs {
    readonly sender_id: FieldRef<"PendingFriendRequests", 'Int'>
    readonly receiver_id: FieldRef<"PendingFriendRequests", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PendingFriendRequests findUnique
   */
  export type PendingFriendRequestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
    /**
     * Filter, which PendingFriendRequests to fetch.
     */
    where: PendingFriendRequestsWhereUniqueInput
  }

  /**
   * PendingFriendRequests findUniqueOrThrow
   */
  export type PendingFriendRequestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
    /**
     * Filter, which PendingFriendRequests to fetch.
     */
    where: PendingFriendRequestsWhereUniqueInput
  }

  /**
   * PendingFriendRequests findFirst
   */
  export type PendingFriendRequestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
    /**
     * Filter, which PendingFriendRequests to fetch.
     */
    where?: PendingFriendRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingFriendRequests to fetch.
     */
    orderBy?: PendingFriendRequestsOrderByWithRelationInput | PendingFriendRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingFriendRequests.
     */
    cursor?: PendingFriendRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingFriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingFriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingFriendRequests.
     */
    distinct?: PendingFriendRequestsScalarFieldEnum | PendingFriendRequestsScalarFieldEnum[]
  }

  /**
   * PendingFriendRequests findFirstOrThrow
   */
  export type PendingFriendRequestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
    /**
     * Filter, which PendingFriendRequests to fetch.
     */
    where?: PendingFriendRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingFriendRequests to fetch.
     */
    orderBy?: PendingFriendRequestsOrderByWithRelationInput | PendingFriendRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingFriendRequests.
     */
    cursor?: PendingFriendRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingFriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingFriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingFriendRequests.
     */
    distinct?: PendingFriendRequestsScalarFieldEnum | PendingFriendRequestsScalarFieldEnum[]
  }

  /**
   * PendingFriendRequests findMany
   */
  export type PendingFriendRequestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
    /**
     * Filter, which PendingFriendRequests to fetch.
     */
    where?: PendingFriendRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingFriendRequests to fetch.
     */
    orderBy?: PendingFriendRequestsOrderByWithRelationInput | PendingFriendRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingFriendRequests.
     */
    cursor?: PendingFriendRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingFriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingFriendRequests.
     */
    skip?: number
    distinct?: PendingFriendRequestsScalarFieldEnum | PendingFriendRequestsScalarFieldEnum[]
  }

  /**
   * PendingFriendRequests create
   */
  export type PendingFriendRequestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingFriendRequests.
     */
    data: XOR<PendingFriendRequestsCreateInput, PendingFriendRequestsUncheckedCreateInput>
  }

  /**
   * PendingFriendRequests createMany
   */
  export type PendingFriendRequestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingFriendRequests.
     */
    data: PendingFriendRequestsCreateManyInput | PendingFriendRequestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingFriendRequests createManyAndReturn
   */
  export type PendingFriendRequestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * The data used to create many PendingFriendRequests.
     */
    data: PendingFriendRequestsCreateManyInput | PendingFriendRequestsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingFriendRequests update
   */
  export type PendingFriendRequestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingFriendRequests.
     */
    data: XOR<PendingFriendRequestsUpdateInput, PendingFriendRequestsUncheckedUpdateInput>
    /**
     * Choose, which PendingFriendRequests to update.
     */
    where: PendingFriendRequestsWhereUniqueInput
  }

  /**
   * PendingFriendRequests updateMany
   */
  export type PendingFriendRequestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingFriendRequests.
     */
    data: XOR<PendingFriendRequestsUpdateManyMutationInput, PendingFriendRequestsUncheckedUpdateManyInput>
    /**
     * Filter which PendingFriendRequests to update
     */
    where?: PendingFriendRequestsWhereInput
    /**
     * Limit how many PendingFriendRequests to update.
     */
    limit?: number
  }

  /**
   * PendingFriendRequests updateManyAndReturn
   */
  export type PendingFriendRequestsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * The data used to update PendingFriendRequests.
     */
    data: XOR<PendingFriendRequestsUpdateManyMutationInput, PendingFriendRequestsUncheckedUpdateManyInput>
    /**
     * Filter which PendingFriendRequests to update
     */
    where?: PendingFriendRequestsWhereInput
    /**
     * Limit how many PendingFriendRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingFriendRequests upsert
   */
  export type PendingFriendRequestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingFriendRequests to update in case it exists.
     */
    where: PendingFriendRequestsWhereUniqueInput
    /**
     * In case the PendingFriendRequests found by the `where` argument doesn't exist, create a new PendingFriendRequests with this data.
     */
    create: XOR<PendingFriendRequestsCreateInput, PendingFriendRequestsUncheckedCreateInput>
    /**
     * In case the PendingFriendRequests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingFriendRequestsUpdateInput, PendingFriendRequestsUncheckedUpdateInput>
  }

  /**
   * PendingFriendRequests delete
   */
  export type PendingFriendRequestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
    /**
     * Filter which PendingFriendRequests to delete.
     */
    where: PendingFriendRequestsWhereUniqueInput
  }

  /**
   * PendingFriendRequests deleteMany
   */
  export type PendingFriendRequestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingFriendRequests to delete
     */
    where?: PendingFriendRequestsWhereInput
    /**
     * Limit how many PendingFriendRequests to delete.
     */
    limit?: number
  }

  /**
   * PendingFriendRequests without action
   */
  export type PendingFriendRequestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingFriendRequests
     */
    select?: PendingFriendRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingFriendRequests
     */
    omit?: PendingFriendRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingFriendRequestsInclude<ExtArgs> | null
  }


  /**
   * Model GroupChats
   */

  export type AggregateGroupChats = {
    _count: GroupChatsCountAggregateOutputType | null
    _avg: GroupChatsAvgAggregateOutputType | null
    _sum: GroupChatsSumAggregateOutputType | null
    _min: GroupChatsMinAggregateOutputType | null
    _max: GroupChatsMaxAggregateOutputType | null
  }

  export type GroupChatsAvgAggregateOutputType = {
    id: number | null
    admin_id: number | null
  }

  export type GroupChatsSumAggregateOutputType = {
    id: number | null
    admin_id: number | null
  }

  export type GroupChatsMinAggregateOutputType = {
    id: number | null
    admin_id: number | null
    name: string | null
    description: string | null
    avatar: string | null
  }

  export type GroupChatsMaxAggregateOutputType = {
    id: number | null
    admin_id: number | null
    name: string | null
    description: string | null
    avatar: string | null
  }

  export type GroupChatsCountAggregateOutputType = {
    id: number
    admin_id: number
    name: number
    description: number
    avatar: number
    _all: number
  }


  export type GroupChatsAvgAggregateInputType = {
    id?: true
    admin_id?: true
  }

  export type GroupChatsSumAggregateInputType = {
    id?: true
    admin_id?: true
  }

  export type GroupChatsMinAggregateInputType = {
    id?: true
    admin_id?: true
    name?: true
    description?: true
    avatar?: true
  }

  export type GroupChatsMaxAggregateInputType = {
    id?: true
    admin_id?: true
    name?: true
    description?: true
    avatar?: true
  }

  export type GroupChatsCountAggregateInputType = {
    id?: true
    admin_id?: true
    name?: true
    description?: true
    avatar?: true
    _all?: true
  }

  export type GroupChatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupChats to aggregate.
     */
    where?: GroupChatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupChats to fetch.
     */
    orderBy?: GroupChatsOrderByWithRelationInput | GroupChatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupChatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupChats
    **/
    _count?: true | GroupChatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupChatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupChatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupChatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupChatsMaxAggregateInputType
  }

  export type GetGroupChatsAggregateType<T extends GroupChatsAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupChats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupChats[P]>
      : GetScalarType<T[P], AggregateGroupChats[P]>
  }




  export type GroupChatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupChatsWhereInput
    orderBy?: GroupChatsOrderByWithAggregationInput | GroupChatsOrderByWithAggregationInput[]
    by: GroupChatsScalarFieldEnum[] | GroupChatsScalarFieldEnum
    having?: GroupChatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupChatsCountAggregateInputType | true
    _avg?: GroupChatsAvgAggregateInputType
    _sum?: GroupChatsSumAggregateInputType
    _min?: GroupChatsMinAggregateInputType
    _max?: GroupChatsMaxAggregateInputType
  }

  export type GroupChatsGroupByOutputType = {
    id: number
    admin_id: number
    name: string | null
    description: string | null
    avatar: string | null
    _count: GroupChatsCountAggregateOutputType | null
    _avg: GroupChatsAvgAggregateOutputType | null
    _sum: GroupChatsSumAggregateOutputType | null
    _min: GroupChatsMinAggregateOutputType | null
    _max: GroupChatsMaxAggregateOutputType | null
  }

  type GetGroupChatsGroupByPayload<T extends GroupChatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupChatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupChatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupChatsGroupByOutputType[P]>
            : GetScalarType<T[P], GroupChatsGroupByOutputType[P]>
        }
      >
    >


  export type GroupChatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    name?: boolean
    description?: boolean
    avatar?: boolean
    Admin?: boolean | UsersDefaultArgs<ExtArgs>
    GroupMembers?: boolean | GroupChats$GroupMembersArgs<ExtArgs>
    GroupMessages?: boolean | GroupChats$GroupMessagesArgs<ExtArgs>
    _count?: boolean | GroupChatsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupChats"]>

  export type GroupChatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    name?: boolean
    description?: boolean
    avatar?: boolean
    Admin?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupChats"]>

  export type GroupChatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    name?: boolean
    description?: boolean
    avatar?: boolean
    Admin?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupChats"]>

  export type GroupChatsSelectScalar = {
    id?: boolean
    admin_id?: boolean
    name?: boolean
    description?: boolean
    avatar?: boolean
  }

  export type GroupChatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admin_id" | "name" | "description" | "avatar", ExtArgs["result"]["groupChats"]>
  export type GroupChatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Admin?: boolean | UsersDefaultArgs<ExtArgs>
    GroupMembers?: boolean | GroupChats$GroupMembersArgs<ExtArgs>
    GroupMessages?: boolean | GroupChats$GroupMessagesArgs<ExtArgs>
    _count?: boolean | GroupChatsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupChatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Admin?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type GroupChatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Admin?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $GroupChatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupChats"
    objects: {
      Admin: Prisma.$UsersPayload<ExtArgs>
      GroupMembers: Prisma.$GroupMembersPayload<ExtArgs>[]
      GroupMessages: Prisma.$GroupMessagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      admin_id: number
      name: string | null
      description: string | null
      avatar: string | null
    }, ExtArgs["result"]["groupChats"]>
    composites: {}
  }

  type GroupChatsGetPayload<S extends boolean | null | undefined | GroupChatsDefaultArgs> = $Result.GetResult<Prisma.$GroupChatsPayload, S>

  type GroupChatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupChatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupChatsCountAggregateInputType | true
    }

  export interface GroupChatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupChats'], meta: { name: 'GroupChats' } }
    /**
     * Find zero or one GroupChats that matches the filter.
     * @param {GroupChatsFindUniqueArgs} args - Arguments to find a GroupChats
     * @example
     * // Get one GroupChats
     * const groupChats = await prisma.groupChats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupChatsFindUniqueArgs>(args: SelectSubset<T, GroupChatsFindUniqueArgs<ExtArgs>>): Prisma__GroupChatsClient<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupChats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupChatsFindUniqueOrThrowArgs} args - Arguments to find a GroupChats
     * @example
     * // Get one GroupChats
     * const groupChats = await prisma.groupChats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupChatsFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupChatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupChatsClient<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupChats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupChatsFindFirstArgs} args - Arguments to find a GroupChats
     * @example
     * // Get one GroupChats
     * const groupChats = await prisma.groupChats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupChatsFindFirstArgs>(args?: SelectSubset<T, GroupChatsFindFirstArgs<ExtArgs>>): Prisma__GroupChatsClient<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupChats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupChatsFindFirstOrThrowArgs} args - Arguments to find a GroupChats
     * @example
     * // Get one GroupChats
     * const groupChats = await prisma.groupChats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupChatsFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupChatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupChatsClient<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupChats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupChatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupChats
     * const groupChats = await prisma.groupChats.findMany()
     * 
     * // Get first 10 GroupChats
     * const groupChats = await prisma.groupChats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupChatsWithIdOnly = await prisma.groupChats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupChatsFindManyArgs>(args?: SelectSubset<T, GroupChatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupChats.
     * @param {GroupChatsCreateArgs} args - Arguments to create a GroupChats.
     * @example
     * // Create one GroupChats
     * const GroupChats = await prisma.groupChats.create({
     *   data: {
     *     // ... data to create a GroupChats
     *   }
     * })
     * 
     */
    create<T extends GroupChatsCreateArgs>(args: SelectSubset<T, GroupChatsCreateArgs<ExtArgs>>): Prisma__GroupChatsClient<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupChats.
     * @param {GroupChatsCreateManyArgs} args - Arguments to create many GroupChats.
     * @example
     * // Create many GroupChats
     * const groupChats = await prisma.groupChats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupChatsCreateManyArgs>(args?: SelectSubset<T, GroupChatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupChats and returns the data saved in the database.
     * @param {GroupChatsCreateManyAndReturnArgs} args - Arguments to create many GroupChats.
     * @example
     * // Create many GroupChats
     * const groupChats = await prisma.groupChats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupChats and only return the `id`
     * const groupChatsWithIdOnly = await prisma.groupChats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupChatsCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupChatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupChats.
     * @param {GroupChatsDeleteArgs} args - Arguments to delete one GroupChats.
     * @example
     * // Delete one GroupChats
     * const GroupChats = await prisma.groupChats.delete({
     *   where: {
     *     // ... filter to delete one GroupChats
     *   }
     * })
     * 
     */
    delete<T extends GroupChatsDeleteArgs>(args: SelectSubset<T, GroupChatsDeleteArgs<ExtArgs>>): Prisma__GroupChatsClient<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupChats.
     * @param {GroupChatsUpdateArgs} args - Arguments to update one GroupChats.
     * @example
     * // Update one GroupChats
     * const groupChats = await prisma.groupChats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupChatsUpdateArgs>(args: SelectSubset<T, GroupChatsUpdateArgs<ExtArgs>>): Prisma__GroupChatsClient<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupChats.
     * @param {GroupChatsDeleteManyArgs} args - Arguments to filter GroupChats to delete.
     * @example
     * // Delete a few GroupChats
     * const { count } = await prisma.groupChats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupChatsDeleteManyArgs>(args?: SelectSubset<T, GroupChatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupChatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupChats
     * const groupChats = await prisma.groupChats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupChatsUpdateManyArgs>(args: SelectSubset<T, GroupChatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupChats and returns the data updated in the database.
     * @param {GroupChatsUpdateManyAndReturnArgs} args - Arguments to update many GroupChats.
     * @example
     * // Update many GroupChats
     * const groupChats = await prisma.groupChats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupChats and only return the `id`
     * const groupChatsWithIdOnly = await prisma.groupChats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupChatsUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupChatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupChats.
     * @param {GroupChatsUpsertArgs} args - Arguments to update or create a GroupChats.
     * @example
     * // Update or create a GroupChats
     * const groupChats = await prisma.groupChats.upsert({
     *   create: {
     *     // ... data to create a GroupChats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupChats we want to update
     *   }
     * })
     */
    upsert<T extends GroupChatsUpsertArgs>(args: SelectSubset<T, GroupChatsUpsertArgs<ExtArgs>>): Prisma__GroupChatsClient<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupChatsCountArgs} args - Arguments to filter GroupChats to count.
     * @example
     * // Count the number of GroupChats
     * const count = await prisma.groupChats.count({
     *   where: {
     *     // ... the filter for the GroupChats we want to count
     *   }
     * })
    **/
    count<T extends GroupChatsCountArgs>(
      args?: Subset<T, GroupChatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupChatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupChatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupChatsAggregateArgs>(args: Subset<T, GroupChatsAggregateArgs>): Prisma.PrismaPromise<GetGroupChatsAggregateType<T>>

    /**
     * Group by GroupChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupChatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupChatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupChatsGroupByArgs['orderBy'] }
        : { orderBy?: GroupChatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupChatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupChatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupChats model
   */
  readonly fields: GroupChatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupChats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupChatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Admin<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    GroupMembers<T extends GroupChats$GroupMembersArgs<ExtArgs> = {}>(args?: Subset<T, GroupChats$GroupMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GroupMessages<T extends GroupChats$GroupMessagesArgs<ExtArgs> = {}>(args?: Subset<T, GroupChats$GroupMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupChats model
   */
  interface GroupChatsFieldRefs {
    readonly id: FieldRef<"GroupChats", 'Int'>
    readonly admin_id: FieldRef<"GroupChats", 'Int'>
    readonly name: FieldRef<"GroupChats", 'String'>
    readonly description: FieldRef<"GroupChats", 'String'>
    readonly avatar: FieldRef<"GroupChats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GroupChats findUnique
   */
  export type GroupChatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsInclude<ExtArgs> | null
    /**
     * Filter, which GroupChats to fetch.
     */
    where: GroupChatsWhereUniqueInput
  }

  /**
   * GroupChats findUniqueOrThrow
   */
  export type GroupChatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsInclude<ExtArgs> | null
    /**
     * Filter, which GroupChats to fetch.
     */
    where: GroupChatsWhereUniqueInput
  }

  /**
   * GroupChats findFirst
   */
  export type GroupChatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsInclude<ExtArgs> | null
    /**
     * Filter, which GroupChats to fetch.
     */
    where?: GroupChatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupChats to fetch.
     */
    orderBy?: GroupChatsOrderByWithRelationInput | GroupChatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupChats.
     */
    cursor?: GroupChatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupChats.
     */
    distinct?: GroupChatsScalarFieldEnum | GroupChatsScalarFieldEnum[]
  }

  /**
   * GroupChats findFirstOrThrow
   */
  export type GroupChatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsInclude<ExtArgs> | null
    /**
     * Filter, which GroupChats to fetch.
     */
    where?: GroupChatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupChats to fetch.
     */
    orderBy?: GroupChatsOrderByWithRelationInput | GroupChatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupChats.
     */
    cursor?: GroupChatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupChats.
     */
    distinct?: GroupChatsScalarFieldEnum | GroupChatsScalarFieldEnum[]
  }

  /**
   * GroupChats findMany
   */
  export type GroupChatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsInclude<ExtArgs> | null
    /**
     * Filter, which GroupChats to fetch.
     */
    where?: GroupChatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupChats to fetch.
     */
    orderBy?: GroupChatsOrderByWithRelationInput | GroupChatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupChats.
     */
    cursor?: GroupChatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupChats.
     */
    skip?: number
    distinct?: GroupChatsScalarFieldEnum | GroupChatsScalarFieldEnum[]
  }

  /**
   * GroupChats create
   */
  export type GroupChatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupChats.
     */
    data: XOR<GroupChatsCreateInput, GroupChatsUncheckedCreateInput>
  }

  /**
   * GroupChats createMany
   */
  export type GroupChatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupChats.
     */
    data: GroupChatsCreateManyInput | GroupChatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupChats createManyAndReturn
   */
  export type GroupChatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * The data used to create many GroupChats.
     */
    data: GroupChatsCreateManyInput | GroupChatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupChats update
   */
  export type GroupChatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupChats.
     */
    data: XOR<GroupChatsUpdateInput, GroupChatsUncheckedUpdateInput>
    /**
     * Choose, which GroupChats to update.
     */
    where: GroupChatsWhereUniqueInput
  }

  /**
   * GroupChats updateMany
   */
  export type GroupChatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupChats.
     */
    data: XOR<GroupChatsUpdateManyMutationInput, GroupChatsUncheckedUpdateManyInput>
    /**
     * Filter which GroupChats to update
     */
    where?: GroupChatsWhereInput
    /**
     * Limit how many GroupChats to update.
     */
    limit?: number
  }

  /**
   * GroupChats updateManyAndReturn
   */
  export type GroupChatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * The data used to update GroupChats.
     */
    data: XOR<GroupChatsUpdateManyMutationInput, GroupChatsUncheckedUpdateManyInput>
    /**
     * Filter which GroupChats to update
     */
    where?: GroupChatsWhereInput
    /**
     * Limit how many GroupChats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupChats upsert
   */
  export type GroupChatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupChats to update in case it exists.
     */
    where: GroupChatsWhereUniqueInput
    /**
     * In case the GroupChats found by the `where` argument doesn't exist, create a new GroupChats with this data.
     */
    create: XOR<GroupChatsCreateInput, GroupChatsUncheckedCreateInput>
    /**
     * In case the GroupChats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupChatsUpdateInput, GroupChatsUncheckedUpdateInput>
  }

  /**
   * GroupChats delete
   */
  export type GroupChatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsInclude<ExtArgs> | null
    /**
     * Filter which GroupChats to delete.
     */
    where: GroupChatsWhereUniqueInput
  }

  /**
   * GroupChats deleteMany
   */
  export type GroupChatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupChats to delete
     */
    where?: GroupChatsWhereInput
    /**
     * Limit how many GroupChats to delete.
     */
    limit?: number
  }

  /**
   * GroupChats.GroupMembers
   */
  export type GroupChats$GroupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
    where?: GroupMembersWhereInput
    orderBy?: GroupMembersOrderByWithRelationInput | GroupMembersOrderByWithRelationInput[]
    cursor?: GroupMembersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMembersScalarFieldEnum | GroupMembersScalarFieldEnum[]
  }

  /**
   * GroupChats.GroupMessages
   */
  export type GroupChats$GroupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessages
     */
    select?: GroupMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessages
     */
    omit?: GroupMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessagesInclude<ExtArgs> | null
    where?: GroupMessagesWhereInput
    orderBy?: GroupMessagesOrderByWithRelationInput | GroupMessagesOrderByWithRelationInput[]
    cursor?: GroupMessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMessagesScalarFieldEnum | GroupMessagesScalarFieldEnum[]
  }

  /**
   * GroupChats without action
   */
  export type GroupChatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupChats
     */
    select?: GroupChatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupChats
     */
    omit?: GroupChatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupChatsInclude<ExtArgs> | null
  }


  /**
   * Model Blocks
   */

  export type AggregateBlocks = {
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  export type BlocksAvgAggregateOutputType = {
    blocked: number | null
    blocker: number | null
  }

  export type BlocksSumAggregateOutputType = {
    blocked: number | null
    blocker: number | null
  }

  export type BlocksMinAggregateOutputType = {
    blocked: number | null
    blocker: number | null
    friends: boolean | null
  }

  export type BlocksMaxAggregateOutputType = {
    blocked: number | null
    blocker: number | null
    friends: boolean | null
  }

  export type BlocksCountAggregateOutputType = {
    blocked: number
    blocker: number
    friends: number
    _all: number
  }


  export type BlocksAvgAggregateInputType = {
    blocked?: true
    blocker?: true
  }

  export type BlocksSumAggregateInputType = {
    blocked?: true
    blocker?: true
  }

  export type BlocksMinAggregateInputType = {
    blocked?: true
    blocker?: true
    friends?: true
  }

  export type BlocksMaxAggregateInputType = {
    blocked?: true
    blocker?: true
    friends?: true
  }

  export type BlocksCountAggregateInputType = {
    blocked?: true
    blocker?: true
    friends?: true
    _all?: true
  }

  export type BlocksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to aggregate.
     */
    where?: BlocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlocksOrderByWithRelationInput | BlocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlocksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlocksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlocksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlocksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlocksMaxAggregateInputType
  }

  export type GetBlocksAggregateType<T extends BlocksAggregateArgs> = {
        [P in keyof T & keyof AggregateBlocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlocks[P]>
      : GetScalarType<T[P], AggregateBlocks[P]>
  }




  export type BlocksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlocksWhereInput
    orderBy?: BlocksOrderByWithAggregationInput | BlocksOrderByWithAggregationInput[]
    by: BlocksScalarFieldEnum[] | BlocksScalarFieldEnum
    having?: BlocksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlocksCountAggregateInputType | true
    _avg?: BlocksAvgAggregateInputType
    _sum?: BlocksSumAggregateInputType
    _min?: BlocksMinAggregateInputType
    _max?: BlocksMaxAggregateInputType
  }

  export type BlocksGroupByOutputType = {
    blocked: number
    blocker: number
    friends: boolean | null
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  type GetBlocksGroupByPayload<T extends BlocksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlocksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlocksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlocksGroupByOutputType[P]>
            : GetScalarType<T[P], BlocksGroupByOutputType[P]>
        }
      >
    >


  export type BlocksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    blocked?: boolean
    blocker?: boolean
    friends?: boolean
    BlockedUser?: boolean | UsersDefaultArgs<ExtArgs>
    BlockingUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type BlocksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    blocked?: boolean
    blocker?: boolean
    friends?: boolean
    BlockedUser?: boolean | UsersDefaultArgs<ExtArgs>
    BlockingUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type BlocksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    blocked?: boolean
    blocker?: boolean
    friends?: boolean
    BlockedUser?: boolean | UsersDefaultArgs<ExtArgs>
    BlockingUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocks"]>

  export type BlocksSelectScalar = {
    blocked?: boolean
    blocker?: boolean
    friends?: boolean
  }

  export type BlocksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"blocked" | "blocker" | "friends", ExtArgs["result"]["blocks"]>
  export type BlocksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlockedUser?: boolean | UsersDefaultArgs<ExtArgs>
    BlockingUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type BlocksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlockedUser?: boolean | UsersDefaultArgs<ExtArgs>
    BlockingUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type BlocksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlockedUser?: boolean | UsersDefaultArgs<ExtArgs>
    BlockingUser?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $BlocksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blocks"
    objects: {
      BlockedUser: Prisma.$UsersPayload<ExtArgs>
      BlockingUser: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      blocked: number
      blocker: number
      friends: boolean | null
    }, ExtArgs["result"]["blocks"]>
    composites: {}
  }

  type BlocksGetPayload<S extends boolean | null | undefined | BlocksDefaultArgs> = $Result.GetResult<Prisma.$BlocksPayload, S>

  type BlocksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlocksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlocksCountAggregateInputType | true
    }

  export interface BlocksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blocks'], meta: { name: 'Blocks' } }
    /**
     * Find zero or one Blocks that matches the filter.
     * @param {BlocksFindUniqueArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlocksFindUniqueArgs>(args: SelectSubset<T, BlocksFindUniqueArgs<ExtArgs>>): Prisma__BlocksClient<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blocks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlocksFindUniqueOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlocksFindUniqueOrThrowArgs>(args: SelectSubset<T, BlocksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlocksClient<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksFindFirstArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlocksFindFirstArgs>(args?: SelectSubset<T, BlocksFindFirstArgs<ExtArgs>>): Prisma__BlocksClient<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blocks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksFindFirstOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlocksFindFirstOrThrowArgs>(args?: SelectSubset<T, BlocksFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlocksClient<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.blocks.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.blocks.findMany({ take: 10 })
     * 
     * // Only select the `blocked`
     * const blocksWithBlockedOnly = await prisma.blocks.findMany({ select: { blocked: true } })
     * 
     */
    findMany<T extends BlocksFindManyArgs>(args?: SelectSubset<T, BlocksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blocks.
     * @param {BlocksCreateArgs} args - Arguments to create a Blocks.
     * @example
     * // Create one Blocks
     * const Blocks = await prisma.blocks.create({
     *   data: {
     *     // ... data to create a Blocks
     *   }
     * })
     * 
     */
    create<T extends BlocksCreateArgs>(args: SelectSubset<T, BlocksCreateArgs<ExtArgs>>): Prisma__BlocksClient<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blocks.
     * @param {BlocksCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const blocks = await prisma.blocks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlocksCreateManyArgs>(args?: SelectSubset<T, BlocksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {BlocksCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const blocks = await prisma.blocks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `blocked`
     * const blocksWithBlockedOnly = await prisma.blocks.createManyAndReturn({
     *   select: { blocked: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlocksCreateManyAndReturnArgs>(args?: SelectSubset<T, BlocksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blocks.
     * @param {BlocksDeleteArgs} args - Arguments to delete one Blocks.
     * @example
     * // Delete one Blocks
     * const Blocks = await prisma.blocks.delete({
     *   where: {
     *     // ... filter to delete one Blocks
     *   }
     * })
     * 
     */
    delete<T extends BlocksDeleteArgs>(args: SelectSubset<T, BlocksDeleteArgs<ExtArgs>>): Prisma__BlocksClient<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blocks.
     * @param {BlocksUpdateArgs} args - Arguments to update one Blocks.
     * @example
     * // Update one Blocks
     * const blocks = await prisma.blocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlocksUpdateArgs>(args: SelectSubset<T, BlocksUpdateArgs<ExtArgs>>): Prisma__BlocksClient<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blocks.
     * @param {BlocksDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.blocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlocksDeleteManyArgs>(args?: SelectSubset<T, BlocksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const blocks = await prisma.blocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlocksUpdateManyArgs>(args: SelectSubset<T, BlocksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks and returns the data updated in the database.
     * @param {BlocksUpdateManyAndReturnArgs} args - Arguments to update many Blocks.
     * @example
     * // Update many Blocks
     * const blocks = await prisma.blocks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blocks and only return the `blocked`
     * const blocksWithBlockedOnly = await prisma.blocks.updateManyAndReturn({
     *   select: { blocked: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlocksUpdateManyAndReturnArgs>(args: SelectSubset<T, BlocksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blocks.
     * @param {BlocksUpsertArgs} args - Arguments to update or create a Blocks.
     * @example
     * // Update or create a Blocks
     * const blocks = await prisma.blocks.upsert({
     *   create: {
     *     // ... data to create a Blocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blocks we want to update
     *   }
     * })
     */
    upsert<T extends BlocksUpsertArgs>(args: SelectSubset<T, BlocksUpsertArgs<ExtArgs>>): Prisma__BlocksClient<$Result.GetResult<Prisma.$BlocksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.blocks.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlocksCountArgs>(
      args?: Subset<T, BlocksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlocksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlocksAggregateArgs>(args: Subset<T, BlocksAggregateArgs>): Prisma.PrismaPromise<GetBlocksAggregateType<T>>

    /**
     * Group by Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlocksGroupByArgs['orderBy'] }
        : { orderBy?: BlocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlocksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlocksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blocks model
   */
  readonly fields: BlocksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlocksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BlockedUser<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    BlockingUser<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blocks model
   */
  interface BlocksFieldRefs {
    readonly blocked: FieldRef<"Blocks", 'Int'>
    readonly blocker: FieldRef<"Blocks", 'Int'>
    readonly friends: FieldRef<"Blocks", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Blocks findUnique
   */
  export type BlocksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where: BlocksWhereUniqueInput
  }

  /**
   * Blocks findUniqueOrThrow
   */
  export type BlocksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where: BlocksWhereUniqueInput
  }

  /**
   * Blocks findFirst
   */
  export type BlocksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlocksOrderByWithRelationInput | BlocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * Blocks findFirstOrThrow
   */
  export type BlocksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlocksOrderByWithRelationInput | BlocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * Blocks findMany
   */
  export type BlocksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlocksOrderByWithRelationInput | BlocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }

  /**
   * Blocks create
   */
  export type BlocksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
    /**
     * The data needed to create a Blocks.
     */
    data: XOR<BlocksCreateInput, BlocksUncheckedCreateInput>
  }

  /**
   * Blocks createMany
   */
  export type BlocksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlocksCreateManyInput | BlocksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blocks createManyAndReturn
   */
  export type BlocksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * The data used to create many Blocks.
     */
    data: BlocksCreateManyInput | BlocksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blocks update
   */
  export type BlocksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
    /**
     * The data needed to update a Blocks.
     */
    data: XOR<BlocksUpdateInput, BlocksUncheckedUpdateInput>
    /**
     * Choose, which Blocks to update.
     */
    where: BlocksWhereUniqueInput
  }

  /**
   * Blocks updateMany
   */
  export type BlocksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlocksUpdateManyMutationInput, BlocksUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlocksWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
  }

  /**
   * Blocks updateManyAndReturn
   */
  export type BlocksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlocksUpdateManyMutationInput, BlocksUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlocksWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blocks upsert
   */
  export type BlocksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
    /**
     * The filter to search for the Blocks to update in case it exists.
     */
    where: BlocksWhereUniqueInput
    /**
     * In case the Blocks found by the `where` argument doesn't exist, create a new Blocks with this data.
     */
    create: XOR<BlocksCreateInput, BlocksUncheckedCreateInput>
    /**
     * In case the Blocks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlocksUpdateInput, BlocksUncheckedUpdateInput>
  }

  /**
   * Blocks delete
   */
  export type BlocksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
    /**
     * Filter which Blocks to delete.
     */
    where: BlocksWhereUniqueInput
  }

  /**
   * Blocks deleteMany
   */
  export type BlocksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlocksWhereInput
    /**
     * Limit how many Blocks to delete.
     */
    limit?: number
  }

  /**
   * Blocks without action
   */
  export type BlocksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blocks
     */
    select?: BlocksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blocks
     */
    omit?: BlocksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocksInclude<ExtArgs> | null
  }


  /**
   * Model GroupMembers
   */

  export type AggregateGroupMembers = {
    _count: GroupMembersCountAggregateOutputType | null
    _avg: GroupMembersAvgAggregateOutputType | null
    _sum: GroupMembersSumAggregateOutputType | null
    _min: GroupMembersMinAggregateOutputType | null
    _max: GroupMembersMaxAggregateOutputType | null
  }

  export type GroupMembersAvgAggregateOutputType = {
    group_id: number | null
    member_id: number | null
  }

  export type GroupMembersSumAggregateOutputType = {
    group_id: number | null
    member_id: number | null
  }

  export type GroupMembersMinAggregateOutputType = {
    group_id: number | null
    member_id: number | null
  }

  export type GroupMembersMaxAggregateOutputType = {
    group_id: number | null
    member_id: number | null
  }

  export type GroupMembersCountAggregateOutputType = {
    group_id: number
    member_id: number
    _all: number
  }


  export type GroupMembersAvgAggregateInputType = {
    group_id?: true
    member_id?: true
  }

  export type GroupMembersSumAggregateInputType = {
    group_id?: true
    member_id?: true
  }

  export type GroupMembersMinAggregateInputType = {
    group_id?: true
    member_id?: true
  }

  export type GroupMembersMaxAggregateInputType = {
    group_id?: true
    member_id?: true
  }

  export type GroupMembersCountAggregateInputType = {
    group_id?: true
    member_id?: true
    _all?: true
  }

  export type GroupMembersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembers to aggregate.
     */
    where?: GroupMembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMembersOrderByWithRelationInput | GroupMembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMembers
    **/
    _count?: true | GroupMembersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupMembersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupMembersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMembersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMembersMaxAggregateInputType
  }

  export type GetGroupMembersAggregateType<T extends GroupMembersAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMembers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMembers[P]>
      : GetScalarType<T[P], AggregateGroupMembers[P]>
  }




  export type GroupMembersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMembersWhereInput
    orderBy?: GroupMembersOrderByWithAggregationInput | GroupMembersOrderByWithAggregationInput[]
    by: GroupMembersScalarFieldEnum[] | GroupMembersScalarFieldEnum
    having?: GroupMembersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMembersCountAggregateInputType | true
    _avg?: GroupMembersAvgAggregateInputType
    _sum?: GroupMembersSumAggregateInputType
    _min?: GroupMembersMinAggregateInputType
    _max?: GroupMembersMaxAggregateInputType
  }

  export type GroupMembersGroupByOutputType = {
    group_id: number
    member_id: number
    _count: GroupMembersCountAggregateOutputType | null
    _avg: GroupMembersAvgAggregateOutputType | null
    _sum: GroupMembersSumAggregateOutputType | null
    _min: GroupMembersMinAggregateOutputType | null
    _max: GroupMembersMaxAggregateOutputType | null
  }

  type GetGroupMembersGroupByPayload<T extends GroupMembersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMembersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMembersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMembersGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMembersGroupByOutputType[P]>
        }
      >
    >


  export type GroupMembersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    group_id?: boolean
    member_id?: boolean
    Member?: boolean | UsersDefaultArgs<ExtArgs>
    Group?: boolean | GroupChatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMembers"]>

  export type GroupMembersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    group_id?: boolean
    member_id?: boolean
    Member?: boolean | UsersDefaultArgs<ExtArgs>
    Group?: boolean | GroupChatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMembers"]>

  export type GroupMembersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    group_id?: boolean
    member_id?: boolean
    Member?: boolean | UsersDefaultArgs<ExtArgs>
    Group?: boolean | GroupChatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMembers"]>

  export type GroupMembersSelectScalar = {
    group_id?: boolean
    member_id?: boolean
  }

  export type GroupMembersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"group_id" | "member_id", ExtArgs["result"]["groupMembers"]>
  export type GroupMembersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Member?: boolean | UsersDefaultArgs<ExtArgs>
    Group?: boolean | GroupChatsDefaultArgs<ExtArgs>
  }
  export type GroupMembersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Member?: boolean | UsersDefaultArgs<ExtArgs>
    Group?: boolean | GroupChatsDefaultArgs<ExtArgs>
  }
  export type GroupMembersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Member?: boolean | UsersDefaultArgs<ExtArgs>
    Group?: boolean | GroupChatsDefaultArgs<ExtArgs>
  }

  export type $GroupMembersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMembers"
    objects: {
      Member: Prisma.$UsersPayload<ExtArgs>
      Group: Prisma.$GroupChatsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      group_id: number
      member_id: number
    }, ExtArgs["result"]["groupMembers"]>
    composites: {}
  }

  type GroupMembersGetPayload<S extends boolean | null | undefined | GroupMembersDefaultArgs> = $Result.GetResult<Prisma.$GroupMembersPayload, S>

  type GroupMembersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMembersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMembersCountAggregateInputType | true
    }

  export interface GroupMembersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMembers'], meta: { name: 'GroupMembers' } }
    /**
     * Find zero or one GroupMembers that matches the filter.
     * @param {GroupMembersFindUniqueArgs} args - Arguments to find a GroupMembers
     * @example
     * // Get one GroupMembers
     * const groupMembers = await prisma.groupMembers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMembersFindUniqueArgs>(args: SelectSubset<T, GroupMembersFindUniqueArgs<ExtArgs>>): Prisma__GroupMembersClient<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMembers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMembersFindUniqueOrThrowArgs} args - Arguments to find a GroupMembers
     * @example
     * // Get one GroupMembers
     * const groupMembers = await prisma.groupMembers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMembersFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMembersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMembersClient<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembersFindFirstArgs} args - Arguments to find a GroupMembers
     * @example
     * // Get one GroupMembers
     * const groupMembers = await prisma.groupMembers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMembersFindFirstArgs>(args?: SelectSubset<T, GroupMembersFindFirstArgs<ExtArgs>>): Prisma__GroupMembersClient<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMembers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembersFindFirstOrThrowArgs} args - Arguments to find a GroupMembers
     * @example
     * // Get one GroupMembers
     * const groupMembers = await prisma.groupMembers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMembersFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMembersFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMembersClient<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMembers
     * const groupMembers = await prisma.groupMembers.findMany()
     * 
     * // Get first 10 GroupMembers
     * const groupMembers = await prisma.groupMembers.findMany({ take: 10 })
     * 
     * // Only select the `group_id`
     * const groupMembersWithGroup_idOnly = await prisma.groupMembers.findMany({ select: { group_id: true } })
     * 
     */
    findMany<T extends GroupMembersFindManyArgs>(args?: SelectSubset<T, GroupMembersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMembers.
     * @param {GroupMembersCreateArgs} args - Arguments to create a GroupMembers.
     * @example
     * // Create one GroupMembers
     * const GroupMembers = await prisma.groupMembers.create({
     *   data: {
     *     // ... data to create a GroupMembers
     *   }
     * })
     * 
     */
    create<T extends GroupMembersCreateArgs>(args: SelectSubset<T, GroupMembersCreateArgs<ExtArgs>>): Prisma__GroupMembersClient<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMembers.
     * @param {GroupMembersCreateManyArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMembers = await prisma.groupMembers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMembersCreateManyArgs>(args?: SelectSubset<T, GroupMembersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMembers and returns the data saved in the database.
     * @param {GroupMembersCreateManyAndReturnArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMembers = await prisma.groupMembers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMembers and only return the `group_id`
     * const groupMembersWithGroup_idOnly = await prisma.groupMembers.createManyAndReturn({
     *   select: { group_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMembersCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMembersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupMembers.
     * @param {GroupMembersDeleteArgs} args - Arguments to delete one GroupMembers.
     * @example
     * // Delete one GroupMembers
     * const GroupMembers = await prisma.groupMembers.delete({
     *   where: {
     *     // ... filter to delete one GroupMembers
     *   }
     * })
     * 
     */
    delete<T extends GroupMembersDeleteArgs>(args: SelectSubset<T, GroupMembersDeleteArgs<ExtArgs>>): Prisma__GroupMembersClient<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMembers.
     * @param {GroupMembersUpdateArgs} args - Arguments to update one GroupMembers.
     * @example
     * // Update one GroupMembers
     * const groupMembers = await prisma.groupMembers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMembersUpdateArgs>(args: SelectSubset<T, GroupMembersUpdateArgs<ExtArgs>>): Prisma__GroupMembersClient<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMembers.
     * @param {GroupMembersDeleteManyArgs} args - Arguments to filter GroupMembers to delete.
     * @example
     * // Delete a few GroupMembers
     * const { count } = await prisma.groupMembers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMembersDeleteManyArgs>(args?: SelectSubset<T, GroupMembersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMembers
     * const groupMembers = await prisma.groupMembers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMembersUpdateManyArgs>(args: SelectSubset<T, GroupMembersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers and returns the data updated in the database.
     * @param {GroupMembersUpdateManyAndReturnArgs} args - Arguments to update many GroupMembers.
     * @example
     * // Update many GroupMembers
     * const groupMembers = await prisma.groupMembers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMembers and only return the `group_id`
     * const groupMembersWithGroup_idOnly = await prisma.groupMembers.updateManyAndReturn({
     *   select: { group_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupMembersUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupMembersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupMembers.
     * @param {GroupMembersUpsertArgs} args - Arguments to update or create a GroupMembers.
     * @example
     * // Update or create a GroupMembers
     * const groupMembers = await prisma.groupMembers.upsert({
     *   create: {
     *     // ... data to create a GroupMembers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMembers we want to update
     *   }
     * })
     */
    upsert<T extends GroupMembersUpsertArgs>(args: SelectSubset<T, GroupMembersUpsertArgs<ExtArgs>>): Prisma__GroupMembersClient<$Result.GetResult<Prisma.$GroupMembersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembersCountArgs} args - Arguments to filter GroupMembers to count.
     * @example
     * // Count the number of GroupMembers
     * const count = await prisma.groupMembers.count({
     *   where: {
     *     // ... the filter for the GroupMembers we want to count
     *   }
     * })
    **/
    count<T extends GroupMembersCountArgs>(
      args?: Subset<T, GroupMembersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMembersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMembersAggregateArgs>(args: Subset<T, GroupMembersAggregateArgs>): Prisma.PrismaPromise<GetGroupMembersAggregateType<T>>

    /**
     * Group by GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMembersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMembersGroupByArgs['orderBy'] }
        : { orderBy?: GroupMembersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMembersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMembersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMembers model
   */
  readonly fields: GroupMembersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMembers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMembersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Member<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Group<T extends GroupChatsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupChatsDefaultArgs<ExtArgs>>): Prisma__GroupChatsClient<$Result.GetResult<Prisma.$GroupChatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMembers model
   */
  interface GroupMembersFieldRefs {
    readonly group_id: FieldRef<"GroupMembers", 'Int'>
    readonly member_id: FieldRef<"GroupMembers", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GroupMembers findUnique
   */
  export type GroupMembersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where: GroupMembersWhereUniqueInput
  }

  /**
   * GroupMembers findUniqueOrThrow
   */
  export type GroupMembersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where: GroupMembersWhereUniqueInput
  }

  /**
   * GroupMembers findFirst
   */
  export type GroupMembersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMembersOrderByWithRelationInput | GroupMembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMembersScalarFieldEnum | GroupMembersScalarFieldEnum[]
  }

  /**
   * GroupMembers findFirstOrThrow
   */
  export type GroupMembersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMembersOrderByWithRelationInput | GroupMembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMembersScalarFieldEnum | GroupMembersScalarFieldEnum[]
  }

  /**
   * GroupMembers findMany
   */
  export type GroupMembersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMembersOrderByWithRelationInput | GroupMembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMembers.
     */
    cursor?: GroupMembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    distinct?: GroupMembersScalarFieldEnum | GroupMembersScalarFieldEnum[]
  }

  /**
   * GroupMembers create
   */
  export type GroupMembersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMembers.
     */
    data: XOR<GroupMembersCreateInput, GroupMembersUncheckedCreateInput>
  }

  /**
   * GroupMembers createMany
   */
  export type GroupMembersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMembersCreateManyInput | GroupMembersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMembers createManyAndReturn
   */
  export type GroupMembersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMembersCreateManyInput | GroupMembersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMembers update
   */
  export type GroupMembersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMembers.
     */
    data: XOR<GroupMembersUpdateInput, GroupMembersUncheckedUpdateInput>
    /**
     * Choose, which GroupMembers to update.
     */
    where: GroupMembersWhereUniqueInput
  }

  /**
   * GroupMembers updateMany
   */
  export type GroupMembersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMembersUpdateManyMutationInput, GroupMembersUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMembersWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
  }

  /**
   * GroupMembers updateManyAndReturn
   */
  export type GroupMembersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMembersUpdateManyMutationInput, GroupMembersUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMembersWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMembers upsert
   */
  export type GroupMembersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMembers to update in case it exists.
     */
    where: GroupMembersWhereUniqueInput
    /**
     * In case the GroupMembers found by the `where` argument doesn't exist, create a new GroupMembers with this data.
     */
    create: XOR<GroupMembersCreateInput, GroupMembersUncheckedCreateInput>
    /**
     * In case the GroupMembers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMembersUpdateInput, GroupMembersUncheckedUpdateInput>
  }

  /**
   * GroupMembers delete
   */
  export type GroupMembersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
    /**
     * Filter which GroupMembers to delete.
     */
    where: GroupMembersWhereUniqueInput
  }

  /**
   * GroupMembers deleteMany
   */
  export type GroupMembersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembers to delete
     */
    where?: GroupMembersWhereInput
    /**
     * Limit how many GroupMembers to delete.
     */
    limit?: number
  }

  /**
   * GroupMembers without action
   */
  export type GroupMembersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembers
     */
    select?: GroupMembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembers
     */
    omit?: GroupMembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    email: 'email',
    bio: 'bio',
    avatar: 'avatar'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const PrivateMessagesScalarFieldEnum: {
    id: 'id',
    sender_id: 'sender_id',
    receiver_id: 'receiver_id',
    content: 'content',
    created_at: 'created_at'
  };

  export type PrivateMessagesScalarFieldEnum = (typeof PrivateMessagesScalarFieldEnum)[keyof typeof PrivateMessagesScalarFieldEnum]


  export const PrivateMessagesAttachmentScalarFieldEnum: {
    id: 'id',
    message_id: 'message_id',
    size: 'size',
    path: 'path',
    originalName: 'originalName',
    uniqueFileName: 'uniqueFileName',
    created_at: 'created_at'
  };

  export type PrivateMessagesAttachmentScalarFieldEnum = (typeof PrivateMessagesAttachmentScalarFieldEnum)[keyof typeof PrivateMessagesAttachmentScalarFieldEnum]


  export const GroupMessagesScalarFieldEnum: {
    id: 'id',
    sender_id: 'sender_id',
    group_id: 'group_id',
    content: 'content',
    created_at: 'created_at'
  };

  export type GroupMessagesScalarFieldEnum = (typeof GroupMessagesScalarFieldEnum)[keyof typeof GroupMessagesScalarFieldEnum]


  export const GroupMessagesAttachmentScalarFieldEnum: {
    id: 'id',
    message_id: 'message_id',
    size: 'size',
    path: 'path',
    originalName: 'originalName',
    uniqueFileName: 'uniqueFileName',
    created_at: 'created_at'
  };

  export type GroupMessagesAttachmentScalarFieldEnum = (typeof GroupMessagesAttachmentScalarFieldEnum)[keyof typeof GroupMessagesAttachmentScalarFieldEnum]


  export const FriendsScalarFieldEnum: {
    user_id: 'user_id',
    friend_id: 'friend_id'
  };

  export type FriendsScalarFieldEnum = (typeof FriendsScalarFieldEnum)[keyof typeof FriendsScalarFieldEnum]


  export const PendingFriendRequestsScalarFieldEnum: {
    sender_id: 'sender_id',
    receiver_id: 'receiver_id'
  };

  export type PendingFriendRequestsScalarFieldEnum = (typeof PendingFriendRequestsScalarFieldEnum)[keyof typeof PendingFriendRequestsScalarFieldEnum]


  export const GroupChatsScalarFieldEnum: {
    id: 'id',
    admin_id: 'admin_id',
    name: 'name',
    description: 'description',
    avatar: 'avatar'
  };

  export type GroupChatsScalarFieldEnum = (typeof GroupChatsScalarFieldEnum)[keyof typeof GroupChatsScalarFieldEnum]


  export const BlocksScalarFieldEnum: {
    blocked: 'blocked',
    blocker: 'blocker',
    friends: 'friends'
  };

  export type BlocksScalarFieldEnum = (typeof BlocksScalarFieldEnum)[keyof typeof BlocksScalarFieldEnum]


  export const GroupMembersScalarFieldEnum: {
    group_id: 'group_id',
    member_id: 'member_id'
  };

  export type GroupMembersScalarFieldEnum = (typeof GroupMembersScalarFieldEnum)[keyof typeof GroupMembersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: IntFilter<"Users"> | number
    username?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    bio?: StringNullableFilter<"Users"> | string | null
    avatar?: StringNullableFilter<"Users"> | string | null
    messagesSent?: PrivateMessagesListRelationFilter
    messagesReceived?: PrivateMessagesListRelationFilter
    friends?: FriendsListRelationFilter
    pendingRequestsSent?: PendingFriendRequestsListRelationFilter
    pendingRequestsReceived?: PendingFriendRequestsListRelationFilter
    Friends?: FriendsListRelationFilter
    GroupChats?: GroupChatsListRelationFilter
    GroupMembers?: GroupMembersListRelationFilter
    GroupMessages?: GroupMessagesListRelationFilter
    blocking?: BlocksListRelationFilter
    blockedBy?: BlocksListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    messagesSent?: PrivateMessagesOrderByRelationAggregateInput
    messagesReceived?: PrivateMessagesOrderByRelationAggregateInput
    friends?: FriendsOrderByRelationAggregateInput
    pendingRequestsSent?: PendingFriendRequestsOrderByRelationAggregateInput
    pendingRequestsReceived?: PendingFriendRequestsOrderByRelationAggregateInput
    Friends?: FriendsOrderByRelationAggregateInput
    GroupChats?: GroupChatsOrderByRelationAggregateInput
    GroupMembers?: GroupMembersOrderByRelationAggregateInput
    GroupMessages?: GroupMessagesOrderByRelationAggregateInput
    blocking?: BlocksOrderByRelationAggregateInput
    blockedBy?: BlocksOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    password?: StringFilter<"Users"> | string
    bio?: StringNullableFilter<"Users"> | string | null
    avatar?: StringNullableFilter<"Users"> | string | null
    messagesSent?: PrivateMessagesListRelationFilter
    messagesReceived?: PrivateMessagesListRelationFilter
    friends?: FriendsListRelationFilter
    pendingRequestsSent?: PendingFriendRequestsListRelationFilter
    pendingRequestsReceived?: PendingFriendRequestsListRelationFilter
    Friends?: FriendsListRelationFilter
    GroupChats?: GroupChatsListRelationFilter
    GroupMembers?: GroupMembersListRelationFilter
    GroupMessages?: GroupMessagesListRelationFilter
    blocking?: BlocksListRelationFilter
    blockedBy?: BlocksListRelationFilter
  }, "id" | "username" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Users"> | number
    username?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    bio?: StringNullableWithAggregatesFilter<"Users"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Users"> | string | null
  }

  export type PrivateMessagesWhereInput = {
    AND?: PrivateMessagesWhereInput | PrivateMessagesWhereInput[]
    OR?: PrivateMessagesWhereInput[]
    NOT?: PrivateMessagesWhereInput | PrivateMessagesWhereInput[]
    id?: IntFilter<"PrivateMessages"> | number
    sender_id?: IntFilter<"PrivateMessages"> | number
    receiver_id?: IntFilter<"PrivateMessages"> | number
    content?: StringFilter<"PrivateMessages"> | string
    created_at?: DateTimeFilter<"PrivateMessages"> | Date | string
    sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    receiver?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    attachments?: PrivateMessagesAttachmentListRelationFilter
  }

  export type PrivateMessagesOrderByWithRelationInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    sender?: UsersOrderByWithRelationInput
    receiver?: UsersOrderByWithRelationInput
    attachments?: PrivateMessagesAttachmentOrderByRelationAggregateInput
  }

  export type PrivateMessagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrivateMessagesWhereInput | PrivateMessagesWhereInput[]
    OR?: PrivateMessagesWhereInput[]
    NOT?: PrivateMessagesWhereInput | PrivateMessagesWhereInput[]
    sender_id?: IntFilter<"PrivateMessages"> | number
    receiver_id?: IntFilter<"PrivateMessages"> | number
    content?: StringFilter<"PrivateMessages"> | string
    created_at?: DateTimeFilter<"PrivateMessages"> | Date | string
    sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    receiver?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    attachments?: PrivateMessagesAttachmentListRelationFilter
  }, "id">

  export type PrivateMessagesOrderByWithAggregationInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    _count?: PrivateMessagesCountOrderByAggregateInput
    _avg?: PrivateMessagesAvgOrderByAggregateInput
    _max?: PrivateMessagesMaxOrderByAggregateInput
    _min?: PrivateMessagesMinOrderByAggregateInput
    _sum?: PrivateMessagesSumOrderByAggregateInput
  }

  export type PrivateMessagesScalarWhereWithAggregatesInput = {
    AND?: PrivateMessagesScalarWhereWithAggregatesInput | PrivateMessagesScalarWhereWithAggregatesInput[]
    OR?: PrivateMessagesScalarWhereWithAggregatesInput[]
    NOT?: PrivateMessagesScalarWhereWithAggregatesInput | PrivateMessagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrivateMessages"> | number
    sender_id?: IntWithAggregatesFilter<"PrivateMessages"> | number
    receiver_id?: IntWithAggregatesFilter<"PrivateMessages"> | number
    content?: StringWithAggregatesFilter<"PrivateMessages"> | string
    created_at?: DateTimeWithAggregatesFilter<"PrivateMessages"> | Date | string
  }

  export type PrivateMessagesAttachmentWhereInput = {
    AND?: PrivateMessagesAttachmentWhereInput | PrivateMessagesAttachmentWhereInput[]
    OR?: PrivateMessagesAttachmentWhereInput[]
    NOT?: PrivateMessagesAttachmentWhereInput | PrivateMessagesAttachmentWhereInput[]
    id?: IntFilter<"PrivateMessagesAttachment"> | number
    message_id?: IntFilter<"PrivateMessagesAttachment"> | number
    size?: IntFilter<"PrivateMessagesAttachment"> | number
    path?: StringFilter<"PrivateMessagesAttachment"> | string
    originalName?: StringFilter<"PrivateMessagesAttachment"> | string
    uniqueFileName?: StringFilter<"PrivateMessagesAttachment"> | string
    created_at?: DateTimeFilter<"PrivateMessagesAttachment"> | Date | string
    privateMessage?: XOR<PrivateMessagesScalarRelationFilter, PrivateMessagesWhereInput>
  }

  export type PrivateMessagesAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
    path?: SortOrder
    originalName?: SortOrder
    uniqueFileName?: SortOrder
    created_at?: SortOrder
    privateMessage?: PrivateMessagesOrderByWithRelationInput
  }

  export type PrivateMessagesAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrivateMessagesAttachmentWhereInput | PrivateMessagesAttachmentWhereInput[]
    OR?: PrivateMessagesAttachmentWhereInput[]
    NOT?: PrivateMessagesAttachmentWhereInput | PrivateMessagesAttachmentWhereInput[]
    message_id?: IntFilter<"PrivateMessagesAttachment"> | number
    size?: IntFilter<"PrivateMessagesAttachment"> | number
    path?: StringFilter<"PrivateMessagesAttachment"> | string
    originalName?: StringFilter<"PrivateMessagesAttachment"> | string
    uniqueFileName?: StringFilter<"PrivateMessagesAttachment"> | string
    created_at?: DateTimeFilter<"PrivateMessagesAttachment"> | Date | string
    privateMessage?: XOR<PrivateMessagesScalarRelationFilter, PrivateMessagesWhereInput>
  }, "id">

  export type PrivateMessagesAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
    path?: SortOrder
    originalName?: SortOrder
    uniqueFileName?: SortOrder
    created_at?: SortOrder
    _count?: PrivateMessagesAttachmentCountOrderByAggregateInput
    _avg?: PrivateMessagesAttachmentAvgOrderByAggregateInput
    _max?: PrivateMessagesAttachmentMaxOrderByAggregateInput
    _min?: PrivateMessagesAttachmentMinOrderByAggregateInput
    _sum?: PrivateMessagesAttachmentSumOrderByAggregateInput
  }

  export type PrivateMessagesAttachmentScalarWhereWithAggregatesInput = {
    AND?: PrivateMessagesAttachmentScalarWhereWithAggregatesInput | PrivateMessagesAttachmentScalarWhereWithAggregatesInput[]
    OR?: PrivateMessagesAttachmentScalarWhereWithAggregatesInput[]
    NOT?: PrivateMessagesAttachmentScalarWhereWithAggregatesInput | PrivateMessagesAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrivateMessagesAttachment"> | number
    message_id?: IntWithAggregatesFilter<"PrivateMessagesAttachment"> | number
    size?: IntWithAggregatesFilter<"PrivateMessagesAttachment"> | number
    path?: StringWithAggregatesFilter<"PrivateMessagesAttachment"> | string
    originalName?: StringWithAggregatesFilter<"PrivateMessagesAttachment"> | string
    uniqueFileName?: StringWithAggregatesFilter<"PrivateMessagesAttachment"> | string
    created_at?: DateTimeWithAggregatesFilter<"PrivateMessagesAttachment"> | Date | string
  }

  export type GroupMessagesWhereInput = {
    AND?: GroupMessagesWhereInput | GroupMessagesWhereInput[]
    OR?: GroupMessagesWhereInput[]
    NOT?: GroupMessagesWhereInput | GroupMessagesWhereInput[]
    id?: IntFilter<"GroupMessages"> | number
    sender_id?: IntFilter<"GroupMessages"> | number
    group_id?: IntFilter<"GroupMessages"> | number
    content?: StringFilter<"GroupMessages"> | string
    created_at?: DateTimeFilter<"GroupMessages"> | Date | string
    group?: XOR<GroupChatsScalarRelationFilter, GroupChatsWhereInput>
    sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    attachments?: GroupMessagesAttachmentListRelationFilter
  }

  export type GroupMessagesOrderByWithRelationInput = {
    id?: SortOrder
    sender_id?: SortOrder
    group_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    group?: GroupChatsOrderByWithRelationInput
    sender?: UsersOrderByWithRelationInput
    attachments?: GroupMessagesAttachmentOrderByRelationAggregateInput
  }

  export type GroupMessagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GroupMessagesWhereInput | GroupMessagesWhereInput[]
    OR?: GroupMessagesWhereInput[]
    NOT?: GroupMessagesWhereInput | GroupMessagesWhereInput[]
    sender_id?: IntFilter<"GroupMessages"> | number
    group_id?: IntFilter<"GroupMessages"> | number
    content?: StringFilter<"GroupMessages"> | string
    created_at?: DateTimeFilter<"GroupMessages"> | Date | string
    group?: XOR<GroupChatsScalarRelationFilter, GroupChatsWhereInput>
    sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    attachments?: GroupMessagesAttachmentListRelationFilter
  }, "id">

  export type GroupMessagesOrderByWithAggregationInput = {
    id?: SortOrder
    sender_id?: SortOrder
    group_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    _count?: GroupMessagesCountOrderByAggregateInput
    _avg?: GroupMessagesAvgOrderByAggregateInput
    _max?: GroupMessagesMaxOrderByAggregateInput
    _min?: GroupMessagesMinOrderByAggregateInput
    _sum?: GroupMessagesSumOrderByAggregateInput
  }

  export type GroupMessagesScalarWhereWithAggregatesInput = {
    AND?: GroupMessagesScalarWhereWithAggregatesInput | GroupMessagesScalarWhereWithAggregatesInput[]
    OR?: GroupMessagesScalarWhereWithAggregatesInput[]
    NOT?: GroupMessagesScalarWhereWithAggregatesInput | GroupMessagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GroupMessages"> | number
    sender_id?: IntWithAggregatesFilter<"GroupMessages"> | number
    group_id?: IntWithAggregatesFilter<"GroupMessages"> | number
    content?: StringWithAggregatesFilter<"GroupMessages"> | string
    created_at?: DateTimeWithAggregatesFilter<"GroupMessages"> | Date | string
  }

  export type GroupMessagesAttachmentWhereInput = {
    AND?: GroupMessagesAttachmentWhereInput | GroupMessagesAttachmentWhereInput[]
    OR?: GroupMessagesAttachmentWhereInput[]
    NOT?: GroupMessagesAttachmentWhereInput | GroupMessagesAttachmentWhereInput[]
    id?: IntFilter<"GroupMessagesAttachment"> | number
    message_id?: IntFilter<"GroupMessagesAttachment"> | number
    size?: IntFilter<"GroupMessagesAttachment"> | number
    path?: StringFilter<"GroupMessagesAttachment"> | string
    originalName?: StringFilter<"GroupMessagesAttachment"> | string
    uniqueFileName?: StringFilter<"GroupMessagesAttachment"> | string
    created_at?: DateTimeFilter<"GroupMessagesAttachment"> | Date | string
    groupMessage?: XOR<GroupMessagesScalarRelationFilter, GroupMessagesWhereInput>
  }

  export type GroupMessagesAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
    path?: SortOrder
    originalName?: SortOrder
    uniqueFileName?: SortOrder
    created_at?: SortOrder
    groupMessage?: GroupMessagesOrderByWithRelationInput
  }

  export type GroupMessagesAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GroupMessagesAttachmentWhereInput | GroupMessagesAttachmentWhereInput[]
    OR?: GroupMessagesAttachmentWhereInput[]
    NOT?: GroupMessagesAttachmentWhereInput | GroupMessagesAttachmentWhereInput[]
    message_id?: IntFilter<"GroupMessagesAttachment"> | number
    size?: IntFilter<"GroupMessagesAttachment"> | number
    path?: StringFilter<"GroupMessagesAttachment"> | string
    originalName?: StringFilter<"GroupMessagesAttachment"> | string
    uniqueFileName?: StringFilter<"GroupMessagesAttachment"> | string
    created_at?: DateTimeFilter<"GroupMessagesAttachment"> | Date | string
    groupMessage?: XOR<GroupMessagesScalarRelationFilter, GroupMessagesWhereInput>
  }, "id">

  export type GroupMessagesAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
    path?: SortOrder
    originalName?: SortOrder
    uniqueFileName?: SortOrder
    created_at?: SortOrder
    _count?: GroupMessagesAttachmentCountOrderByAggregateInput
    _avg?: GroupMessagesAttachmentAvgOrderByAggregateInput
    _max?: GroupMessagesAttachmentMaxOrderByAggregateInput
    _min?: GroupMessagesAttachmentMinOrderByAggregateInput
    _sum?: GroupMessagesAttachmentSumOrderByAggregateInput
  }

  export type GroupMessagesAttachmentScalarWhereWithAggregatesInput = {
    AND?: GroupMessagesAttachmentScalarWhereWithAggregatesInput | GroupMessagesAttachmentScalarWhereWithAggregatesInput[]
    OR?: GroupMessagesAttachmentScalarWhereWithAggregatesInput[]
    NOT?: GroupMessagesAttachmentScalarWhereWithAggregatesInput | GroupMessagesAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GroupMessagesAttachment"> | number
    message_id?: IntWithAggregatesFilter<"GroupMessagesAttachment"> | number
    size?: IntWithAggregatesFilter<"GroupMessagesAttachment"> | number
    path?: StringWithAggregatesFilter<"GroupMessagesAttachment"> | string
    originalName?: StringWithAggregatesFilter<"GroupMessagesAttachment"> | string
    uniqueFileName?: StringWithAggregatesFilter<"GroupMessagesAttachment"> | string
    created_at?: DateTimeWithAggregatesFilter<"GroupMessagesAttachment"> | Date | string
  }

  export type FriendsWhereInput = {
    AND?: FriendsWhereInput | FriendsWhereInput[]
    OR?: FriendsWhereInput[]
    NOT?: FriendsWhereInput | FriendsWhereInput[]
    user_id?: IntFilter<"Friends"> | number
    friend_id?: IntFilter<"Friends"> | number
    User?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Friend?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type FriendsOrderByWithRelationInput = {
    user_id?: SortOrder
    friend_id?: SortOrder
    User?: UsersOrderByWithRelationInput
    Friend?: UsersOrderByWithRelationInput
  }

  export type FriendsWhereUniqueInput = Prisma.AtLeast<{
    friend_id_user_id?: FriendsFriend_idUser_idCompoundUniqueInput
    user_id_friend_id?: FriendsUser_idFriend_idCompoundUniqueInput
    AND?: FriendsWhereInput | FriendsWhereInput[]
    OR?: FriendsWhereInput[]
    NOT?: FriendsWhereInput | FriendsWhereInput[]
    user_id?: IntFilter<"Friends"> | number
    friend_id?: IntFilter<"Friends"> | number
    User?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Friend?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "user_id_friend_id" | "friend_id_user_id">

  export type FriendsOrderByWithAggregationInput = {
    user_id?: SortOrder
    friend_id?: SortOrder
    _count?: FriendsCountOrderByAggregateInput
    _avg?: FriendsAvgOrderByAggregateInput
    _max?: FriendsMaxOrderByAggregateInput
    _min?: FriendsMinOrderByAggregateInput
    _sum?: FriendsSumOrderByAggregateInput
  }

  export type FriendsScalarWhereWithAggregatesInput = {
    AND?: FriendsScalarWhereWithAggregatesInput | FriendsScalarWhereWithAggregatesInput[]
    OR?: FriendsScalarWhereWithAggregatesInput[]
    NOT?: FriendsScalarWhereWithAggregatesInput | FriendsScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"Friends"> | number
    friend_id?: IntWithAggregatesFilter<"Friends"> | number
  }

  export type PendingFriendRequestsWhereInput = {
    AND?: PendingFriendRequestsWhereInput | PendingFriendRequestsWhereInput[]
    OR?: PendingFriendRequestsWhereInput[]
    NOT?: PendingFriendRequestsWhereInput | PendingFriendRequestsWhereInput[]
    sender_id?: IntFilter<"PendingFriendRequests"> | number
    receiver_id?: IntFilter<"PendingFriendRequests"> | number
    Sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Receiver?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type PendingFriendRequestsOrderByWithRelationInput = {
    sender_id?: SortOrder
    receiver_id?: SortOrder
    Sender?: UsersOrderByWithRelationInput
    Receiver?: UsersOrderByWithRelationInput
  }

  export type PendingFriendRequestsWhereUniqueInput = Prisma.AtLeast<{
    sender_id_receiver_id?: PendingFriendRequestsSender_idReceiver_idCompoundUniqueInput
    AND?: PendingFriendRequestsWhereInput | PendingFriendRequestsWhereInput[]
    OR?: PendingFriendRequestsWhereInput[]
    NOT?: PendingFriendRequestsWhereInput | PendingFriendRequestsWhereInput[]
    sender_id?: IntFilter<"PendingFriendRequests"> | number
    receiver_id?: IntFilter<"PendingFriendRequests"> | number
    Sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Receiver?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "sender_id_receiver_id" | "sender_id_receiver_id">

  export type PendingFriendRequestsOrderByWithAggregationInput = {
    sender_id?: SortOrder
    receiver_id?: SortOrder
    _count?: PendingFriendRequestsCountOrderByAggregateInput
    _avg?: PendingFriendRequestsAvgOrderByAggregateInput
    _max?: PendingFriendRequestsMaxOrderByAggregateInput
    _min?: PendingFriendRequestsMinOrderByAggregateInput
    _sum?: PendingFriendRequestsSumOrderByAggregateInput
  }

  export type PendingFriendRequestsScalarWhereWithAggregatesInput = {
    AND?: PendingFriendRequestsScalarWhereWithAggregatesInput | PendingFriendRequestsScalarWhereWithAggregatesInput[]
    OR?: PendingFriendRequestsScalarWhereWithAggregatesInput[]
    NOT?: PendingFriendRequestsScalarWhereWithAggregatesInput | PendingFriendRequestsScalarWhereWithAggregatesInput[]
    sender_id?: IntWithAggregatesFilter<"PendingFriendRequests"> | number
    receiver_id?: IntWithAggregatesFilter<"PendingFriendRequests"> | number
  }

  export type GroupChatsWhereInput = {
    AND?: GroupChatsWhereInput | GroupChatsWhereInput[]
    OR?: GroupChatsWhereInput[]
    NOT?: GroupChatsWhereInput | GroupChatsWhereInput[]
    id?: IntFilter<"GroupChats"> | number
    admin_id?: IntFilter<"GroupChats"> | number
    name?: StringNullableFilter<"GroupChats"> | string | null
    description?: StringNullableFilter<"GroupChats"> | string | null
    avatar?: StringNullableFilter<"GroupChats"> | string | null
    Admin?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    GroupMembers?: GroupMembersListRelationFilter
    GroupMessages?: GroupMessagesListRelationFilter
  }

  export type GroupChatsOrderByWithRelationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    Admin?: UsersOrderByWithRelationInput
    GroupMembers?: GroupMembersOrderByRelationAggregateInput
    GroupMessages?: GroupMessagesOrderByRelationAggregateInput
  }

  export type GroupChatsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GroupChatsWhereInput | GroupChatsWhereInput[]
    OR?: GroupChatsWhereInput[]
    NOT?: GroupChatsWhereInput | GroupChatsWhereInput[]
    admin_id?: IntFilter<"GroupChats"> | number
    name?: StringNullableFilter<"GroupChats"> | string | null
    description?: StringNullableFilter<"GroupChats"> | string | null
    avatar?: StringNullableFilter<"GroupChats"> | string | null
    Admin?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    GroupMembers?: GroupMembersListRelationFilter
    GroupMessages?: GroupMessagesListRelationFilter
  }, "id">

  export type GroupChatsOrderByWithAggregationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    _count?: GroupChatsCountOrderByAggregateInput
    _avg?: GroupChatsAvgOrderByAggregateInput
    _max?: GroupChatsMaxOrderByAggregateInput
    _min?: GroupChatsMinOrderByAggregateInput
    _sum?: GroupChatsSumOrderByAggregateInput
  }

  export type GroupChatsScalarWhereWithAggregatesInput = {
    AND?: GroupChatsScalarWhereWithAggregatesInput | GroupChatsScalarWhereWithAggregatesInput[]
    OR?: GroupChatsScalarWhereWithAggregatesInput[]
    NOT?: GroupChatsScalarWhereWithAggregatesInput | GroupChatsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GroupChats"> | number
    admin_id?: IntWithAggregatesFilter<"GroupChats"> | number
    name?: StringNullableWithAggregatesFilter<"GroupChats"> | string | null
    description?: StringNullableWithAggregatesFilter<"GroupChats"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"GroupChats"> | string | null
  }

  export type BlocksWhereInput = {
    AND?: BlocksWhereInput | BlocksWhereInput[]
    OR?: BlocksWhereInput[]
    NOT?: BlocksWhereInput | BlocksWhereInput[]
    blocked?: IntFilter<"Blocks"> | number
    blocker?: IntFilter<"Blocks"> | number
    friends?: BoolNullableFilter<"Blocks"> | boolean | null
    BlockedUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    BlockingUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type BlocksOrderByWithRelationInput = {
    blocked?: SortOrder
    blocker?: SortOrder
    friends?: SortOrderInput | SortOrder
    BlockedUser?: UsersOrderByWithRelationInput
    BlockingUser?: UsersOrderByWithRelationInput
  }

  export type BlocksWhereUniqueInput = Prisma.AtLeast<{
    blocked_blocker?: BlocksBlockedBlockerCompoundUniqueInput
    AND?: BlocksWhereInput | BlocksWhereInput[]
    OR?: BlocksWhereInput[]
    NOT?: BlocksWhereInput | BlocksWhereInput[]
    blocked?: IntFilter<"Blocks"> | number
    blocker?: IntFilter<"Blocks"> | number
    friends?: BoolNullableFilter<"Blocks"> | boolean | null
    BlockedUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    BlockingUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "blocked_blocker">

  export type BlocksOrderByWithAggregationInput = {
    blocked?: SortOrder
    blocker?: SortOrder
    friends?: SortOrderInput | SortOrder
    _count?: BlocksCountOrderByAggregateInput
    _avg?: BlocksAvgOrderByAggregateInput
    _max?: BlocksMaxOrderByAggregateInput
    _min?: BlocksMinOrderByAggregateInput
    _sum?: BlocksSumOrderByAggregateInput
  }

  export type BlocksScalarWhereWithAggregatesInput = {
    AND?: BlocksScalarWhereWithAggregatesInput | BlocksScalarWhereWithAggregatesInput[]
    OR?: BlocksScalarWhereWithAggregatesInput[]
    NOT?: BlocksScalarWhereWithAggregatesInput | BlocksScalarWhereWithAggregatesInput[]
    blocked?: IntWithAggregatesFilter<"Blocks"> | number
    blocker?: IntWithAggregatesFilter<"Blocks"> | number
    friends?: BoolNullableWithAggregatesFilter<"Blocks"> | boolean | null
  }

  export type GroupMembersWhereInput = {
    AND?: GroupMembersWhereInput | GroupMembersWhereInput[]
    OR?: GroupMembersWhereInput[]
    NOT?: GroupMembersWhereInput | GroupMembersWhereInput[]
    group_id?: IntFilter<"GroupMembers"> | number
    member_id?: IntFilter<"GroupMembers"> | number
    Member?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Group?: XOR<GroupChatsScalarRelationFilter, GroupChatsWhereInput>
  }

  export type GroupMembersOrderByWithRelationInput = {
    group_id?: SortOrder
    member_id?: SortOrder
    Member?: UsersOrderByWithRelationInput
    Group?: GroupChatsOrderByWithRelationInput
  }

  export type GroupMembersWhereUniqueInput = Prisma.AtLeast<{
    member_id_group_id?: GroupMembersMember_idGroup_idCompoundUniqueInput
    group_id_member_id?: GroupMembersGroup_idMember_idCompoundUniqueInput
    AND?: GroupMembersWhereInput | GroupMembersWhereInput[]
    OR?: GroupMembersWhereInput[]
    NOT?: GroupMembersWhereInput | GroupMembersWhereInput[]
    group_id?: IntFilter<"GroupMembers"> | number
    member_id?: IntFilter<"GroupMembers"> | number
    Member?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Group?: XOR<GroupChatsScalarRelationFilter, GroupChatsWhereInput>
  }, "group_id_member_id" | "member_id_group_id">

  export type GroupMembersOrderByWithAggregationInput = {
    group_id?: SortOrder
    member_id?: SortOrder
    _count?: GroupMembersCountOrderByAggregateInput
    _avg?: GroupMembersAvgOrderByAggregateInput
    _max?: GroupMembersMaxOrderByAggregateInput
    _min?: GroupMembersMinOrderByAggregateInput
    _sum?: GroupMembersSumOrderByAggregateInput
  }

  export type GroupMembersScalarWhereWithAggregatesInput = {
    AND?: GroupMembersScalarWhereWithAggregatesInput | GroupMembersScalarWhereWithAggregatesInput[]
    OR?: GroupMembersScalarWhereWithAggregatesInput[]
    NOT?: GroupMembersScalarWhereWithAggregatesInput | GroupMembersScalarWhereWithAggregatesInput[]
    group_id?: IntWithAggregatesFilter<"GroupMembers"> | number
    member_id?: IntWithAggregatesFilter<"GroupMembers"> | number
  }

  export type UsersCreateInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsCreateNestedManyWithoutReceiverInput
    Friends?: FriendsCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutSenderInput
    blocking?: BlocksCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput
    Friends?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsUncheckedCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutSenderInput
    blocking?: BlocksUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksUncheckedCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUncheckedUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersCreateManyInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
  }

  export type UsersUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrivateMessagesCreateInput = {
    content: string
    created_at?: Date | string
    sender: UsersCreateNestedOneWithoutMessagesSentInput
    receiver: UsersCreateNestedOneWithoutMessagesReceivedInput
    attachments?: PrivateMessagesAttachmentCreateNestedManyWithoutPrivateMessageInput
  }

  export type PrivateMessagesUncheckedCreateInput = {
    id?: number
    sender_id: number
    receiver_id: number
    content: string
    created_at?: Date | string
    attachments?: PrivateMessagesAttachmentUncheckedCreateNestedManyWithoutPrivateMessageInput
  }

  export type PrivateMessagesUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UsersUpdateOneRequiredWithoutMessagesSentNestedInput
    receiver?: UsersUpdateOneRequiredWithoutMessagesReceivedNestedInput
    attachments?: PrivateMessagesAttachmentUpdateManyWithoutPrivateMessageNestedInput
  }

  export type PrivateMessagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: PrivateMessagesAttachmentUncheckedUpdateManyWithoutPrivateMessageNestedInput
  }

  export type PrivateMessagesCreateManyInput = {
    id?: number
    sender_id: number
    receiver_id: number
    content: string
    created_at?: Date | string
  }

  export type PrivateMessagesUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessagesAttachmentCreateInput = {
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
    privateMessage: PrivateMessagesCreateNestedOneWithoutAttachmentsInput
  }

  export type PrivateMessagesAttachmentUncheckedCreateInput = {
    id?: number
    message_id: number
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
  }

  export type PrivateMessagesAttachmentUpdateInput = {
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    privateMessage?: PrivateMessagesUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type PrivateMessagesAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message_id?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessagesAttachmentCreateManyInput = {
    id?: number
    message_id: number
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
  }

  export type PrivateMessagesAttachmentUpdateManyMutationInput = {
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessagesAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message_id?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessagesCreateInput = {
    content: string
    created_at?: Date | string
    group: GroupChatsCreateNestedOneWithoutGroupMessagesInput
    sender: UsersCreateNestedOneWithoutGroupMessagesInput
    attachments?: GroupMessagesAttachmentCreateNestedManyWithoutGroupMessageInput
  }

  export type GroupMessagesUncheckedCreateInput = {
    id?: number
    sender_id: number
    group_id: number
    content: string
    created_at?: Date | string
    attachments?: GroupMessagesAttachmentUncheckedCreateNestedManyWithoutGroupMessageInput
  }

  export type GroupMessagesUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupChatsUpdateOneRequiredWithoutGroupMessagesNestedInput
    sender?: UsersUpdateOneRequiredWithoutGroupMessagesNestedInput
    attachments?: GroupMessagesAttachmentUpdateManyWithoutGroupMessageNestedInput
  }

  export type GroupMessagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: GroupMessagesAttachmentUncheckedUpdateManyWithoutGroupMessageNestedInput
  }

  export type GroupMessagesCreateManyInput = {
    id?: number
    sender_id: number
    group_id: number
    content: string
    created_at?: Date | string
  }

  export type GroupMessagesUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessagesAttachmentCreateInput = {
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
    groupMessage: GroupMessagesCreateNestedOneWithoutAttachmentsInput
  }

  export type GroupMessagesAttachmentUncheckedCreateInput = {
    id?: number
    message_id: number
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
  }

  export type GroupMessagesAttachmentUpdateInput = {
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMessage?: GroupMessagesUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type GroupMessagesAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message_id?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessagesAttachmentCreateManyInput = {
    id?: number
    message_id: number
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
  }

  export type GroupMessagesAttachmentUpdateManyMutationInput = {
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessagesAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message_id?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendsCreateInput = {
    User: UsersCreateNestedOneWithoutFriendsInput
    Friend: UsersCreateNestedOneWithoutFriendsInput
  }

  export type FriendsUncheckedCreateInput = {
    user_id: number
    friend_id: number
  }

  export type FriendsUpdateInput = {
    User?: UsersUpdateOneRequiredWithoutFriendsNestedInput
    Friend?: UsersUpdateOneRequiredWithoutFriendsNestedInput
  }

  export type FriendsUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    friend_id?: IntFieldUpdateOperationsInput | number
  }

  export type FriendsCreateManyInput = {
    user_id: number
    friend_id: number
  }

  export type FriendsUpdateManyMutationInput = {

  }

  export type FriendsUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    friend_id?: IntFieldUpdateOperationsInput | number
  }

  export type PendingFriendRequestsCreateInput = {
    Sender: UsersCreateNestedOneWithoutPendingRequestsSentInput
    Receiver: UsersCreateNestedOneWithoutPendingRequestsReceivedInput
  }

  export type PendingFriendRequestsUncheckedCreateInput = {
    sender_id: number
    receiver_id: number
  }

  export type PendingFriendRequestsUpdateInput = {
    Sender?: UsersUpdateOneRequiredWithoutPendingRequestsSentNestedInput
    Receiver?: UsersUpdateOneRequiredWithoutPendingRequestsReceivedNestedInput
  }

  export type PendingFriendRequestsUncheckedUpdateInput = {
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
  }

  export type PendingFriendRequestsCreateManyInput = {
    sender_id: number
    receiver_id: number
  }

  export type PendingFriendRequestsUpdateManyMutationInput = {

  }

  export type PendingFriendRequestsUncheckedUpdateManyInput = {
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
  }

  export type GroupChatsCreateInput = {
    name?: string | null
    description?: string | null
    avatar?: string | null
    Admin: UsersCreateNestedOneWithoutGroupChatsInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutGroupInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutGroupInput
  }

  export type GroupChatsUncheckedCreateInput = {
    id?: number
    admin_id: number
    name?: string | null
    description?: string | null
    avatar?: string | null
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutGroupInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupChatsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    Admin?: UsersUpdateOneRequiredWithoutGroupChatsNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutGroupNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutGroupNestedInput
  }

  export type GroupChatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutGroupNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupChatsCreateManyInput = {
    id?: number
    admin_id: number
    name?: string | null
    description?: string | null
    avatar?: string | null
  }

  export type GroupChatsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupChatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlocksCreateInput = {
    friends?: boolean | null
    BlockedUser: UsersCreateNestedOneWithoutBlockedByInput
    BlockingUser: UsersCreateNestedOneWithoutBlockingInput
  }

  export type BlocksUncheckedCreateInput = {
    blocked: number
    blocker: number
    friends?: boolean | null
  }

  export type BlocksUpdateInput = {
    friends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    BlockedUser?: UsersUpdateOneRequiredWithoutBlockedByNestedInput
    BlockingUser?: UsersUpdateOneRequiredWithoutBlockingNestedInput
  }

  export type BlocksUncheckedUpdateInput = {
    blocked?: IntFieldUpdateOperationsInput | number
    blocker?: IntFieldUpdateOperationsInput | number
    friends?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BlocksCreateManyInput = {
    blocked: number
    blocker: number
    friends?: boolean | null
  }

  export type BlocksUpdateManyMutationInput = {
    friends?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BlocksUncheckedUpdateManyInput = {
    blocked?: IntFieldUpdateOperationsInput | number
    blocker?: IntFieldUpdateOperationsInput | number
    friends?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type GroupMembersCreateInput = {
    Member: UsersCreateNestedOneWithoutGroupMembersInput
    Group: GroupChatsCreateNestedOneWithoutGroupMembersInput
  }

  export type GroupMembersUncheckedCreateInput = {
    group_id: number
    member_id: number
  }

  export type GroupMembersUpdateInput = {
    Member?: UsersUpdateOneRequiredWithoutGroupMembersNestedInput
    Group?: GroupChatsUpdateOneRequiredWithoutGroupMembersNestedInput
  }

  export type GroupMembersUncheckedUpdateInput = {
    group_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
  }

  export type GroupMembersCreateManyInput = {
    group_id: number
    member_id: number
  }

  export type GroupMembersUpdateManyMutationInput = {

  }

  export type GroupMembersUncheckedUpdateManyInput = {
    group_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type PrivateMessagesListRelationFilter = {
    every?: PrivateMessagesWhereInput
    some?: PrivateMessagesWhereInput
    none?: PrivateMessagesWhereInput
  }

  export type FriendsListRelationFilter = {
    every?: FriendsWhereInput
    some?: FriendsWhereInput
    none?: FriendsWhereInput
  }

  export type PendingFriendRequestsListRelationFilter = {
    every?: PendingFriendRequestsWhereInput
    some?: PendingFriendRequestsWhereInput
    none?: PendingFriendRequestsWhereInput
  }

  export type GroupChatsListRelationFilter = {
    every?: GroupChatsWhereInput
    some?: GroupChatsWhereInput
    none?: GroupChatsWhereInput
  }

  export type GroupMembersListRelationFilter = {
    every?: GroupMembersWhereInput
    some?: GroupMembersWhereInput
    none?: GroupMembersWhereInput
  }

  export type GroupMessagesListRelationFilter = {
    every?: GroupMessagesWhereInput
    some?: GroupMessagesWhereInput
    none?: GroupMessagesWhereInput
  }

  export type BlocksListRelationFilter = {
    every?: BlocksWhereInput
    some?: BlocksWhereInput
    none?: BlocksWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PrivateMessagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingFriendRequestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupChatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMembersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMessagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlocksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type PrivateMessagesAttachmentListRelationFilter = {
    every?: PrivateMessagesAttachmentWhereInput
    some?: PrivateMessagesAttachmentWhereInput
    none?: PrivateMessagesAttachmentWhereInput
  }

  export type PrivateMessagesAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrivateMessagesCountOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type PrivateMessagesAvgOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type PrivateMessagesMaxOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type PrivateMessagesMinOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type PrivateMessagesSumOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PrivateMessagesScalarRelationFilter = {
    is?: PrivateMessagesWhereInput
    isNot?: PrivateMessagesWhereInput
  }

  export type PrivateMessagesAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
    path?: SortOrder
    originalName?: SortOrder
    uniqueFileName?: SortOrder
    created_at?: SortOrder
  }

  export type PrivateMessagesAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
  }

  export type PrivateMessagesAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
    path?: SortOrder
    originalName?: SortOrder
    uniqueFileName?: SortOrder
    created_at?: SortOrder
  }

  export type PrivateMessagesAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
    path?: SortOrder
    originalName?: SortOrder
    uniqueFileName?: SortOrder
    created_at?: SortOrder
  }

  export type PrivateMessagesAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
  }

  export type GroupChatsScalarRelationFilter = {
    is?: GroupChatsWhereInput
    isNot?: GroupChatsWhereInput
  }

  export type GroupMessagesAttachmentListRelationFilter = {
    every?: GroupMessagesAttachmentWhereInput
    some?: GroupMessagesAttachmentWhereInput
    none?: GroupMessagesAttachmentWhereInput
  }

  export type GroupMessagesAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMessagesCountOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    group_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type GroupMessagesAvgOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    group_id?: SortOrder
  }

  export type GroupMessagesMaxOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    group_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type GroupMessagesMinOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    group_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type GroupMessagesSumOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    group_id?: SortOrder
  }

  export type GroupMessagesScalarRelationFilter = {
    is?: GroupMessagesWhereInput
    isNot?: GroupMessagesWhereInput
  }

  export type GroupMessagesAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
    path?: SortOrder
    originalName?: SortOrder
    uniqueFileName?: SortOrder
    created_at?: SortOrder
  }

  export type GroupMessagesAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
  }

  export type GroupMessagesAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
    path?: SortOrder
    originalName?: SortOrder
    uniqueFileName?: SortOrder
    created_at?: SortOrder
  }

  export type GroupMessagesAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
    path?: SortOrder
    originalName?: SortOrder
    uniqueFileName?: SortOrder
    created_at?: SortOrder
  }

  export type GroupMessagesAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    size?: SortOrder
  }

  export type FriendsFriend_idUser_idCompoundUniqueInput = {
    friend_id: number
    user_id: number
  }

  export type FriendsUser_idFriend_idCompoundUniqueInput = {
    user_id: number
    friend_id: number
  }

  export type FriendsCountOrderByAggregateInput = {
    user_id?: SortOrder
    friend_id?: SortOrder
  }

  export type FriendsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    friend_id?: SortOrder
  }

  export type FriendsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    friend_id?: SortOrder
  }

  export type FriendsMinOrderByAggregateInput = {
    user_id?: SortOrder
    friend_id?: SortOrder
  }

  export type FriendsSumOrderByAggregateInput = {
    user_id?: SortOrder
    friend_id?: SortOrder
  }

  export type PendingFriendRequestsSender_idReceiver_idCompoundUniqueInput = {
    sender_id: number
    receiver_id: number
  }

  export type PendingFriendRequestsCountOrderByAggregateInput = {
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type PendingFriendRequestsAvgOrderByAggregateInput = {
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type PendingFriendRequestsMaxOrderByAggregateInput = {
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type PendingFriendRequestsMinOrderByAggregateInput = {
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type PendingFriendRequestsSumOrderByAggregateInput = {
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type GroupChatsCountOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatar?: SortOrder
  }

  export type GroupChatsAvgOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
  }

  export type GroupChatsMaxOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatar?: SortOrder
  }

  export type GroupChatsMinOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatar?: SortOrder
  }

  export type GroupChatsSumOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BlocksBlockedBlockerCompoundUniqueInput = {
    blocked: number
    blocker: number
  }

  export type BlocksCountOrderByAggregateInput = {
    blocked?: SortOrder
    blocker?: SortOrder
    friends?: SortOrder
  }

  export type BlocksAvgOrderByAggregateInput = {
    blocked?: SortOrder
    blocker?: SortOrder
  }

  export type BlocksMaxOrderByAggregateInput = {
    blocked?: SortOrder
    blocker?: SortOrder
    friends?: SortOrder
  }

  export type BlocksMinOrderByAggregateInput = {
    blocked?: SortOrder
    blocker?: SortOrder
    friends?: SortOrder
  }

  export type BlocksSumOrderByAggregateInput = {
    blocked?: SortOrder
    blocker?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type GroupMembersMember_idGroup_idCompoundUniqueInput = {
    member_id: number
    group_id: number
  }

  export type GroupMembersGroup_idMember_idCompoundUniqueInput = {
    group_id: number
    member_id: number
  }

  export type GroupMembersCountOrderByAggregateInput = {
    group_id?: SortOrder
    member_id?: SortOrder
  }

  export type GroupMembersAvgOrderByAggregateInput = {
    group_id?: SortOrder
    member_id?: SortOrder
  }

  export type GroupMembersMaxOrderByAggregateInput = {
    group_id?: SortOrder
    member_id?: SortOrder
  }

  export type GroupMembersMinOrderByAggregateInput = {
    group_id?: SortOrder
    member_id?: SortOrder
  }

  export type GroupMembersSumOrderByAggregateInput = {
    group_id?: SortOrder
    member_id?: SortOrder
  }

  export type PrivateMessagesCreateNestedManyWithoutSenderInput = {
    create?: XOR<PrivateMessagesCreateWithoutSenderInput, PrivateMessagesUncheckedCreateWithoutSenderInput> | PrivateMessagesCreateWithoutSenderInput[] | PrivateMessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PrivateMessagesCreateOrConnectWithoutSenderInput | PrivateMessagesCreateOrConnectWithoutSenderInput[]
    createMany?: PrivateMessagesCreateManySenderInputEnvelope
    connect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
  }

  export type PrivateMessagesCreateNestedManyWithoutReceiverInput = {
    create?: XOR<PrivateMessagesCreateWithoutReceiverInput, PrivateMessagesUncheckedCreateWithoutReceiverInput> | PrivateMessagesCreateWithoutReceiverInput[] | PrivateMessagesUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PrivateMessagesCreateOrConnectWithoutReceiverInput | PrivateMessagesCreateOrConnectWithoutReceiverInput[]
    createMany?: PrivateMessagesCreateManyReceiverInputEnvelope
    connect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
  }

  export type FriendsCreateNestedManyWithoutUserInput = {
    create?: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput> | FriendsCreateWithoutUserInput[] | FriendsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUserInput | FriendsCreateOrConnectWithoutUserInput[]
    createMany?: FriendsCreateManyUserInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type PendingFriendRequestsCreateNestedManyWithoutSenderInput = {
    create?: XOR<PendingFriendRequestsCreateWithoutSenderInput, PendingFriendRequestsUncheckedCreateWithoutSenderInput> | PendingFriendRequestsCreateWithoutSenderInput[] | PendingFriendRequestsUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PendingFriendRequestsCreateOrConnectWithoutSenderInput | PendingFriendRequestsCreateOrConnectWithoutSenderInput[]
    createMany?: PendingFriendRequestsCreateManySenderInputEnvelope
    connect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
  }

  export type PendingFriendRequestsCreateNestedManyWithoutReceiverInput = {
    create?: XOR<PendingFriendRequestsCreateWithoutReceiverInput, PendingFriendRequestsUncheckedCreateWithoutReceiverInput> | PendingFriendRequestsCreateWithoutReceiverInput[] | PendingFriendRequestsUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PendingFriendRequestsCreateOrConnectWithoutReceiverInput | PendingFriendRequestsCreateOrConnectWithoutReceiverInput[]
    createMany?: PendingFriendRequestsCreateManyReceiverInputEnvelope
    connect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
  }

  export type FriendsCreateNestedManyWithoutFriendInput = {
    create?: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput> | FriendsCreateWithoutFriendInput[] | FriendsUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutFriendInput | FriendsCreateOrConnectWithoutFriendInput[]
    createMany?: FriendsCreateManyFriendInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type GroupChatsCreateNestedManyWithoutAdminInput = {
    create?: XOR<GroupChatsCreateWithoutAdminInput, GroupChatsUncheckedCreateWithoutAdminInput> | GroupChatsCreateWithoutAdminInput[] | GroupChatsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: GroupChatsCreateOrConnectWithoutAdminInput | GroupChatsCreateOrConnectWithoutAdminInput[]
    createMany?: GroupChatsCreateManyAdminInputEnvelope
    connect?: GroupChatsWhereUniqueInput | GroupChatsWhereUniqueInput[]
  }

  export type GroupMembersCreateNestedManyWithoutMemberInput = {
    create?: XOR<GroupMembersCreateWithoutMemberInput, GroupMembersUncheckedCreateWithoutMemberInput> | GroupMembersCreateWithoutMemberInput[] | GroupMembersUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: GroupMembersCreateOrConnectWithoutMemberInput | GroupMembersCreateOrConnectWithoutMemberInput[]
    createMany?: GroupMembersCreateManyMemberInputEnvelope
    connect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
  }

  export type GroupMessagesCreateNestedManyWithoutSenderInput = {
    create?: XOR<GroupMessagesCreateWithoutSenderInput, GroupMessagesUncheckedCreateWithoutSenderInput> | GroupMessagesCreateWithoutSenderInput[] | GroupMessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: GroupMessagesCreateOrConnectWithoutSenderInput | GroupMessagesCreateOrConnectWithoutSenderInput[]
    createMany?: GroupMessagesCreateManySenderInputEnvelope
    connect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
  }

  export type BlocksCreateNestedManyWithoutBlockingUserInput = {
    create?: XOR<BlocksCreateWithoutBlockingUserInput, BlocksUncheckedCreateWithoutBlockingUserInput> | BlocksCreateWithoutBlockingUserInput[] | BlocksUncheckedCreateWithoutBlockingUserInput[]
    connectOrCreate?: BlocksCreateOrConnectWithoutBlockingUserInput | BlocksCreateOrConnectWithoutBlockingUserInput[]
    createMany?: BlocksCreateManyBlockingUserInputEnvelope
    connect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
  }

  export type BlocksCreateNestedManyWithoutBlockedUserInput = {
    create?: XOR<BlocksCreateWithoutBlockedUserInput, BlocksUncheckedCreateWithoutBlockedUserInput> | BlocksCreateWithoutBlockedUserInput[] | BlocksUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlocksCreateOrConnectWithoutBlockedUserInput | BlocksCreateOrConnectWithoutBlockedUserInput[]
    createMany?: BlocksCreateManyBlockedUserInputEnvelope
    connect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
  }

  export type PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<PrivateMessagesCreateWithoutSenderInput, PrivateMessagesUncheckedCreateWithoutSenderInput> | PrivateMessagesCreateWithoutSenderInput[] | PrivateMessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PrivateMessagesCreateOrConnectWithoutSenderInput | PrivateMessagesCreateOrConnectWithoutSenderInput[]
    createMany?: PrivateMessagesCreateManySenderInputEnvelope
    connect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
  }

  export type PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<PrivateMessagesCreateWithoutReceiverInput, PrivateMessagesUncheckedCreateWithoutReceiverInput> | PrivateMessagesCreateWithoutReceiverInput[] | PrivateMessagesUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PrivateMessagesCreateOrConnectWithoutReceiverInput | PrivateMessagesCreateOrConnectWithoutReceiverInput[]
    createMany?: PrivateMessagesCreateManyReceiverInputEnvelope
    connect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
  }

  export type FriendsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput> | FriendsCreateWithoutUserInput[] | FriendsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUserInput | FriendsCreateOrConnectWithoutUserInput[]
    createMany?: FriendsCreateManyUserInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<PendingFriendRequestsCreateWithoutSenderInput, PendingFriendRequestsUncheckedCreateWithoutSenderInput> | PendingFriendRequestsCreateWithoutSenderInput[] | PendingFriendRequestsUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PendingFriendRequestsCreateOrConnectWithoutSenderInput | PendingFriendRequestsCreateOrConnectWithoutSenderInput[]
    createMany?: PendingFriendRequestsCreateManySenderInputEnvelope
    connect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
  }

  export type PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<PendingFriendRequestsCreateWithoutReceiverInput, PendingFriendRequestsUncheckedCreateWithoutReceiverInput> | PendingFriendRequestsCreateWithoutReceiverInput[] | PendingFriendRequestsUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PendingFriendRequestsCreateOrConnectWithoutReceiverInput | PendingFriendRequestsCreateOrConnectWithoutReceiverInput[]
    createMany?: PendingFriendRequestsCreateManyReceiverInputEnvelope
    connect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
  }

  export type FriendsUncheckedCreateNestedManyWithoutFriendInput = {
    create?: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput> | FriendsCreateWithoutFriendInput[] | FriendsUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutFriendInput | FriendsCreateOrConnectWithoutFriendInput[]
    createMany?: FriendsCreateManyFriendInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type GroupChatsUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<GroupChatsCreateWithoutAdminInput, GroupChatsUncheckedCreateWithoutAdminInput> | GroupChatsCreateWithoutAdminInput[] | GroupChatsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: GroupChatsCreateOrConnectWithoutAdminInput | GroupChatsCreateOrConnectWithoutAdminInput[]
    createMany?: GroupChatsCreateManyAdminInputEnvelope
    connect?: GroupChatsWhereUniqueInput | GroupChatsWhereUniqueInput[]
  }

  export type GroupMembersUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<GroupMembersCreateWithoutMemberInput, GroupMembersUncheckedCreateWithoutMemberInput> | GroupMembersCreateWithoutMemberInput[] | GroupMembersUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: GroupMembersCreateOrConnectWithoutMemberInput | GroupMembersCreateOrConnectWithoutMemberInput[]
    createMany?: GroupMembersCreateManyMemberInputEnvelope
    connect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
  }

  export type GroupMessagesUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<GroupMessagesCreateWithoutSenderInput, GroupMessagesUncheckedCreateWithoutSenderInput> | GroupMessagesCreateWithoutSenderInput[] | GroupMessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: GroupMessagesCreateOrConnectWithoutSenderInput | GroupMessagesCreateOrConnectWithoutSenderInput[]
    createMany?: GroupMessagesCreateManySenderInputEnvelope
    connect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
  }

  export type BlocksUncheckedCreateNestedManyWithoutBlockingUserInput = {
    create?: XOR<BlocksCreateWithoutBlockingUserInput, BlocksUncheckedCreateWithoutBlockingUserInput> | BlocksCreateWithoutBlockingUserInput[] | BlocksUncheckedCreateWithoutBlockingUserInput[]
    connectOrCreate?: BlocksCreateOrConnectWithoutBlockingUserInput | BlocksCreateOrConnectWithoutBlockingUserInput[]
    createMany?: BlocksCreateManyBlockingUserInputEnvelope
    connect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
  }

  export type BlocksUncheckedCreateNestedManyWithoutBlockedUserInput = {
    create?: XOR<BlocksCreateWithoutBlockedUserInput, BlocksUncheckedCreateWithoutBlockedUserInput> | BlocksCreateWithoutBlockedUserInput[] | BlocksUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlocksCreateOrConnectWithoutBlockedUserInput | BlocksCreateOrConnectWithoutBlockedUserInput[]
    createMany?: BlocksCreateManyBlockedUserInputEnvelope
    connect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PrivateMessagesUpdateManyWithoutSenderNestedInput = {
    create?: XOR<PrivateMessagesCreateWithoutSenderInput, PrivateMessagesUncheckedCreateWithoutSenderInput> | PrivateMessagesCreateWithoutSenderInput[] | PrivateMessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PrivateMessagesCreateOrConnectWithoutSenderInput | PrivateMessagesCreateOrConnectWithoutSenderInput[]
    upsert?: PrivateMessagesUpsertWithWhereUniqueWithoutSenderInput | PrivateMessagesUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: PrivateMessagesCreateManySenderInputEnvelope
    set?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    disconnect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    delete?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    connect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    update?: PrivateMessagesUpdateWithWhereUniqueWithoutSenderInput | PrivateMessagesUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: PrivateMessagesUpdateManyWithWhereWithoutSenderInput | PrivateMessagesUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: PrivateMessagesScalarWhereInput | PrivateMessagesScalarWhereInput[]
  }

  export type PrivateMessagesUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<PrivateMessagesCreateWithoutReceiverInput, PrivateMessagesUncheckedCreateWithoutReceiverInput> | PrivateMessagesCreateWithoutReceiverInput[] | PrivateMessagesUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PrivateMessagesCreateOrConnectWithoutReceiverInput | PrivateMessagesCreateOrConnectWithoutReceiverInput[]
    upsert?: PrivateMessagesUpsertWithWhereUniqueWithoutReceiverInput | PrivateMessagesUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: PrivateMessagesCreateManyReceiverInputEnvelope
    set?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    disconnect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    delete?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    connect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    update?: PrivateMessagesUpdateWithWhereUniqueWithoutReceiverInput | PrivateMessagesUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: PrivateMessagesUpdateManyWithWhereWithoutReceiverInput | PrivateMessagesUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: PrivateMessagesScalarWhereInput | PrivateMessagesScalarWhereInput[]
  }

  export type FriendsUpdateManyWithoutUserNestedInput = {
    create?: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput> | FriendsCreateWithoutUserInput[] | FriendsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUserInput | FriendsCreateOrConnectWithoutUserInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutUserInput | FriendsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FriendsCreateManyUserInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutUserInput | FriendsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutUserInput | FriendsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type PendingFriendRequestsUpdateManyWithoutSenderNestedInput = {
    create?: XOR<PendingFriendRequestsCreateWithoutSenderInput, PendingFriendRequestsUncheckedCreateWithoutSenderInput> | PendingFriendRequestsCreateWithoutSenderInput[] | PendingFriendRequestsUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PendingFriendRequestsCreateOrConnectWithoutSenderInput | PendingFriendRequestsCreateOrConnectWithoutSenderInput[]
    upsert?: PendingFriendRequestsUpsertWithWhereUniqueWithoutSenderInput | PendingFriendRequestsUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: PendingFriendRequestsCreateManySenderInputEnvelope
    set?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    disconnect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    delete?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    connect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    update?: PendingFriendRequestsUpdateWithWhereUniqueWithoutSenderInput | PendingFriendRequestsUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: PendingFriendRequestsUpdateManyWithWhereWithoutSenderInput | PendingFriendRequestsUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: PendingFriendRequestsScalarWhereInput | PendingFriendRequestsScalarWhereInput[]
  }

  export type PendingFriendRequestsUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<PendingFriendRequestsCreateWithoutReceiverInput, PendingFriendRequestsUncheckedCreateWithoutReceiverInput> | PendingFriendRequestsCreateWithoutReceiverInput[] | PendingFriendRequestsUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PendingFriendRequestsCreateOrConnectWithoutReceiverInput | PendingFriendRequestsCreateOrConnectWithoutReceiverInput[]
    upsert?: PendingFriendRequestsUpsertWithWhereUniqueWithoutReceiverInput | PendingFriendRequestsUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: PendingFriendRequestsCreateManyReceiverInputEnvelope
    set?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    disconnect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    delete?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    connect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    update?: PendingFriendRequestsUpdateWithWhereUniqueWithoutReceiverInput | PendingFriendRequestsUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: PendingFriendRequestsUpdateManyWithWhereWithoutReceiverInput | PendingFriendRequestsUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: PendingFriendRequestsScalarWhereInput | PendingFriendRequestsScalarWhereInput[]
  }

  export type FriendsUpdateManyWithoutFriendNestedInput = {
    create?: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput> | FriendsCreateWithoutFriendInput[] | FriendsUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutFriendInput | FriendsCreateOrConnectWithoutFriendInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutFriendInput | FriendsUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: FriendsCreateManyFriendInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutFriendInput | FriendsUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutFriendInput | FriendsUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type GroupChatsUpdateManyWithoutAdminNestedInput = {
    create?: XOR<GroupChatsCreateWithoutAdminInput, GroupChatsUncheckedCreateWithoutAdminInput> | GroupChatsCreateWithoutAdminInput[] | GroupChatsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: GroupChatsCreateOrConnectWithoutAdminInput | GroupChatsCreateOrConnectWithoutAdminInput[]
    upsert?: GroupChatsUpsertWithWhereUniqueWithoutAdminInput | GroupChatsUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: GroupChatsCreateManyAdminInputEnvelope
    set?: GroupChatsWhereUniqueInput | GroupChatsWhereUniqueInput[]
    disconnect?: GroupChatsWhereUniqueInput | GroupChatsWhereUniqueInput[]
    delete?: GroupChatsWhereUniqueInput | GroupChatsWhereUniqueInput[]
    connect?: GroupChatsWhereUniqueInput | GroupChatsWhereUniqueInput[]
    update?: GroupChatsUpdateWithWhereUniqueWithoutAdminInput | GroupChatsUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: GroupChatsUpdateManyWithWhereWithoutAdminInput | GroupChatsUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: GroupChatsScalarWhereInput | GroupChatsScalarWhereInput[]
  }

  export type GroupMembersUpdateManyWithoutMemberNestedInput = {
    create?: XOR<GroupMembersCreateWithoutMemberInput, GroupMembersUncheckedCreateWithoutMemberInput> | GroupMembersCreateWithoutMemberInput[] | GroupMembersUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: GroupMembersCreateOrConnectWithoutMemberInput | GroupMembersCreateOrConnectWithoutMemberInput[]
    upsert?: GroupMembersUpsertWithWhereUniqueWithoutMemberInput | GroupMembersUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: GroupMembersCreateManyMemberInputEnvelope
    set?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    disconnect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    delete?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    connect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    update?: GroupMembersUpdateWithWhereUniqueWithoutMemberInput | GroupMembersUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: GroupMembersUpdateManyWithWhereWithoutMemberInput | GroupMembersUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: GroupMembersScalarWhereInput | GroupMembersScalarWhereInput[]
  }

  export type GroupMessagesUpdateManyWithoutSenderNestedInput = {
    create?: XOR<GroupMessagesCreateWithoutSenderInput, GroupMessagesUncheckedCreateWithoutSenderInput> | GroupMessagesCreateWithoutSenderInput[] | GroupMessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: GroupMessagesCreateOrConnectWithoutSenderInput | GroupMessagesCreateOrConnectWithoutSenderInput[]
    upsert?: GroupMessagesUpsertWithWhereUniqueWithoutSenderInput | GroupMessagesUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: GroupMessagesCreateManySenderInputEnvelope
    set?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    disconnect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    delete?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    connect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    update?: GroupMessagesUpdateWithWhereUniqueWithoutSenderInput | GroupMessagesUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: GroupMessagesUpdateManyWithWhereWithoutSenderInput | GroupMessagesUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: GroupMessagesScalarWhereInput | GroupMessagesScalarWhereInput[]
  }

  export type BlocksUpdateManyWithoutBlockingUserNestedInput = {
    create?: XOR<BlocksCreateWithoutBlockingUserInput, BlocksUncheckedCreateWithoutBlockingUserInput> | BlocksCreateWithoutBlockingUserInput[] | BlocksUncheckedCreateWithoutBlockingUserInput[]
    connectOrCreate?: BlocksCreateOrConnectWithoutBlockingUserInput | BlocksCreateOrConnectWithoutBlockingUserInput[]
    upsert?: BlocksUpsertWithWhereUniqueWithoutBlockingUserInput | BlocksUpsertWithWhereUniqueWithoutBlockingUserInput[]
    createMany?: BlocksCreateManyBlockingUserInputEnvelope
    set?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    disconnect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    delete?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    connect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    update?: BlocksUpdateWithWhereUniqueWithoutBlockingUserInput | BlocksUpdateWithWhereUniqueWithoutBlockingUserInput[]
    updateMany?: BlocksUpdateManyWithWhereWithoutBlockingUserInput | BlocksUpdateManyWithWhereWithoutBlockingUserInput[]
    deleteMany?: BlocksScalarWhereInput | BlocksScalarWhereInput[]
  }

  export type BlocksUpdateManyWithoutBlockedUserNestedInput = {
    create?: XOR<BlocksCreateWithoutBlockedUserInput, BlocksUncheckedCreateWithoutBlockedUserInput> | BlocksCreateWithoutBlockedUserInput[] | BlocksUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlocksCreateOrConnectWithoutBlockedUserInput | BlocksCreateOrConnectWithoutBlockedUserInput[]
    upsert?: BlocksUpsertWithWhereUniqueWithoutBlockedUserInput | BlocksUpsertWithWhereUniqueWithoutBlockedUserInput[]
    createMany?: BlocksCreateManyBlockedUserInputEnvelope
    set?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    disconnect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    delete?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    connect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    update?: BlocksUpdateWithWhereUniqueWithoutBlockedUserInput | BlocksUpdateWithWhereUniqueWithoutBlockedUserInput[]
    updateMany?: BlocksUpdateManyWithWhereWithoutBlockedUserInput | BlocksUpdateManyWithWhereWithoutBlockedUserInput[]
    deleteMany?: BlocksScalarWhereInput | BlocksScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<PrivateMessagesCreateWithoutSenderInput, PrivateMessagesUncheckedCreateWithoutSenderInput> | PrivateMessagesCreateWithoutSenderInput[] | PrivateMessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PrivateMessagesCreateOrConnectWithoutSenderInput | PrivateMessagesCreateOrConnectWithoutSenderInput[]
    upsert?: PrivateMessagesUpsertWithWhereUniqueWithoutSenderInput | PrivateMessagesUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: PrivateMessagesCreateManySenderInputEnvelope
    set?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    disconnect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    delete?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    connect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    update?: PrivateMessagesUpdateWithWhereUniqueWithoutSenderInput | PrivateMessagesUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: PrivateMessagesUpdateManyWithWhereWithoutSenderInput | PrivateMessagesUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: PrivateMessagesScalarWhereInput | PrivateMessagesScalarWhereInput[]
  }

  export type PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<PrivateMessagesCreateWithoutReceiverInput, PrivateMessagesUncheckedCreateWithoutReceiverInput> | PrivateMessagesCreateWithoutReceiverInput[] | PrivateMessagesUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PrivateMessagesCreateOrConnectWithoutReceiverInput | PrivateMessagesCreateOrConnectWithoutReceiverInput[]
    upsert?: PrivateMessagesUpsertWithWhereUniqueWithoutReceiverInput | PrivateMessagesUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: PrivateMessagesCreateManyReceiverInputEnvelope
    set?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    disconnect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    delete?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    connect?: PrivateMessagesWhereUniqueInput | PrivateMessagesWhereUniqueInput[]
    update?: PrivateMessagesUpdateWithWhereUniqueWithoutReceiverInput | PrivateMessagesUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: PrivateMessagesUpdateManyWithWhereWithoutReceiverInput | PrivateMessagesUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: PrivateMessagesScalarWhereInput | PrivateMessagesScalarWhereInput[]
  }

  export type FriendsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput> | FriendsCreateWithoutUserInput[] | FriendsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUserInput | FriendsCreateOrConnectWithoutUserInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutUserInput | FriendsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FriendsCreateManyUserInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutUserInput | FriendsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutUserInput | FriendsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<PendingFriendRequestsCreateWithoutSenderInput, PendingFriendRequestsUncheckedCreateWithoutSenderInput> | PendingFriendRequestsCreateWithoutSenderInput[] | PendingFriendRequestsUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PendingFriendRequestsCreateOrConnectWithoutSenderInput | PendingFriendRequestsCreateOrConnectWithoutSenderInput[]
    upsert?: PendingFriendRequestsUpsertWithWhereUniqueWithoutSenderInput | PendingFriendRequestsUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: PendingFriendRequestsCreateManySenderInputEnvelope
    set?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    disconnect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    delete?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    connect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    update?: PendingFriendRequestsUpdateWithWhereUniqueWithoutSenderInput | PendingFriendRequestsUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: PendingFriendRequestsUpdateManyWithWhereWithoutSenderInput | PendingFriendRequestsUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: PendingFriendRequestsScalarWhereInput | PendingFriendRequestsScalarWhereInput[]
  }

  export type PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<PendingFriendRequestsCreateWithoutReceiverInput, PendingFriendRequestsUncheckedCreateWithoutReceiverInput> | PendingFriendRequestsCreateWithoutReceiverInput[] | PendingFriendRequestsUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PendingFriendRequestsCreateOrConnectWithoutReceiverInput | PendingFriendRequestsCreateOrConnectWithoutReceiverInput[]
    upsert?: PendingFriendRequestsUpsertWithWhereUniqueWithoutReceiverInput | PendingFriendRequestsUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: PendingFriendRequestsCreateManyReceiverInputEnvelope
    set?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    disconnect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    delete?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    connect?: PendingFriendRequestsWhereUniqueInput | PendingFriendRequestsWhereUniqueInput[]
    update?: PendingFriendRequestsUpdateWithWhereUniqueWithoutReceiverInput | PendingFriendRequestsUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: PendingFriendRequestsUpdateManyWithWhereWithoutReceiverInput | PendingFriendRequestsUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: PendingFriendRequestsScalarWhereInput | PendingFriendRequestsScalarWhereInput[]
  }

  export type FriendsUncheckedUpdateManyWithoutFriendNestedInput = {
    create?: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput> | FriendsCreateWithoutFriendInput[] | FriendsUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutFriendInput | FriendsCreateOrConnectWithoutFriendInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutFriendInput | FriendsUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: FriendsCreateManyFriendInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutFriendInput | FriendsUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutFriendInput | FriendsUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type GroupChatsUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<GroupChatsCreateWithoutAdminInput, GroupChatsUncheckedCreateWithoutAdminInput> | GroupChatsCreateWithoutAdminInput[] | GroupChatsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: GroupChatsCreateOrConnectWithoutAdminInput | GroupChatsCreateOrConnectWithoutAdminInput[]
    upsert?: GroupChatsUpsertWithWhereUniqueWithoutAdminInput | GroupChatsUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: GroupChatsCreateManyAdminInputEnvelope
    set?: GroupChatsWhereUniqueInput | GroupChatsWhereUniqueInput[]
    disconnect?: GroupChatsWhereUniqueInput | GroupChatsWhereUniqueInput[]
    delete?: GroupChatsWhereUniqueInput | GroupChatsWhereUniqueInput[]
    connect?: GroupChatsWhereUniqueInput | GroupChatsWhereUniqueInput[]
    update?: GroupChatsUpdateWithWhereUniqueWithoutAdminInput | GroupChatsUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: GroupChatsUpdateManyWithWhereWithoutAdminInput | GroupChatsUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: GroupChatsScalarWhereInput | GroupChatsScalarWhereInput[]
  }

  export type GroupMembersUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<GroupMembersCreateWithoutMemberInput, GroupMembersUncheckedCreateWithoutMemberInput> | GroupMembersCreateWithoutMemberInput[] | GroupMembersUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: GroupMembersCreateOrConnectWithoutMemberInput | GroupMembersCreateOrConnectWithoutMemberInput[]
    upsert?: GroupMembersUpsertWithWhereUniqueWithoutMemberInput | GroupMembersUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: GroupMembersCreateManyMemberInputEnvelope
    set?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    disconnect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    delete?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    connect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    update?: GroupMembersUpdateWithWhereUniqueWithoutMemberInput | GroupMembersUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: GroupMembersUpdateManyWithWhereWithoutMemberInput | GroupMembersUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: GroupMembersScalarWhereInput | GroupMembersScalarWhereInput[]
  }

  export type GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<GroupMessagesCreateWithoutSenderInput, GroupMessagesUncheckedCreateWithoutSenderInput> | GroupMessagesCreateWithoutSenderInput[] | GroupMessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: GroupMessagesCreateOrConnectWithoutSenderInput | GroupMessagesCreateOrConnectWithoutSenderInput[]
    upsert?: GroupMessagesUpsertWithWhereUniqueWithoutSenderInput | GroupMessagesUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: GroupMessagesCreateManySenderInputEnvelope
    set?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    disconnect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    delete?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    connect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    update?: GroupMessagesUpdateWithWhereUniqueWithoutSenderInput | GroupMessagesUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: GroupMessagesUpdateManyWithWhereWithoutSenderInput | GroupMessagesUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: GroupMessagesScalarWhereInput | GroupMessagesScalarWhereInput[]
  }

  export type BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput = {
    create?: XOR<BlocksCreateWithoutBlockingUserInput, BlocksUncheckedCreateWithoutBlockingUserInput> | BlocksCreateWithoutBlockingUserInput[] | BlocksUncheckedCreateWithoutBlockingUserInput[]
    connectOrCreate?: BlocksCreateOrConnectWithoutBlockingUserInput | BlocksCreateOrConnectWithoutBlockingUserInput[]
    upsert?: BlocksUpsertWithWhereUniqueWithoutBlockingUserInput | BlocksUpsertWithWhereUniqueWithoutBlockingUserInput[]
    createMany?: BlocksCreateManyBlockingUserInputEnvelope
    set?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    disconnect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    delete?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    connect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    update?: BlocksUpdateWithWhereUniqueWithoutBlockingUserInput | BlocksUpdateWithWhereUniqueWithoutBlockingUserInput[]
    updateMany?: BlocksUpdateManyWithWhereWithoutBlockingUserInput | BlocksUpdateManyWithWhereWithoutBlockingUserInput[]
    deleteMany?: BlocksScalarWhereInput | BlocksScalarWhereInput[]
  }

  export type BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput = {
    create?: XOR<BlocksCreateWithoutBlockedUserInput, BlocksUncheckedCreateWithoutBlockedUserInput> | BlocksCreateWithoutBlockedUserInput[] | BlocksUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlocksCreateOrConnectWithoutBlockedUserInput | BlocksCreateOrConnectWithoutBlockedUserInput[]
    upsert?: BlocksUpsertWithWhereUniqueWithoutBlockedUserInput | BlocksUpsertWithWhereUniqueWithoutBlockedUserInput[]
    createMany?: BlocksCreateManyBlockedUserInputEnvelope
    set?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    disconnect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    delete?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    connect?: BlocksWhereUniqueInput | BlocksWhereUniqueInput[]
    update?: BlocksUpdateWithWhereUniqueWithoutBlockedUserInput | BlocksUpdateWithWhereUniqueWithoutBlockedUserInput[]
    updateMany?: BlocksUpdateManyWithWhereWithoutBlockedUserInput | BlocksUpdateManyWithWhereWithoutBlockedUserInput[]
    deleteMany?: BlocksScalarWhereInput | BlocksScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UsersCreateWithoutMessagesSentInput, UsersUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessagesSentInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutMessagesReceivedInput = {
    create?: XOR<UsersCreateWithoutMessagesReceivedInput, UsersUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessagesReceivedInput
    connect?: UsersWhereUniqueInput
  }

  export type PrivateMessagesAttachmentCreateNestedManyWithoutPrivateMessageInput = {
    create?: XOR<PrivateMessagesAttachmentCreateWithoutPrivateMessageInput, PrivateMessagesAttachmentUncheckedCreateWithoutPrivateMessageInput> | PrivateMessagesAttachmentCreateWithoutPrivateMessageInput[] | PrivateMessagesAttachmentUncheckedCreateWithoutPrivateMessageInput[]
    connectOrCreate?: PrivateMessagesAttachmentCreateOrConnectWithoutPrivateMessageInput | PrivateMessagesAttachmentCreateOrConnectWithoutPrivateMessageInput[]
    createMany?: PrivateMessagesAttachmentCreateManyPrivateMessageInputEnvelope
    connect?: PrivateMessagesAttachmentWhereUniqueInput | PrivateMessagesAttachmentWhereUniqueInput[]
  }

  export type PrivateMessagesAttachmentUncheckedCreateNestedManyWithoutPrivateMessageInput = {
    create?: XOR<PrivateMessagesAttachmentCreateWithoutPrivateMessageInput, PrivateMessagesAttachmentUncheckedCreateWithoutPrivateMessageInput> | PrivateMessagesAttachmentCreateWithoutPrivateMessageInput[] | PrivateMessagesAttachmentUncheckedCreateWithoutPrivateMessageInput[]
    connectOrCreate?: PrivateMessagesAttachmentCreateOrConnectWithoutPrivateMessageInput | PrivateMessagesAttachmentCreateOrConnectWithoutPrivateMessageInput[]
    createMany?: PrivateMessagesAttachmentCreateManyPrivateMessageInputEnvelope
    connect?: PrivateMessagesAttachmentWhereUniqueInput | PrivateMessagesAttachmentWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsersUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<UsersCreateWithoutMessagesSentInput, UsersUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessagesSentInput
    upsert?: UsersUpsertWithoutMessagesSentInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMessagesSentInput, UsersUpdateWithoutMessagesSentInput>, UsersUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UsersUpdateOneRequiredWithoutMessagesReceivedNestedInput = {
    create?: XOR<UsersCreateWithoutMessagesReceivedInput, UsersUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessagesReceivedInput
    upsert?: UsersUpsertWithoutMessagesReceivedInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMessagesReceivedInput, UsersUpdateWithoutMessagesReceivedInput>, UsersUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type PrivateMessagesAttachmentUpdateManyWithoutPrivateMessageNestedInput = {
    create?: XOR<PrivateMessagesAttachmentCreateWithoutPrivateMessageInput, PrivateMessagesAttachmentUncheckedCreateWithoutPrivateMessageInput> | PrivateMessagesAttachmentCreateWithoutPrivateMessageInput[] | PrivateMessagesAttachmentUncheckedCreateWithoutPrivateMessageInput[]
    connectOrCreate?: PrivateMessagesAttachmentCreateOrConnectWithoutPrivateMessageInput | PrivateMessagesAttachmentCreateOrConnectWithoutPrivateMessageInput[]
    upsert?: PrivateMessagesAttachmentUpsertWithWhereUniqueWithoutPrivateMessageInput | PrivateMessagesAttachmentUpsertWithWhereUniqueWithoutPrivateMessageInput[]
    createMany?: PrivateMessagesAttachmentCreateManyPrivateMessageInputEnvelope
    set?: PrivateMessagesAttachmentWhereUniqueInput | PrivateMessagesAttachmentWhereUniqueInput[]
    disconnect?: PrivateMessagesAttachmentWhereUniqueInput | PrivateMessagesAttachmentWhereUniqueInput[]
    delete?: PrivateMessagesAttachmentWhereUniqueInput | PrivateMessagesAttachmentWhereUniqueInput[]
    connect?: PrivateMessagesAttachmentWhereUniqueInput | PrivateMessagesAttachmentWhereUniqueInput[]
    update?: PrivateMessagesAttachmentUpdateWithWhereUniqueWithoutPrivateMessageInput | PrivateMessagesAttachmentUpdateWithWhereUniqueWithoutPrivateMessageInput[]
    updateMany?: PrivateMessagesAttachmentUpdateManyWithWhereWithoutPrivateMessageInput | PrivateMessagesAttachmentUpdateManyWithWhereWithoutPrivateMessageInput[]
    deleteMany?: PrivateMessagesAttachmentScalarWhereInput | PrivateMessagesAttachmentScalarWhereInput[]
  }

  export type PrivateMessagesAttachmentUncheckedUpdateManyWithoutPrivateMessageNestedInput = {
    create?: XOR<PrivateMessagesAttachmentCreateWithoutPrivateMessageInput, PrivateMessagesAttachmentUncheckedCreateWithoutPrivateMessageInput> | PrivateMessagesAttachmentCreateWithoutPrivateMessageInput[] | PrivateMessagesAttachmentUncheckedCreateWithoutPrivateMessageInput[]
    connectOrCreate?: PrivateMessagesAttachmentCreateOrConnectWithoutPrivateMessageInput | PrivateMessagesAttachmentCreateOrConnectWithoutPrivateMessageInput[]
    upsert?: PrivateMessagesAttachmentUpsertWithWhereUniqueWithoutPrivateMessageInput | PrivateMessagesAttachmentUpsertWithWhereUniqueWithoutPrivateMessageInput[]
    createMany?: PrivateMessagesAttachmentCreateManyPrivateMessageInputEnvelope
    set?: PrivateMessagesAttachmentWhereUniqueInput | PrivateMessagesAttachmentWhereUniqueInput[]
    disconnect?: PrivateMessagesAttachmentWhereUniqueInput | PrivateMessagesAttachmentWhereUniqueInput[]
    delete?: PrivateMessagesAttachmentWhereUniqueInput | PrivateMessagesAttachmentWhereUniqueInput[]
    connect?: PrivateMessagesAttachmentWhereUniqueInput | PrivateMessagesAttachmentWhereUniqueInput[]
    update?: PrivateMessagesAttachmentUpdateWithWhereUniqueWithoutPrivateMessageInput | PrivateMessagesAttachmentUpdateWithWhereUniqueWithoutPrivateMessageInput[]
    updateMany?: PrivateMessagesAttachmentUpdateManyWithWhereWithoutPrivateMessageInput | PrivateMessagesAttachmentUpdateManyWithWhereWithoutPrivateMessageInput[]
    deleteMany?: PrivateMessagesAttachmentScalarWhereInput | PrivateMessagesAttachmentScalarWhereInput[]
  }

  export type PrivateMessagesCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<PrivateMessagesCreateWithoutAttachmentsInput, PrivateMessagesUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PrivateMessagesCreateOrConnectWithoutAttachmentsInput
    connect?: PrivateMessagesWhereUniqueInput
  }

  export type PrivateMessagesUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<PrivateMessagesCreateWithoutAttachmentsInput, PrivateMessagesUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PrivateMessagesCreateOrConnectWithoutAttachmentsInput
    upsert?: PrivateMessagesUpsertWithoutAttachmentsInput
    connect?: PrivateMessagesWhereUniqueInput
    update?: XOR<XOR<PrivateMessagesUpdateToOneWithWhereWithoutAttachmentsInput, PrivateMessagesUpdateWithoutAttachmentsInput>, PrivateMessagesUncheckedUpdateWithoutAttachmentsInput>
  }

  export type GroupChatsCreateNestedOneWithoutGroupMessagesInput = {
    create?: XOR<GroupChatsCreateWithoutGroupMessagesInput, GroupChatsUncheckedCreateWithoutGroupMessagesInput>
    connectOrCreate?: GroupChatsCreateOrConnectWithoutGroupMessagesInput
    connect?: GroupChatsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutGroupMessagesInput = {
    create?: XOR<UsersCreateWithoutGroupMessagesInput, UsersUncheckedCreateWithoutGroupMessagesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutGroupMessagesInput
    connect?: UsersWhereUniqueInput
  }

  export type GroupMessagesAttachmentCreateNestedManyWithoutGroupMessageInput = {
    create?: XOR<GroupMessagesAttachmentCreateWithoutGroupMessageInput, GroupMessagesAttachmentUncheckedCreateWithoutGroupMessageInput> | GroupMessagesAttachmentCreateWithoutGroupMessageInput[] | GroupMessagesAttachmentUncheckedCreateWithoutGroupMessageInput[]
    connectOrCreate?: GroupMessagesAttachmentCreateOrConnectWithoutGroupMessageInput | GroupMessagesAttachmentCreateOrConnectWithoutGroupMessageInput[]
    createMany?: GroupMessagesAttachmentCreateManyGroupMessageInputEnvelope
    connect?: GroupMessagesAttachmentWhereUniqueInput | GroupMessagesAttachmentWhereUniqueInput[]
  }

  export type GroupMessagesAttachmentUncheckedCreateNestedManyWithoutGroupMessageInput = {
    create?: XOR<GroupMessagesAttachmentCreateWithoutGroupMessageInput, GroupMessagesAttachmentUncheckedCreateWithoutGroupMessageInput> | GroupMessagesAttachmentCreateWithoutGroupMessageInput[] | GroupMessagesAttachmentUncheckedCreateWithoutGroupMessageInput[]
    connectOrCreate?: GroupMessagesAttachmentCreateOrConnectWithoutGroupMessageInput | GroupMessagesAttachmentCreateOrConnectWithoutGroupMessageInput[]
    createMany?: GroupMessagesAttachmentCreateManyGroupMessageInputEnvelope
    connect?: GroupMessagesAttachmentWhereUniqueInput | GroupMessagesAttachmentWhereUniqueInput[]
  }

  export type GroupChatsUpdateOneRequiredWithoutGroupMessagesNestedInput = {
    create?: XOR<GroupChatsCreateWithoutGroupMessagesInput, GroupChatsUncheckedCreateWithoutGroupMessagesInput>
    connectOrCreate?: GroupChatsCreateOrConnectWithoutGroupMessagesInput
    upsert?: GroupChatsUpsertWithoutGroupMessagesInput
    connect?: GroupChatsWhereUniqueInput
    update?: XOR<XOR<GroupChatsUpdateToOneWithWhereWithoutGroupMessagesInput, GroupChatsUpdateWithoutGroupMessagesInput>, GroupChatsUncheckedUpdateWithoutGroupMessagesInput>
  }

  export type UsersUpdateOneRequiredWithoutGroupMessagesNestedInput = {
    create?: XOR<UsersCreateWithoutGroupMessagesInput, UsersUncheckedCreateWithoutGroupMessagesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutGroupMessagesInput
    upsert?: UsersUpsertWithoutGroupMessagesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutGroupMessagesInput, UsersUpdateWithoutGroupMessagesInput>, UsersUncheckedUpdateWithoutGroupMessagesInput>
  }

  export type GroupMessagesAttachmentUpdateManyWithoutGroupMessageNestedInput = {
    create?: XOR<GroupMessagesAttachmentCreateWithoutGroupMessageInput, GroupMessagesAttachmentUncheckedCreateWithoutGroupMessageInput> | GroupMessagesAttachmentCreateWithoutGroupMessageInput[] | GroupMessagesAttachmentUncheckedCreateWithoutGroupMessageInput[]
    connectOrCreate?: GroupMessagesAttachmentCreateOrConnectWithoutGroupMessageInput | GroupMessagesAttachmentCreateOrConnectWithoutGroupMessageInput[]
    upsert?: GroupMessagesAttachmentUpsertWithWhereUniqueWithoutGroupMessageInput | GroupMessagesAttachmentUpsertWithWhereUniqueWithoutGroupMessageInput[]
    createMany?: GroupMessagesAttachmentCreateManyGroupMessageInputEnvelope
    set?: GroupMessagesAttachmentWhereUniqueInput | GroupMessagesAttachmentWhereUniqueInput[]
    disconnect?: GroupMessagesAttachmentWhereUniqueInput | GroupMessagesAttachmentWhereUniqueInput[]
    delete?: GroupMessagesAttachmentWhereUniqueInput | GroupMessagesAttachmentWhereUniqueInput[]
    connect?: GroupMessagesAttachmentWhereUniqueInput | GroupMessagesAttachmentWhereUniqueInput[]
    update?: GroupMessagesAttachmentUpdateWithWhereUniqueWithoutGroupMessageInput | GroupMessagesAttachmentUpdateWithWhereUniqueWithoutGroupMessageInput[]
    updateMany?: GroupMessagesAttachmentUpdateManyWithWhereWithoutGroupMessageInput | GroupMessagesAttachmentUpdateManyWithWhereWithoutGroupMessageInput[]
    deleteMany?: GroupMessagesAttachmentScalarWhereInput | GroupMessagesAttachmentScalarWhereInput[]
  }

  export type GroupMessagesAttachmentUncheckedUpdateManyWithoutGroupMessageNestedInput = {
    create?: XOR<GroupMessagesAttachmentCreateWithoutGroupMessageInput, GroupMessagesAttachmentUncheckedCreateWithoutGroupMessageInput> | GroupMessagesAttachmentCreateWithoutGroupMessageInput[] | GroupMessagesAttachmentUncheckedCreateWithoutGroupMessageInput[]
    connectOrCreate?: GroupMessagesAttachmentCreateOrConnectWithoutGroupMessageInput | GroupMessagesAttachmentCreateOrConnectWithoutGroupMessageInput[]
    upsert?: GroupMessagesAttachmentUpsertWithWhereUniqueWithoutGroupMessageInput | GroupMessagesAttachmentUpsertWithWhereUniqueWithoutGroupMessageInput[]
    createMany?: GroupMessagesAttachmentCreateManyGroupMessageInputEnvelope
    set?: GroupMessagesAttachmentWhereUniqueInput | GroupMessagesAttachmentWhereUniqueInput[]
    disconnect?: GroupMessagesAttachmentWhereUniqueInput | GroupMessagesAttachmentWhereUniqueInput[]
    delete?: GroupMessagesAttachmentWhereUniqueInput | GroupMessagesAttachmentWhereUniqueInput[]
    connect?: GroupMessagesAttachmentWhereUniqueInput | GroupMessagesAttachmentWhereUniqueInput[]
    update?: GroupMessagesAttachmentUpdateWithWhereUniqueWithoutGroupMessageInput | GroupMessagesAttachmentUpdateWithWhereUniqueWithoutGroupMessageInput[]
    updateMany?: GroupMessagesAttachmentUpdateManyWithWhereWithoutGroupMessageInput | GroupMessagesAttachmentUpdateManyWithWhereWithoutGroupMessageInput[]
    deleteMany?: GroupMessagesAttachmentScalarWhereInput | GroupMessagesAttachmentScalarWhereInput[]
  }

  export type GroupMessagesCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<GroupMessagesCreateWithoutAttachmentsInput, GroupMessagesUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: GroupMessagesCreateOrConnectWithoutAttachmentsInput
    connect?: GroupMessagesWhereUniqueInput
  }

  export type GroupMessagesUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<GroupMessagesCreateWithoutAttachmentsInput, GroupMessagesUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: GroupMessagesCreateOrConnectWithoutAttachmentsInput
    upsert?: GroupMessagesUpsertWithoutAttachmentsInput
    connect?: GroupMessagesWhereUniqueInput
    update?: XOR<XOR<GroupMessagesUpdateToOneWithWhereWithoutAttachmentsInput, GroupMessagesUpdateWithoutAttachmentsInput>, GroupMessagesUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UsersCreateNestedOneWithoutFriendsInput = {
    create?: XOR<UsersCreateWithoutFriendsInput, UsersUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFriendsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutFriendsInput = {
    create?: XOR<UsersCreateWithoutFriendsInput, UsersUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFriendsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutFriendsNestedInput = {
    create?: XOR<UsersCreateWithoutFriendsInput, UsersUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFriendsInput
    upsert?: UsersUpsertWithoutFriendsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFriendsInput, UsersUpdateWithoutFriendsInput>, UsersUncheckedUpdateWithoutFriendsInput>
  }

  export type UsersUpdateOneRequiredWithoutFriendsNestedInput = {
    create?: XOR<UsersCreateWithoutFriendsInput, UsersUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFriendsInput
    upsert?: UsersUpsertWithoutFriendsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFriendsInput, UsersUpdateWithoutFriendsInput>, UsersUncheckedUpdateWithoutFriendsInput>
  }

  export type UsersCreateNestedOneWithoutPendingRequestsSentInput = {
    create?: XOR<UsersCreateWithoutPendingRequestsSentInput, UsersUncheckedCreateWithoutPendingRequestsSentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPendingRequestsSentInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutPendingRequestsReceivedInput = {
    create?: XOR<UsersCreateWithoutPendingRequestsReceivedInput, UsersUncheckedCreateWithoutPendingRequestsReceivedInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPendingRequestsReceivedInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutPendingRequestsSentNestedInput = {
    create?: XOR<UsersCreateWithoutPendingRequestsSentInput, UsersUncheckedCreateWithoutPendingRequestsSentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPendingRequestsSentInput
    upsert?: UsersUpsertWithoutPendingRequestsSentInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPendingRequestsSentInput, UsersUpdateWithoutPendingRequestsSentInput>, UsersUncheckedUpdateWithoutPendingRequestsSentInput>
  }

  export type UsersUpdateOneRequiredWithoutPendingRequestsReceivedNestedInput = {
    create?: XOR<UsersCreateWithoutPendingRequestsReceivedInput, UsersUncheckedCreateWithoutPendingRequestsReceivedInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPendingRequestsReceivedInput
    upsert?: UsersUpsertWithoutPendingRequestsReceivedInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPendingRequestsReceivedInput, UsersUpdateWithoutPendingRequestsReceivedInput>, UsersUncheckedUpdateWithoutPendingRequestsReceivedInput>
  }

  export type UsersCreateNestedOneWithoutGroupChatsInput = {
    create?: XOR<UsersCreateWithoutGroupChatsInput, UsersUncheckedCreateWithoutGroupChatsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutGroupChatsInput
    connect?: UsersWhereUniqueInput
  }

  export type GroupMembersCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMembersCreateWithoutGroupInput, GroupMembersUncheckedCreateWithoutGroupInput> | GroupMembersCreateWithoutGroupInput[] | GroupMembersUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMembersCreateOrConnectWithoutGroupInput | GroupMembersCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMembersCreateManyGroupInputEnvelope
    connect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
  }

  export type GroupMessagesCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMessagesCreateWithoutGroupInput, GroupMessagesUncheckedCreateWithoutGroupInput> | GroupMessagesCreateWithoutGroupInput[] | GroupMessagesUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMessagesCreateOrConnectWithoutGroupInput | GroupMessagesCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMessagesCreateManyGroupInputEnvelope
    connect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
  }

  export type GroupMembersUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMembersCreateWithoutGroupInput, GroupMembersUncheckedCreateWithoutGroupInput> | GroupMembersCreateWithoutGroupInput[] | GroupMembersUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMembersCreateOrConnectWithoutGroupInput | GroupMembersCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMembersCreateManyGroupInputEnvelope
    connect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
  }

  export type GroupMessagesUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMessagesCreateWithoutGroupInput, GroupMessagesUncheckedCreateWithoutGroupInput> | GroupMessagesCreateWithoutGroupInput[] | GroupMessagesUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMessagesCreateOrConnectWithoutGroupInput | GroupMessagesCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMessagesCreateManyGroupInputEnvelope
    connect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
  }

  export type UsersUpdateOneRequiredWithoutGroupChatsNestedInput = {
    create?: XOR<UsersCreateWithoutGroupChatsInput, UsersUncheckedCreateWithoutGroupChatsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutGroupChatsInput
    upsert?: UsersUpsertWithoutGroupChatsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutGroupChatsInput, UsersUpdateWithoutGroupChatsInput>, UsersUncheckedUpdateWithoutGroupChatsInput>
  }

  export type GroupMembersUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMembersCreateWithoutGroupInput, GroupMembersUncheckedCreateWithoutGroupInput> | GroupMembersCreateWithoutGroupInput[] | GroupMembersUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMembersCreateOrConnectWithoutGroupInput | GroupMembersCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMembersUpsertWithWhereUniqueWithoutGroupInput | GroupMembersUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMembersCreateManyGroupInputEnvelope
    set?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    disconnect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    delete?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    connect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    update?: GroupMembersUpdateWithWhereUniqueWithoutGroupInput | GroupMembersUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMembersUpdateManyWithWhereWithoutGroupInput | GroupMembersUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMembersScalarWhereInput | GroupMembersScalarWhereInput[]
  }

  export type GroupMessagesUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMessagesCreateWithoutGroupInput, GroupMessagesUncheckedCreateWithoutGroupInput> | GroupMessagesCreateWithoutGroupInput[] | GroupMessagesUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMessagesCreateOrConnectWithoutGroupInput | GroupMessagesCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMessagesUpsertWithWhereUniqueWithoutGroupInput | GroupMessagesUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMessagesCreateManyGroupInputEnvelope
    set?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    disconnect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    delete?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    connect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    update?: GroupMessagesUpdateWithWhereUniqueWithoutGroupInput | GroupMessagesUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMessagesUpdateManyWithWhereWithoutGroupInput | GroupMessagesUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMessagesScalarWhereInput | GroupMessagesScalarWhereInput[]
  }

  export type GroupMembersUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMembersCreateWithoutGroupInput, GroupMembersUncheckedCreateWithoutGroupInput> | GroupMembersCreateWithoutGroupInput[] | GroupMembersUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMembersCreateOrConnectWithoutGroupInput | GroupMembersCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMembersUpsertWithWhereUniqueWithoutGroupInput | GroupMembersUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMembersCreateManyGroupInputEnvelope
    set?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    disconnect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    delete?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    connect?: GroupMembersWhereUniqueInput | GroupMembersWhereUniqueInput[]
    update?: GroupMembersUpdateWithWhereUniqueWithoutGroupInput | GroupMembersUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMembersUpdateManyWithWhereWithoutGroupInput | GroupMembersUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMembersScalarWhereInput | GroupMembersScalarWhereInput[]
  }

  export type GroupMessagesUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMessagesCreateWithoutGroupInput, GroupMessagesUncheckedCreateWithoutGroupInput> | GroupMessagesCreateWithoutGroupInput[] | GroupMessagesUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMessagesCreateOrConnectWithoutGroupInput | GroupMessagesCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMessagesUpsertWithWhereUniqueWithoutGroupInput | GroupMessagesUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMessagesCreateManyGroupInputEnvelope
    set?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    disconnect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    delete?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    connect?: GroupMessagesWhereUniqueInput | GroupMessagesWhereUniqueInput[]
    update?: GroupMessagesUpdateWithWhereUniqueWithoutGroupInput | GroupMessagesUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMessagesUpdateManyWithWhereWithoutGroupInput | GroupMessagesUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMessagesScalarWhereInput | GroupMessagesScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutBlockedByInput = {
    create?: XOR<UsersCreateWithoutBlockedByInput, UsersUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBlockedByInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutBlockingInput = {
    create?: XOR<UsersCreateWithoutBlockingInput, UsersUncheckedCreateWithoutBlockingInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBlockingInput
    connect?: UsersWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UsersUpdateOneRequiredWithoutBlockedByNestedInput = {
    create?: XOR<UsersCreateWithoutBlockedByInput, UsersUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBlockedByInput
    upsert?: UsersUpsertWithoutBlockedByInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutBlockedByInput, UsersUpdateWithoutBlockedByInput>, UsersUncheckedUpdateWithoutBlockedByInput>
  }

  export type UsersUpdateOneRequiredWithoutBlockingNestedInput = {
    create?: XOR<UsersCreateWithoutBlockingInput, UsersUncheckedCreateWithoutBlockingInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBlockingInput
    upsert?: UsersUpsertWithoutBlockingInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutBlockingInput, UsersUpdateWithoutBlockingInput>, UsersUncheckedUpdateWithoutBlockingInput>
  }

  export type UsersCreateNestedOneWithoutGroupMembersInput = {
    create?: XOR<UsersCreateWithoutGroupMembersInput, UsersUncheckedCreateWithoutGroupMembersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutGroupMembersInput
    connect?: UsersWhereUniqueInput
  }

  export type GroupChatsCreateNestedOneWithoutGroupMembersInput = {
    create?: XOR<GroupChatsCreateWithoutGroupMembersInput, GroupChatsUncheckedCreateWithoutGroupMembersInput>
    connectOrCreate?: GroupChatsCreateOrConnectWithoutGroupMembersInput
    connect?: GroupChatsWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutGroupMembersNestedInput = {
    create?: XOR<UsersCreateWithoutGroupMembersInput, UsersUncheckedCreateWithoutGroupMembersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutGroupMembersInput
    upsert?: UsersUpsertWithoutGroupMembersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutGroupMembersInput, UsersUpdateWithoutGroupMembersInput>, UsersUncheckedUpdateWithoutGroupMembersInput>
  }

  export type GroupChatsUpdateOneRequiredWithoutGroupMembersNestedInput = {
    create?: XOR<GroupChatsCreateWithoutGroupMembersInput, GroupChatsUncheckedCreateWithoutGroupMembersInput>
    connectOrCreate?: GroupChatsCreateOrConnectWithoutGroupMembersInput
    upsert?: GroupChatsUpsertWithoutGroupMembersInput
    connect?: GroupChatsWhereUniqueInput
    update?: XOR<XOR<GroupChatsUpdateToOneWithWhereWithoutGroupMembersInput, GroupChatsUpdateWithoutGroupMembersInput>, GroupChatsUncheckedUpdateWithoutGroupMembersInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type PrivateMessagesCreateWithoutSenderInput = {
    content: string
    created_at?: Date | string
    receiver: UsersCreateNestedOneWithoutMessagesReceivedInput
    attachments?: PrivateMessagesAttachmentCreateNestedManyWithoutPrivateMessageInput
  }

  export type PrivateMessagesUncheckedCreateWithoutSenderInput = {
    id?: number
    receiver_id: number
    content: string
    created_at?: Date | string
    attachments?: PrivateMessagesAttachmentUncheckedCreateNestedManyWithoutPrivateMessageInput
  }

  export type PrivateMessagesCreateOrConnectWithoutSenderInput = {
    where: PrivateMessagesWhereUniqueInput
    create: XOR<PrivateMessagesCreateWithoutSenderInput, PrivateMessagesUncheckedCreateWithoutSenderInput>
  }

  export type PrivateMessagesCreateManySenderInputEnvelope = {
    data: PrivateMessagesCreateManySenderInput | PrivateMessagesCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type PrivateMessagesCreateWithoutReceiverInput = {
    content: string
    created_at?: Date | string
    sender: UsersCreateNestedOneWithoutMessagesSentInput
    attachments?: PrivateMessagesAttachmentCreateNestedManyWithoutPrivateMessageInput
  }

  export type PrivateMessagesUncheckedCreateWithoutReceiverInput = {
    id?: number
    sender_id: number
    content: string
    created_at?: Date | string
    attachments?: PrivateMessagesAttachmentUncheckedCreateNestedManyWithoutPrivateMessageInput
  }

  export type PrivateMessagesCreateOrConnectWithoutReceiverInput = {
    where: PrivateMessagesWhereUniqueInput
    create: XOR<PrivateMessagesCreateWithoutReceiverInput, PrivateMessagesUncheckedCreateWithoutReceiverInput>
  }

  export type PrivateMessagesCreateManyReceiverInputEnvelope = {
    data: PrivateMessagesCreateManyReceiverInput | PrivateMessagesCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type FriendsCreateWithoutUserInput = {
    Friend: UsersCreateNestedOneWithoutFriendsInput
  }

  export type FriendsUncheckedCreateWithoutUserInput = {
    friend_id: number
  }

  export type FriendsCreateOrConnectWithoutUserInput = {
    where: FriendsWhereUniqueInput
    create: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput>
  }

  export type FriendsCreateManyUserInputEnvelope = {
    data: FriendsCreateManyUserInput | FriendsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PendingFriendRequestsCreateWithoutSenderInput = {
    Receiver: UsersCreateNestedOneWithoutPendingRequestsReceivedInput
  }

  export type PendingFriendRequestsUncheckedCreateWithoutSenderInput = {
    receiver_id: number
  }

  export type PendingFriendRequestsCreateOrConnectWithoutSenderInput = {
    where: PendingFriendRequestsWhereUniqueInput
    create: XOR<PendingFriendRequestsCreateWithoutSenderInput, PendingFriendRequestsUncheckedCreateWithoutSenderInput>
  }

  export type PendingFriendRequestsCreateManySenderInputEnvelope = {
    data: PendingFriendRequestsCreateManySenderInput | PendingFriendRequestsCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type PendingFriendRequestsCreateWithoutReceiverInput = {
    Sender: UsersCreateNestedOneWithoutPendingRequestsSentInput
  }

  export type PendingFriendRequestsUncheckedCreateWithoutReceiverInput = {
    sender_id: number
  }

  export type PendingFriendRequestsCreateOrConnectWithoutReceiverInput = {
    where: PendingFriendRequestsWhereUniqueInput
    create: XOR<PendingFriendRequestsCreateWithoutReceiverInput, PendingFriendRequestsUncheckedCreateWithoutReceiverInput>
  }

  export type PendingFriendRequestsCreateManyReceiverInputEnvelope = {
    data: PendingFriendRequestsCreateManyReceiverInput | PendingFriendRequestsCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type FriendsCreateWithoutFriendInput = {
    User: UsersCreateNestedOneWithoutFriendsInput
  }

  export type FriendsUncheckedCreateWithoutFriendInput = {
    user_id: number
  }

  export type FriendsCreateOrConnectWithoutFriendInput = {
    where: FriendsWhereUniqueInput
    create: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput>
  }

  export type FriendsCreateManyFriendInputEnvelope = {
    data: FriendsCreateManyFriendInput | FriendsCreateManyFriendInput[]
    skipDuplicates?: boolean
  }

  export type GroupChatsCreateWithoutAdminInput = {
    name?: string | null
    description?: string | null
    avatar?: string | null
    GroupMembers?: GroupMembersCreateNestedManyWithoutGroupInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutGroupInput
  }

  export type GroupChatsUncheckedCreateWithoutAdminInput = {
    id?: number
    name?: string | null
    description?: string | null
    avatar?: string | null
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutGroupInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupChatsCreateOrConnectWithoutAdminInput = {
    where: GroupChatsWhereUniqueInput
    create: XOR<GroupChatsCreateWithoutAdminInput, GroupChatsUncheckedCreateWithoutAdminInput>
  }

  export type GroupChatsCreateManyAdminInputEnvelope = {
    data: GroupChatsCreateManyAdminInput | GroupChatsCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type GroupMembersCreateWithoutMemberInput = {
    Group: GroupChatsCreateNestedOneWithoutGroupMembersInput
  }

  export type GroupMembersUncheckedCreateWithoutMemberInput = {
    group_id: number
  }

  export type GroupMembersCreateOrConnectWithoutMemberInput = {
    where: GroupMembersWhereUniqueInput
    create: XOR<GroupMembersCreateWithoutMemberInput, GroupMembersUncheckedCreateWithoutMemberInput>
  }

  export type GroupMembersCreateManyMemberInputEnvelope = {
    data: GroupMembersCreateManyMemberInput | GroupMembersCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type GroupMessagesCreateWithoutSenderInput = {
    content: string
    created_at?: Date | string
    group: GroupChatsCreateNestedOneWithoutGroupMessagesInput
    attachments?: GroupMessagesAttachmentCreateNestedManyWithoutGroupMessageInput
  }

  export type GroupMessagesUncheckedCreateWithoutSenderInput = {
    id?: number
    group_id: number
    content: string
    created_at?: Date | string
    attachments?: GroupMessagesAttachmentUncheckedCreateNestedManyWithoutGroupMessageInput
  }

  export type GroupMessagesCreateOrConnectWithoutSenderInput = {
    where: GroupMessagesWhereUniqueInput
    create: XOR<GroupMessagesCreateWithoutSenderInput, GroupMessagesUncheckedCreateWithoutSenderInput>
  }

  export type GroupMessagesCreateManySenderInputEnvelope = {
    data: GroupMessagesCreateManySenderInput | GroupMessagesCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type BlocksCreateWithoutBlockingUserInput = {
    friends?: boolean | null
    BlockedUser: UsersCreateNestedOneWithoutBlockedByInput
  }

  export type BlocksUncheckedCreateWithoutBlockingUserInput = {
    blocked: number
    friends?: boolean | null
  }

  export type BlocksCreateOrConnectWithoutBlockingUserInput = {
    where: BlocksWhereUniqueInput
    create: XOR<BlocksCreateWithoutBlockingUserInput, BlocksUncheckedCreateWithoutBlockingUserInput>
  }

  export type BlocksCreateManyBlockingUserInputEnvelope = {
    data: BlocksCreateManyBlockingUserInput | BlocksCreateManyBlockingUserInput[]
    skipDuplicates?: boolean
  }

  export type BlocksCreateWithoutBlockedUserInput = {
    friends?: boolean | null
    BlockingUser: UsersCreateNestedOneWithoutBlockingInput
  }

  export type BlocksUncheckedCreateWithoutBlockedUserInput = {
    blocker: number
    friends?: boolean | null
  }

  export type BlocksCreateOrConnectWithoutBlockedUserInput = {
    where: BlocksWhereUniqueInput
    create: XOR<BlocksCreateWithoutBlockedUserInput, BlocksUncheckedCreateWithoutBlockedUserInput>
  }

  export type BlocksCreateManyBlockedUserInputEnvelope = {
    data: BlocksCreateManyBlockedUserInput | BlocksCreateManyBlockedUserInput[]
    skipDuplicates?: boolean
  }

  export type PrivateMessagesUpsertWithWhereUniqueWithoutSenderInput = {
    where: PrivateMessagesWhereUniqueInput
    update: XOR<PrivateMessagesUpdateWithoutSenderInput, PrivateMessagesUncheckedUpdateWithoutSenderInput>
    create: XOR<PrivateMessagesCreateWithoutSenderInput, PrivateMessagesUncheckedCreateWithoutSenderInput>
  }

  export type PrivateMessagesUpdateWithWhereUniqueWithoutSenderInput = {
    where: PrivateMessagesWhereUniqueInput
    data: XOR<PrivateMessagesUpdateWithoutSenderInput, PrivateMessagesUncheckedUpdateWithoutSenderInput>
  }

  export type PrivateMessagesUpdateManyWithWhereWithoutSenderInput = {
    where: PrivateMessagesScalarWhereInput
    data: XOR<PrivateMessagesUpdateManyMutationInput, PrivateMessagesUncheckedUpdateManyWithoutSenderInput>
  }

  export type PrivateMessagesScalarWhereInput = {
    AND?: PrivateMessagesScalarWhereInput | PrivateMessagesScalarWhereInput[]
    OR?: PrivateMessagesScalarWhereInput[]
    NOT?: PrivateMessagesScalarWhereInput | PrivateMessagesScalarWhereInput[]
    id?: IntFilter<"PrivateMessages"> | number
    sender_id?: IntFilter<"PrivateMessages"> | number
    receiver_id?: IntFilter<"PrivateMessages"> | number
    content?: StringFilter<"PrivateMessages"> | string
    created_at?: DateTimeFilter<"PrivateMessages"> | Date | string
  }

  export type PrivateMessagesUpsertWithWhereUniqueWithoutReceiverInput = {
    where: PrivateMessagesWhereUniqueInput
    update: XOR<PrivateMessagesUpdateWithoutReceiverInput, PrivateMessagesUncheckedUpdateWithoutReceiverInput>
    create: XOR<PrivateMessagesCreateWithoutReceiverInput, PrivateMessagesUncheckedCreateWithoutReceiverInput>
  }

  export type PrivateMessagesUpdateWithWhereUniqueWithoutReceiverInput = {
    where: PrivateMessagesWhereUniqueInput
    data: XOR<PrivateMessagesUpdateWithoutReceiverInput, PrivateMessagesUncheckedUpdateWithoutReceiverInput>
  }

  export type PrivateMessagesUpdateManyWithWhereWithoutReceiverInput = {
    where: PrivateMessagesScalarWhereInput
    data: XOR<PrivateMessagesUpdateManyMutationInput, PrivateMessagesUncheckedUpdateManyWithoutReceiverInput>
  }

  export type FriendsUpsertWithWhereUniqueWithoutUserInput = {
    where: FriendsWhereUniqueInput
    update: XOR<FriendsUpdateWithoutUserInput, FriendsUncheckedUpdateWithoutUserInput>
    create: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput>
  }

  export type FriendsUpdateWithWhereUniqueWithoutUserInput = {
    where: FriendsWhereUniqueInput
    data: XOR<FriendsUpdateWithoutUserInput, FriendsUncheckedUpdateWithoutUserInput>
  }

  export type FriendsUpdateManyWithWhereWithoutUserInput = {
    where: FriendsScalarWhereInput
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyWithoutUserInput>
  }

  export type FriendsScalarWhereInput = {
    AND?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
    OR?: FriendsScalarWhereInput[]
    NOT?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
    user_id?: IntFilter<"Friends"> | number
    friend_id?: IntFilter<"Friends"> | number
  }

  export type PendingFriendRequestsUpsertWithWhereUniqueWithoutSenderInput = {
    where: PendingFriendRequestsWhereUniqueInput
    update: XOR<PendingFriendRequestsUpdateWithoutSenderInput, PendingFriendRequestsUncheckedUpdateWithoutSenderInput>
    create: XOR<PendingFriendRequestsCreateWithoutSenderInput, PendingFriendRequestsUncheckedCreateWithoutSenderInput>
  }

  export type PendingFriendRequestsUpdateWithWhereUniqueWithoutSenderInput = {
    where: PendingFriendRequestsWhereUniqueInput
    data: XOR<PendingFriendRequestsUpdateWithoutSenderInput, PendingFriendRequestsUncheckedUpdateWithoutSenderInput>
  }

  export type PendingFriendRequestsUpdateManyWithWhereWithoutSenderInput = {
    where: PendingFriendRequestsScalarWhereInput
    data: XOR<PendingFriendRequestsUpdateManyMutationInput, PendingFriendRequestsUncheckedUpdateManyWithoutSenderInput>
  }

  export type PendingFriendRequestsScalarWhereInput = {
    AND?: PendingFriendRequestsScalarWhereInput | PendingFriendRequestsScalarWhereInput[]
    OR?: PendingFriendRequestsScalarWhereInput[]
    NOT?: PendingFriendRequestsScalarWhereInput | PendingFriendRequestsScalarWhereInput[]
    sender_id?: IntFilter<"PendingFriendRequests"> | number
    receiver_id?: IntFilter<"PendingFriendRequests"> | number
  }

  export type PendingFriendRequestsUpsertWithWhereUniqueWithoutReceiverInput = {
    where: PendingFriendRequestsWhereUniqueInput
    update: XOR<PendingFriendRequestsUpdateWithoutReceiverInput, PendingFriendRequestsUncheckedUpdateWithoutReceiverInput>
    create: XOR<PendingFriendRequestsCreateWithoutReceiverInput, PendingFriendRequestsUncheckedCreateWithoutReceiverInput>
  }

  export type PendingFriendRequestsUpdateWithWhereUniqueWithoutReceiverInput = {
    where: PendingFriendRequestsWhereUniqueInput
    data: XOR<PendingFriendRequestsUpdateWithoutReceiverInput, PendingFriendRequestsUncheckedUpdateWithoutReceiverInput>
  }

  export type PendingFriendRequestsUpdateManyWithWhereWithoutReceiverInput = {
    where: PendingFriendRequestsScalarWhereInput
    data: XOR<PendingFriendRequestsUpdateManyMutationInput, PendingFriendRequestsUncheckedUpdateManyWithoutReceiverInput>
  }

  export type FriendsUpsertWithWhereUniqueWithoutFriendInput = {
    where: FriendsWhereUniqueInput
    update: XOR<FriendsUpdateWithoutFriendInput, FriendsUncheckedUpdateWithoutFriendInput>
    create: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput>
  }

  export type FriendsUpdateWithWhereUniqueWithoutFriendInput = {
    where: FriendsWhereUniqueInput
    data: XOR<FriendsUpdateWithoutFriendInput, FriendsUncheckedUpdateWithoutFriendInput>
  }

  export type FriendsUpdateManyWithWhereWithoutFriendInput = {
    where: FriendsScalarWhereInput
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyWithoutFriendInput>
  }

  export type GroupChatsUpsertWithWhereUniqueWithoutAdminInput = {
    where: GroupChatsWhereUniqueInput
    update: XOR<GroupChatsUpdateWithoutAdminInput, GroupChatsUncheckedUpdateWithoutAdminInput>
    create: XOR<GroupChatsCreateWithoutAdminInput, GroupChatsUncheckedCreateWithoutAdminInput>
  }

  export type GroupChatsUpdateWithWhereUniqueWithoutAdminInput = {
    where: GroupChatsWhereUniqueInput
    data: XOR<GroupChatsUpdateWithoutAdminInput, GroupChatsUncheckedUpdateWithoutAdminInput>
  }

  export type GroupChatsUpdateManyWithWhereWithoutAdminInput = {
    where: GroupChatsScalarWhereInput
    data: XOR<GroupChatsUpdateManyMutationInput, GroupChatsUncheckedUpdateManyWithoutAdminInput>
  }

  export type GroupChatsScalarWhereInput = {
    AND?: GroupChatsScalarWhereInput | GroupChatsScalarWhereInput[]
    OR?: GroupChatsScalarWhereInput[]
    NOT?: GroupChatsScalarWhereInput | GroupChatsScalarWhereInput[]
    id?: IntFilter<"GroupChats"> | number
    admin_id?: IntFilter<"GroupChats"> | number
    name?: StringNullableFilter<"GroupChats"> | string | null
    description?: StringNullableFilter<"GroupChats"> | string | null
    avatar?: StringNullableFilter<"GroupChats"> | string | null
  }

  export type GroupMembersUpsertWithWhereUniqueWithoutMemberInput = {
    where: GroupMembersWhereUniqueInput
    update: XOR<GroupMembersUpdateWithoutMemberInput, GroupMembersUncheckedUpdateWithoutMemberInput>
    create: XOR<GroupMembersCreateWithoutMemberInput, GroupMembersUncheckedCreateWithoutMemberInput>
  }

  export type GroupMembersUpdateWithWhereUniqueWithoutMemberInput = {
    where: GroupMembersWhereUniqueInput
    data: XOR<GroupMembersUpdateWithoutMemberInput, GroupMembersUncheckedUpdateWithoutMemberInput>
  }

  export type GroupMembersUpdateManyWithWhereWithoutMemberInput = {
    where: GroupMembersScalarWhereInput
    data: XOR<GroupMembersUpdateManyMutationInput, GroupMembersUncheckedUpdateManyWithoutMemberInput>
  }

  export type GroupMembersScalarWhereInput = {
    AND?: GroupMembersScalarWhereInput | GroupMembersScalarWhereInput[]
    OR?: GroupMembersScalarWhereInput[]
    NOT?: GroupMembersScalarWhereInput | GroupMembersScalarWhereInput[]
    group_id?: IntFilter<"GroupMembers"> | number
    member_id?: IntFilter<"GroupMembers"> | number
  }

  export type GroupMessagesUpsertWithWhereUniqueWithoutSenderInput = {
    where: GroupMessagesWhereUniqueInput
    update: XOR<GroupMessagesUpdateWithoutSenderInput, GroupMessagesUncheckedUpdateWithoutSenderInput>
    create: XOR<GroupMessagesCreateWithoutSenderInput, GroupMessagesUncheckedCreateWithoutSenderInput>
  }

  export type GroupMessagesUpdateWithWhereUniqueWithoutSenderInput = {
    where: GroupMessagesWhereUniqueInput
    data: XOR<GroupMessagesUpdateWithoutSenderInput, GroupMessagesUncheckedUpdateWithoutSenderInput>
  }

  export type GroupMessagesUpdateManyWithWhereWithoutSenderInput = {
    where: GroupMessagesScalarWhereInput
    data: XOR<GroupMessagesUpdateManyMutationInput, GroupMessagesUncheckedUpdateManyWithoutSenderInput>
  }

  export type GroupMessagesScalarWhereInput = {
    AND?: GroupMessagesScalarWhereInput | GroupMessagesScalarWhereInput[]
    OR?: GroupMessagesScalarWhereInput[]
    NOT?: GroupMessagesScalarWhereInput | GroupMessagesScalarWhereInput[]
    id?: IntFilter<"GroupMessages"> | number
    sender_id?: IntFilter<"GroupMessages"> | number
    group_id?: IntFilter<"GroupMessages"> | number
    content?: StringFilter<"GroupMessages"> | string
    created_at?: DateTimeFilter<"GroupMessages"> | Date | string
  }

  export type BlocksUpsertWithWhereUniqueWithoutBlockingUserInput = {
    where: BlocksWhereUniqueInput
    update: XOR<BlocksUpdateWithoutBlockingUserInput, BlocksUncheckedUpdateWithoutBlockingUserInput>
    create: XOR<BlocksCreateWithoutBlockingUserInput, BlocksUncheckedCreateWithoutBlockingUserInput>
  }

  export type BlocksUpdateWithWhereUniqueWithoutBlockingUserInput = {
    where: BlocksWhereUniqueInput
    data: XOR<BlocksUpdateWithoutBlockingUserInput, BlocksUncheckedUpdateWithoutBlockingUserInput>
  }

  export type BlocksUpdateManyWithWhereWithoutBlockingUserInput = {
    where: BlocksScalarWhereInput
    data: XOR<BlocksUpdateManyMutationInput, BlocksUncheckedUpdateManyWithoutBlockingUserInput>
  }

  export type BlocksScalarWhereInput = {
    AND?: BlocksScalarWhereInput | BlocksScalarWhereInput[]
    OR?: BlocksScalarWhereInput[]
    NOT?: BlocksScalarWhereInput | BlocksScalarWhereInput[]
    blocked?: IntFilter<"Blocks"> | number
    blocker?: IntFilter<"Blocks"> | number
    friends?: BoolNullableFilter<"Blocks"> | boolean | null
  }

  export type BlocksUpsertWithWhereUniqueWithoutBlockedUserInput = {
    where: BlocksWhereUniqueInput
    update: XOR<BlocksUpdateWithoutBlockedUserInput, BlocksUncheckedUpdateWithoutBlockedUserInput>
    create: XOR<BlocksCreateWithoutBlockedUserInput, BlocksUncheckedCreateWithoutBlockedUserInput>
  }

  export type BlocksUpdateWithWhereUniqueWithoutBlockedUserInput = {
    where: BlocksWhereUniqueInput
    data: XOR<BlocksUpdateWithoutBlockedUserInput, BlocksUncheckedUpdateWithoutBlockedUserInput>
  }

  export type BlocksUpdateManyWithWhereWithoutBlockedUserInput = {
    where: BlocksScalarWhereInput
    data: XOR<BlocksUpdateManyMutationInput, BlocksUncheckedUpdateManyWithoutBlockedUserInput>
  }

  export type UsersCreateWithoutMessagesSentInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesReceived?: PrivateMessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsCreateNestedManyWithoutReceiverInput
    Friends?: FriendsCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutSenderInput
    blocking?: BlocksCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUncheckedCreateWithoutMessagesSentInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesReceived?: PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput
    Friends?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsUncheckedCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutSenderInput
    blocking?: BlocksUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksUncheckedCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersCreateOrConnectWithoutMessagesSentInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMessagesSentInput, UsersUncheckedCreateWithoutMessagesSentInput>
  }

  export type UsersCreateWithoutMessagesReceivedInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesCreateNestedManyWithoutSenderInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsCreateNestedManyWithoutReceiverInput
    Friends?: FriendsCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutSenderInput
    blocking?: BlocksCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUncheckedCreateWithoutMessagesReceivedInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput
    Friends?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsUncheckedCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutSenderInput
    blocking?: BlocksUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksUncheckedCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersCreateOrConnectWithoutMessagesReceivedInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMessagesReceivedInput, UsersUncheckedCreateWithoutMessagesReceivedInput>
  }

  export type PrivateMessagesAttachmentCreateWithoutPrivateMessageInput = {
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
  }

  export type PrivateMessagesAttachmentUncheckedCreateWithoutPrivateMessageInput = {
    id?: number
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
  }

  export type PrivateMessagesAttachmentCreateOrConnectWithoutPrivateMessageInput = {
    where: PrivateMessagesAttachmentWhereUniqueInput
    create: XOR<PrivateMessagesAttachmentCreateWithoutPrivateMessageInput, PrivateMessagesAttachmentUncheckedCreateWithoutPrivateMessageInput>
  }

  export type PrivateMessagesAttachmentCreateManyPrivateMessageInputEnvelope = {
    data: PrivateMessagesAttachmentCreateManyPrivateMessageInput | PrivateMessagesAttachmentCreateManyPrivateMessageInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutMessagesSentInput = {
    update: XOR<UsersUpdateWithoutMessagesSentInput, UsersUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UsersCreateWithoutMessagesSentInput, UsersUncheckedCreateWithoutMessagesSentInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMessagesSentInput, UsersUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UsersUpdateWithoutMessagesSentInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesReceived?: PrivateMessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutMessagesSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesReceived?: PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUncheckedUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUpsertWithoutMessagesReceivedInput = {
    update: XOR<UsersUpdateWithoutMessagesReceivedInput, UsersUncheckedUpdateWithoutMessagesReceivedInput>
    create: XOR<UsersCreateWithoutMessagesReceivedInput, UsersUncheckedCreateWithoutMessagesReceivedInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMessagesReceivedInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMessagesReceivedInput, UsersUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type UsersUpdateWithoutMessagesReceivedInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUpdateManyWithoutSenderNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutMessagesReceivedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUncheckedUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput
  }

  export type PrivateMessagesAttachmentUpsertWithWhereUniqueWithoutPrivateMessageInput = {
    where: PrivateMessagesAttachmentWhereUniqueInput
    update: XOR<PrivateMessagesAttachmentUpdateWithoutPrivateMessageInput, PrivateMessagesAttachmentUncheckedUpdateWithoutPrivateMessageInput>
    create: XOR<PrivateMessagesAttachmentCreateWithoutPrivateMessageInput, PrivateMessagesAttachmentUncheckedCreateWithoutPrivateMessageInput>
  }

  export type PrivateMessagesAttachmentUpdateWithWhereUniqueWithoutPrivateMessageInput = {
    where: PrivateMessagesAttachmentWhereUniqueInput
    data: XOR<PrivateMessagesAttachmentUpdateWithoutPrivateMessageInput, PrivateMessagesAttachmentUncheckedUpdateWithoutPrivateMessageInput>
  }

  export type PrivateMessagesAttachmentUpdateManyWithWhereWithoutPrivateMessageInput = {
    where: PrivateMessagesAttachmentScalarWhereInput
    data: XOR<PrivateMessagesAttachmentUpdateManyMutationInput, PrivateMessagesAttachmentUncheckedUpdateManyWithoutPrivateMessageInput>
  }

  export type PrivateMessagesAttachmentScalarWhereInput = {
    AND?: PrivateMessagesAttachmentScalarWhereInput | PrivateMessagesAttachmentScalarWhereInput[]
    OR?: PrivateMessagesAttachmentScalarWhereInput[]
    NOT?: PrivateMessagesAttachmentScalarWhereInput | PrivateMessagesAttachmentScalarWhereInput[]
    id?: IntFilter<"PrivateMessagesAttachment"> | number
    message_id?: IntFilter<"PrivateMessagesAttachment"> | number
    size?: IntFilter<"PrivateMessagesAttachment"> | number
    path?: StringFilter<"PrivateMessagesAttachment"> | string
    originalName?: StringFilter<"PrivateMessagesAttachment"> | string
    uniqueFileName?: StringFilter<"PrivateMessagesAttachment"> | string
    created_at?: DateTimeFilter<"PrivateMessagesAttachment"> | Date | string
  }

  export type PrivateMessagesCreateWithoutAttachmentsInput = {
    content: string
    created_at?: Date | string
    sender: UsersCreateNestedOneWithoutMessagesSentInput
    receiver: UsersCreateNestedOneWithoutMessagesReceivedInput
  }

  export type PrivateMessagesUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    sender_id: number
    receiver_id: number
    content: string
    created_at?: Date | string
  }

  export type PrivateMessagesCreateOrConnectWithoutAttachmentsInput = {
    where: PrivateMessagesWhereUniqueInput
    create: XOR<PrivateMessagesCreateWithoutAttachmentsInput, PrivateMessagesUncheckedCreateWithoutAttachmentsInput>
  }

  export type PrivateMessagesUpsertWithoutAttachmentsInput = {
    update: XOR<PrivateMessagesUpdateWithoutAttachmentsInput, PrivateMessagesUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<PrivateMessagesCreateWithoutAttachmentsInput, PrivateMessagesUncheckedCreateWithoutAttachmentsInput>
    where?: PrivateMessagesWhereInput
  }

  export type PrivateMessagesUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: PrivateMessagesWhereInput
    data: XOR<PrivateMessagesUpdateWithoutAttachmentsInput, PrivateMessagesUncheckedUpdateWithoutAttachmentsInput>
  }

  export type PrivateMessagesUpdateWithoutAttachmentsInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UsersUpdateOneRequiredWithoutMessagesSentNestedInput
    receiver?: UsersUpdateOneRequiredWithoutMessagesReceivedNestedInput
  }

  export type PrivateMessagesUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupChatsCreateWithoutGroupMessagesInput = {
    name?: string | null
    description?: string | null
    avatar?: string | null
    Admin: UsersCreateNestedOneWithoutGroupChatsInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutGroupInput
  }

  export type GroupChatsUncheckedCreateWithoutGroupMessagesInput = {
    id?: number
    admin_id: number
    name?: string | null
    description?: string | null
    avatar?: string | null
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupChatsCreateOrConnectWithoutGroupMessagesInput = {
    where: GroupChatsWhereUniqueInput
    create: XOR<GroupChatsCreateWithoutGroupMessagesInput, GroupChatsUncheckedCreateWithoutGroupMessagesInput>
  }

  export type UsersCreateWithoutGroupMessagesInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsCreateNestedManyWithoutReceiverInput
    Friends?: FriendsCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutMemberInput
    blocking?: BlocksCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUncheckedCreateWithoutGroupMessagesInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput
    Friends?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsUncheckedCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutMemberInput
    blocking?: BlocksUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksUncheckedCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersCreateOrConnectWithoutGroupMessagesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutGroupMessagesInput, UsersUncheckedCreateWithoutGroupMessagesInput>
  }

  export type GroupMessagesAttachmentCreateWithoutGroupMessageInput = {
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
  }

  export type GroupMessagesAttachmentUncheckedCreateWithoutGroupMessageInput = {
    id?: number
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
  }

  export type GroupMessagesAttachmentCreateOrConnectWithoutGroupMessageInput = {
    where: GroupMessagesAttachmentWhereUniqueInput
    create: XOR<GroupMessagesAttachmentCreateWithoutGroupMessageInput, GroupMessagesAttachmentUncheckedCreateWithoutGroupMessageInput>
  }

  export type GroupMessagesAttachmentCreateManyGroupMessageInputEnvelope = {
    data: GroupMessagesAttachmentCreateManyGroupMessageInput | GroupMessagesAttachmentCreateManyGroupMessageInput[]
    skipDuplicates?: boolean
  }

  export type GroupChatsUpsertWithoutGroupMessagesInput = {
    update: XOR<GroupChatsUpdateWithoutGroupMessagesInput, GroupChatsUncheckedUpdateWithoutGroupMessagesInput>
    create: XOR<GroupChatsCreateWithoutGroupMessagesInput, GroupChatsUncheckedCreateWithoutGroupMessagesInput>
    where?: GroupChatsWhereInput
  }

  export type GroupChatsUpdateToOneWithWhereWithoutGroupMessagesInput = {
    where?: GroupChatsWhereInput
    data: XOR<GroupChatsUpdateWithoutGroupMessagesInput, GroupChatsUncheckedUpdateWithoutGroupMessagesInput>
  }

  export type GroupChatsUpdateWithoutGroupMessagesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    Admin?: UsersUpdateOneRequiredWithoutGroupChatsNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutGroupNestedInput
  }

  export type GroupChatsUncheckedUpdateWithoutGroupMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UsersUpsertWithoutGroupMessagesInput = {
    update: XOR<UsersUpdateWithoutGroupMessagesInput, UsersUncheckedUpdateWithoutGroupMessagesInput>
    create: XOR<UsersCreateWithoutGroupMessagesInput, UsersUncheckedCreateWithoutGroupMessagesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutGroupMessagesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutGroupMessagesInput, UsersUncheckedUpdateWithoutGroupMessagesInput>
  }

  export type UsersUpdateWithoutGroupMessagesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutMemberNestedInput
    blocking?: BlocksUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutGroupMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUncheckedUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutMemberNestedInput
    blocking?: BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput
  }

  export type GroupMessagesAttachmentUpsertWithWhereUniqueWithoutGroupMessageInput = {
    where: GroupMessagesAttachmentWhereUniqueInput
    update: XOR<GroupMessagesAttachmentUpdateWithoutGroupMessageInput, GroupMessagesAttachmentUncheckedUpdateWithoutGroupMessageInput>
    create: XOR<GroupMessagesAttachmentCreateWithoutGroupMessageInput, GroupMessagesAttachmentUncheckedCreateWithoutGroupMessageInput>
  }

  export type GroupMessagesAttachmentUpdateWithWhereUniqueWithoutGroupMessageInput = {
    where: GroupMessagesAttachmentWhereUniqueInput
    data: XOR<GroupMessagesAttachmentUpdateWithoutGroupMessageInput, GroupMessagesAttachmentUncheckedUpdateWithoutGroupMessageInput>
  }

  export type GroupMessagesAttachmentUpdateManyWithWhereWithoutGroupMessageInput = {
    where: GroupMessagesAttachmentScalarWhereInput
    data: XOR<GroupMessagesAttachmentUpdateManyMutationInput, GroupMessagesAttachmentUncheckedUpdateManyWithoutGroupMessageInput>
  }

  export type GroupMessagesAttachmentScalarWhereInput = {
    AND?: GroupMessagesAttachmentScalarWhereInput | GroupMessagesAttachmentScalarWhereInput[]
    OR?: GroupMessagesAttachmentScalarWhereInput[]
    NOT?: GroupMessagesAttachmentScalarWhereInput | GroupMessagesAttachmentScalarWhereInput[]
    id?: IntFilter<"GroupMessagesAttachment"> | number
    message_id?: IntFilter<"GroupMessagesAttachment"> | number
    size?: IntFilter<"GroupMessagesAttachment"> | number
    path?: StringFilter<"GroupMessagesAttachment"> | string
    originalName?: StringFilter<"GroupMessagesAttachment"> | string
    uniqueFileName?: StringFilter<"GroupMessagesAttachment"> | string
    created_at?: DateTimeFilter<"GroupMessagesAttachment"> | Date | string
  }

  export type GroupMessagesCreateWithoutAttachmentsInput = {
    content: string
    created_at?: Date | string
    group: GroupChatsCreateNestedOneWithoutGroupMessagesInput
    sender: UsersCreateNestedOneWithoutGroupMessagesInput
  }

  export type GroupMessagesUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    sender_id: number
    group_id: number
    content: string
    created_at?: Date | string
  }

  export type GroupMessagesCreateOrConnectWithoutAttachmentsInput = {
    where: GroupMessagesWhereUniqueInput
    create: XOR<GroupMessagesCreateWithoutAttachmentsInput, GroupMessagesUncheckedCreateWithoutAttachmentsInput>
  }

  export type GroupMessagesUpsertWithoutAttachmentsInput = {
    update: XOR<GroupMessagesUpdateWithoutAttachmentsInput, GroupMessagesUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<GroupMessagesCreateWithoutAttachmentsInput, GroupMessagesUncheckedCreateWithoutAttachmentsInput>
    where?: GroupMessagesWhereInput
  }

  export type GroupMessagesUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: GroupMessagesWhereInput
    data: XOR<GroupMessagesUpdateWithoutAttachmentsInput, GroupMessagesUncheckedUpdateWithoutAttachmentsInput>
  }

  export type GroupMessagesUpdateWithoutAttachmentsInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupChatsUpdateOneRequiredWithoutGroupMessagesNestedInput
    sender?: UsersUpdateOneRequiredWithoutGroupMessagesNestedInput
  }

  export type GroupMessagesUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersCreateWithoutFriendsInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesCreateNestedManyWithoutReceiverInput
    pendingRequestsSent?: PendingFriendRequestsCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsCreateNestedManyWithoutReceiverInput
    Friends?: FriendsCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutSenderInput
    blocking?: BlocksCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUncheckedCreateWithoutFriendsInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput
    Friends?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsUncheckedCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutSenderInput
    blocking?: BlocksUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksUncheckedCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersCreateOrConnectWithoutFriendsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFriendsInput, UsersUncheckedCreateWithoutFriendsInput>
  }

  export type UsersCreateWithoutFriendsInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsCreateNestedManyWithoutReceiverInput
    GroupChats?: GroupChatsCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutSenderInput
    blocking?: BlocksCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUncheckedCreateWithoutFriendsInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput
    GroupChats?: GroupChatsUncheckedCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutSenderInput
    blocking?: BlocksUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksUncheckedCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUpsertWithoutFriendsInput = {
    update: XOR<UsersUpdateWithoutFriendsInput, UsersUncheckedUpdateWithoutFriendsInput>
    create: XOR<UsersCreateWithoutFriendsInput, UsersUncheckedCreateWithoutFriendsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFriendsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFriendsInput, UsersUncheckedUpdateWithoutFriendsInput>
  }

  export type UsersUpdateWithoutFriendsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUpdateManyWithoutReceiverNestedInput
    pendingRequestsSent?: PendingFriendRequestsUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutFriendsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUncheckedUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUpsertWithoutFriendsInput = {
    update: XOR<UsersUpdateWithoutFriendsInput, UsersUncheckedUpdateWithoutFriendsInput>
    create: XOR<UsersCreateWithoutFriendsInput, UsersUncheckedCreateWithoutFriendsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFriendsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFriendsInput, UsersUncheckedUpdateWithoutFriendsInput>
  }

  export type UsersUpdateWithoutFriendsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUpdateManyWithoutReceiverNestedInput
    GroupChats?: GroupChatsUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutFriendsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput
    GroupChats?: GroupChatsUncheckedUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersCreateWithoutPendingRequestsSentInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    pendingRequestsReceived?: PendingFriendRequestsCreateNestedManyWithoutReceiverInput
    Friends?: FriendsCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutSenderInput
    blocking?: BlocksCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUncheckedCreateWithoutPendingRequestsSentInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput
    Friends?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsUncheckedCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutSenderInput
    blocking?: BlocksUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksUncheckedCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersCreateOrConnectWithoutPendingRequestsSentInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPendingRequestsSentInput, UsersUncheckedCreateWithoutPendingRequestsSentInput>
  }

  export type UsersCreateWithoutPendingRequestsReceivedInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsCreateNestedManyWithoutSenderInput
    Friends?: FriendsCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutSenderInput
    blocking?: BlocksCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUncheckedCreateWithoutPendingRequestsReceivedInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput
    Friends?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsUncheckedCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutSenderInput
    blocking?: BlocksUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksUncheckedCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersCreateOrConnectWithoutPendingRequestsReceivedInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPendingRequestsReceivedInput, UsersUncheckedCreateWithoutPendingRequestsReceivedInput>
  }

  export type UsersUpsertWithoutPendingRequestsSentInput = {
    update: XOR<UsersUpdateWithoutPendingRequestsSentInput, UsersUncheckedUpdateWithoutPendingRequestsSentInput>
    create: XOR<UsersCreateWithoutPendingRequestsSentInput, UsersUncheckedCreateWithoutPendingRequestsSentInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPendingRequestsSentInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPendingRequestsSentInput, UsersUncheckedUpdateWithoutPendingRequestsSentInput>
  }

  export type UsersUpdateWithoutPendingRequestsSentInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutPendingRequestsSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUncheckedUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUpsertWithoutPendingRequestsReceivedInput = {
    update: XOR<UsersUpdateWithoutPendingRequestsReceivedInput, UsersUncheckedUpdateWithoutPendingRequestsReceivedInput>
    create: XOR<UsersCreateWithoutPendingRequestsReceivedInput, UsersUncheckedCreateWithoutPendingRequestsReceivedInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPendingRequestsReceivedInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPendingRequestsReceivedInput, UsersUncheckedUpdateWithoutPendingRequestsReceivedInput>
  }

  export type UsersUpdateWithoutPendingRequestsReceivedInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUpdateManyWithoutSenderNestedInput
    Friends?: FriendsUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutPendingRequestsReceivedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput
    Friends?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUncheckedUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersCreateWithoutGroupChatsInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsCreateNestedManyWithoutReceiverInput
    Friends?: FriendsCreateNestedManyWithoutFriendInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutSenderInput
    blocking?: BlocksCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUncheckedCreateWithoutGroupChatsInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput
    Friends?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutSenderInput
    blocking?: BlocksUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksUncheckedCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersCreateOrConnectWithoutGroupChatsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutGroupChatsInput, UsersUncheckedCreateWithoutGroupChatsInput>
  }

  export type GroupMembersCreateWithoutGroupInput = {
    Member: UsersCreateNestedOneWithoutGroupMembersInput
  }

  export type GroupMembersUncheckedCreateWithoutGroupInput = {
    member_id: number
  }

  export type GroupMembersCreateOrConnectWithoutGroupInput = {
    where: GroupMembersWhereUniqueInput
    create: XOR<GroupMembersCreateWithoutGroupInput, GroupMembersUncheckedCreateWithoutGroupInput>
  }

  export type GroupMembersCreateManyGroupInputEnvelope = {
    data: GroupMembersCreateManyGroupInput | GroupMembersCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type GroupMessagesCreateWithoutGroupInput = {
    content: string
    created_at?: Date | string
    sender: UsersCreateNestedOneWithoutGroupMessagesInput
    attachments?: GroupMessagesAttachmentCreateNestedManyWithoutGroupMessageInput
  }

  export type GroupMessagesUncheckedCreateWithoutGroupInput = {
    id?: number
    sender_id: number
    content: string
    created_at?: Date | string
    attachments?: GroupMessagesAttachmentUncheckedCreateNestedManyWithoutGroupMessageInput
  }

  export type GroupMessagesCreateOrConnectWithoutGroupInput = {
    where: GroupMessagesWhereUniqueInput
    create: XOR<GroupMessagesCreateWithoutGroupInput, GroupMessagesUncheckedCreateWithoutGroupInput>
  }

  export type GroupMessagesCreateManyGroupInputEnvelope = {
    data: GroupMessagesCreateManyGroupInput | GroupMessagesCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutGroupChatsInput = {
    update: XOR<UsersUpdateWithoutGroupChatsInput, UsersUncheckedUpdateWithoutGroupChatsInput>
    create: XOR<UsersCreateWithoutGroupChatsInput, UsersUncheckedCreateWithoutGroupChatsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutGroupChatsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutGroupChatsInput, UsersUncheckedUpdateWithoutGroupChatsInput>
  }

  export type UsersUpdateWithoutGroupChatsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUpdateManyWithoutFriendNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutGroupChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput
  }

  export type GroupMembersUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMembersWhereUniqueInput
    update: XOR<GroupMembersUpdateWithoutGroupInput, GroupMembersUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMembersCreateWithoutGroupInput, GroupMembersUncheckedCreateWithoutGroupInput>
  }

  export type GroupMembersUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMembersWhereUniqueInput
    data: XOR<GroupMembersUpdateWithoutGroupInput, GroupMembersUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMembersUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMembersScalarWhereInput
    data: XOR<GroupMembersUpdateManyMutationInput, GroupMembersUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupMessagesUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMessagesWhereUniqueInput
    update: XOR<GroupMessagesUpdateWithoutGroupInput, GroupMessagesUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMessagesCreateWithoutGroupInput, GroupMessagesUncheckedCreateWithoutGroupInput>
  }

  export type GroupMessagesUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMessagesWhereUniqueInput
    data: XOR<GroupMessagesUpdateWithoutGroupInput, GroupMessagesUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMessagesUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMessagesScalarWhereInput
    data: XOR<GroupMessagesUpdateManyMutationInput, GroupMessagesUncheckedUpdateManyWithoutGroupInput>
  }

  export type UsersCreateWithoutBlockedByInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsCreateNestedManyWithoutReceiverInput
    Friends?: FriendsCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutSenderInput
    blocking?: BlocksCreateNestedManyWithoutBlockingUserInput
  }

  export type UsersUncheckedCreateWithoutBlockedByInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput
    Friends?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsUncheckedCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutSenderInput
    blocking?: BlocksUncheckedCreateNestedManyWithoutBlockingUserInput
  }

  export type UsersCreateOrConnectWithoutBlockedByInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutBlockedByInput, UsersUncheckedCreateWithoutBlockedByInput>
  }

  export type UsersCreateWithoutBlockingInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsCreateNestedManyWithoutReceiverInput
    Friends?: FriendsCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutSenderInput
    blockedBy?: BlocksCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUncheckedCreateWithoutBlockingInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput
    Friends?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsUncheckedCreateNestedManyWithoutAdminInput
    GroupMembers?: GroupMembersUncheckedCreateNestedManyWithoutMemberInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlocksUncheckedCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersCreateOrConnectWithoutBlockingInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutBlockingInput, UsersUncheckedCreateWithoutBlockingInput>
  }

  export type UsersUpsertWithoutBlockedByInput = {
    update: XOR<UsersUpdateWithoutBlockedByInput, UsersUncheckedUpdateWithoutBlockedByInput>
    create: XOR<UsersCreateWithoutBlockedByInput, UsersUncheckedCreateWithoutBlockedByInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutBlockedByInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutBlockedByInput, UsersUncheckedUpdateWithoutBlockedByInput>
  }

  export type UsersUpdateWithoutBlockedByInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUpdateManyWithoutBlockingUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutBlockedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUncheckedUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput
  }

  export type UsersUpsertWithoutBlockingInput = {
    update: XOR<UsersUpdateWithoutBlockingInput, UsersUncheckedUpdateWithoutBlockingInput>
    create: XOR<UsersCreateWithoutBlockingInput, UsersUncheckedCreateWithoutBlockingInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutBlockingInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutBlockingInput, UsersUncheckedUpdateWithoutBlockingInput>
  }

  export type UsersUpdateWithoutBlockingInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutSenderNestedInput
    blockedBy?: BlocksUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutBlockingInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUncheckedUpdateManyWithoutAdminNestedInput
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutMemberNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersCreateWithoutGroupMembersInput = {
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsCreateNestedManyWithoutReceiverInput
    Friends?: FriendsCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsCreateNestedManyWithoutAdminInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutSenderInput
    blocking?: BlocksCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersUncheckedCreateWithoutGroupMembersInput = {
    id?: number
    username: string
    password: string
    email: string
    bio?: string | null
    avatar?: string | null
    messagesSent?: PrivateMessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: PrivateMessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedCreateNestedManyWithoutSenderInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedCreateNestedManyWithoutReceiverInput
    Friends?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    GroupChats?: GroupChatsUncheckedCreateNestedManyWithoutAdminInput
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutSenderInput
    blocking?: BlocksUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedBy?: BlocksUncheckedCreateNestedManyWithoutBlockedUserInput
  }

  export type UsersCreateOrConnectWithoutGroupMembersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutGroupMembersInput, UsersUncheckedCreateWithoutGroupMembersInput>
  }

  export type GroupChatsCreateWithoutGroupMembersInput = {
    name?: string | null
    description?: string | null
    avatar?: string | null
    Admin: UsersCreateNestedOneWithoutGroupChatsInput
    GroupMessages?: GroupMessagesCreateNestedManyWithoutGroupInput
  }

  export type GroupChatsUncheckedCreateWithoutGroupMembersInput = {
    id?: number
    admin_id: number
    name?: string | null
    description?: string | null
    avatar?: string | null
    GroupMessages?: GroupMessagesUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupChatsCreateOrConnectWithoutGroupMembersInput = {
    where: GroupChatsWhereUniqueInput
    create: XOR<GroupChatsCreateWithoutGroupMembersInput, GroupChatsUncheckedCreateWithoutGroupMembersInput>
  }

  export type UsersUpsertWithoutGroupMembersInput = {
    update: XOR<UsersUpdateWithoutGroupMembersInput, UsersUncheckedUpdateWithoutGroupMembersInput>
    create: XOR<UsersCreateWithoutGroupMembersInput, UsersUncheckedCreateWithoutGroupMembersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutGroupMembersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutGroupMembersInput, UsersUncheckedUpdateWithoutGroupMembersInput>
  }

  export type UsersUpdateWithoutGroupMembersInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUpdateManyWithoutAdminNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUpdateManyWithoutBlockedUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutGroupMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    messagesSent?: PrivateMessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: PrivateMessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    pendingRequestsSent?: PendingFriendRequestsUncheckedUpdateManyWithoutSenderNestedInput
    pendingRequestsReceived?: PendingFriendRequestsUncheckedUpdateManyWithoutReceiverNestedInput
    Friends?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    GroupChats?: GroupChatsUncheckedUpdateManyWithoutAdminNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutSenderNestedInput
    blocking?: BlocksUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedBy?: BlocksUncheckedUpdateManyWithoutBlockedUserNestedInput
  }

  export type GroupChatsUpsertWithoutGroupMembersInput = {
    update: XOR<GroupChatsUpdateWithoutGroupMembersInput, GroupChatsUncheckedUpdateWithoutGroupMembersInput>
    create: XOR<GroupChatsCreateWithoutGroupMembersInput, GroupChatsUncheckedCreateWithoutGroupMembersInput>
    where?: GroupChatsWhereInput
  }

  export type GroupChatsUpdateToOneWithWhereWithoutGroupMembersInput = {
    where?: GroupChatsWhereInput
    data: XOR<GroupChatsUpdateWithoutGroupMembersInput, GroupChatsUncheckedUpdateWithoutGroupMembersInput>
  }

  export type GroupChatsUpdateWithoutGroupMembersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    Admin?: UsersUpdateOneRequiredWithoutGroupChatsNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutGroupNestedInput
  }

  export type GroupChatsUncheckedUpdateWithoutGroupMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type PrivateMessagesCreateManySenderInput = {
    id?: number
    receiver_id: number
    content: string
    created_at?: Date | string
  }

  export type PrivateMessagesCreateManyReceiverInput = {
    id?: number
    sender_id: number
    content: string
    created_at?: Date | string
  }

  export type FriendsCreateManyUserInput = {
    friend_id: number
  }

  export type PendingFriendRequestsCreateManySenderInput = {
    receiver_id: number
  }

  export type PendingFriendRequestsCreateManyReceiverInput = {
    sender_id: number
  }

  export type FriendsCreateManyFriendInput = {
    user_id: number
  }

  export type GroupChatsCreateManyAdminInput = {
    id?: number
    name?: string | null
    description?: string | null
    avatar?: string | null
  }

  export type GroupMembersCreateManyMemberInput = {
    group_id: number
  }

  export type GroupMessagesCreateManySenderInput = {
    id?: number
    group_id: number
    content: string
    created_at?: Date | string
  }

  export type BlocksCreateManyBlockingUserInput = {
    blocked: number
    friends?: boolean | null
  }

  export type BlocksCreateManyBlockedUserInput = {
    blocker: number
    friends?: boolean | null
  }

  export type PrivateMessagesUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UsersUpdateOneRequiredWithoutMessagesReceivedNestedInput
    attachments?: PrivateMessagesAttachmentUpdateManyWithoutPrivateMessageNestedInput
  }

  export type PrivateMessagesUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: PrivateMessagesAttachmentUncheckedUpdateManyWithoutPrivateMessageNestedInput
  }

  export type PrivateMessagesUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessagesUpdateWithoutReceiverInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UsersUpdateOneRequiredWithoutMessagesSentNestedInput
    attachments?: PrivateMessagesAttachmentUpdateManyWithoutPrivateMessageNestedInput
  }

  export type PrivateMessagesUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: PrivateMessagesAttachmentUncheckedUpdateManyWithoutPrivateMessageNestedInput
  }

  export type PrivateMessagesUncheckedUpdateManyWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendsUpdateWithoutUserInput = {
    Friend?: UsersUpdateOneRequiredWithoutFriendsNestedInput
  }

  export type FriendsUncheckedUpdateWithoutUserInput = {
    friend_id?: IntFieldUpdateOperationsInput | number
  }

  export type FriendsUncheckedUpdateManyWithoutUserInput = {
    friend_id?: IntFieldUpdateOperationsInput | number
  }

  export type PendingFriendRequestsUpdateWithoutSenderInput = {
    Receiver?: UsersUpdateOneRequiredWithoutPendingRequestsReceivedNestedInput
  }

  export type PendingFriendRequestsUncheckedUpdateWithoutSenderInput = {
    receiver_id?: IntFieldUpdateOperationsInput | number
  }

  export type PendingFriendRequestsUncheckedUpdateManyWithoutSenderInput = {
    receiver_id?: IntFieldUpdateOperationsInput | number
  }

  export type PendingFriendRequestsUpdateWithoutReceiverInput = {
    Sender?: UsersUpdateOneRequiredWithoutPendingRequestsSentNestedInput
  }

  export type PendingFriendRequestsUncheckedUpdateWithoutReceiverInput = {
    sender_id?: IntFieldUpdateOperationsInput | number
  }

  export type PendingFriendRequestsUncheckedUpdateManyWithoutReceiverInput = {
    sender_id?: IntFieldUpdateOperationsInput | number
  }

  export type FriendsUpdateWithoutFriendInput = {
    User?: UsersUpdateOneRequiredWithoutFriendsNestedInput
  }

  export type FriendsUncheckedUpdateWithoutFriendInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type FriendsUncheckedUpdateManyWithoutFriendInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type GroupChatsUpdateWithoutAdminInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    GroupMembers?: GroupMembersUpdateManyWithoutGroupNestedInput
    GroupMessages?: GroupMessagesUpdateManyWithoutGroupNestedInput
  }

  export type GroupChatsUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    GroupMembers?: GroupMembersUncheckedUpdateManyWithoutGroupNestedInput
    GroupMessages?: GroupMessagesUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupChatsUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupMembersUpdateWithoutMemberInput = {
    Group?: GroupChatsUpdateOneRequiredWithoutGroupMembersNestedInput
  }

  export type GroupMembersUncheckedUpdateWithoutMemberInput = {
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type GroupMembersUncheckedUpdateManyWithoutMemberInput = {
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type GroupMessagesUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupChatsUpdateOneRequiredWithoutGroupMessagesNestedInput
    attachments?: GroupMessagesAttachmentUpdateManyWithoutGroupMessageNestedInput
  }

  export type GroupMessagesUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: GroupMessagesAttachmentUncheckedUpdateManyWithoutGroupMessageNestedInput
  }

  export type GroupMessagesUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlocksUpdateWithoutBlockingUserInput = {
    friends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    BlockedUser?: UsersUpdateOneRequiredWithoutBlockedByNestedInput
  }

  export type BlocksUncheckedUpdateWithoutBlockingUserInput = {
    blocked?: IntFieldUpdateOperationsInput | number
    friends?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BlocksUncheckedUpdateManyWithoutBlockingUserInput = {
    blocked?: IntFieldUpdateOperationsInput | number
    friends?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BlocksUpdateWithoutBlockedUserInput = {
    friends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    BlockingUser?: UsersUpdateOneRequiredWithoutBlockingNestedInput
  }

  export type BlocksUncheckedUpdateWithoutBlockedUserInput = {
    blocker?: IntFieldUpdateOperationsInput | number
    friends?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BlocksUncheckedUpdateManyWithoutBlockedUserInput = {
    blocker?: IntFieldUpdateOperationsInput | number
    friends?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PrivateMessagesAttachmentCreateManyPrivateMessageInput = {
    id?: number
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
  }

  export type PrivateMessagesAttachmentUpdateWithoutPrivateMessageInput = {
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessagesAttachmentUncheckedUpdateWithoutPrivateMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessagesAttachmentUncheckedUpdateManyWithoutPrivateMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessagesAttachmentCreateManyGroupMessageInput = {
    id?: number
    size: number
    path: string
    originalName: string
    uniqueFileName: string
    created_at?: Date | string
  }

  export type GroupMessagesAttachmentUpdateWithoutGroupMessageInput = {
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessagesAttachmentUncheckedUpdateWithoutGroupMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessagesAttachmentUncheckedUpdateManyWithoutGroupMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    uniqueFileName?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMembersCreateManyGroupInput = {
    member_id: number
  }

  export type GroupMessagesCreateManyGroupInput = {
    id?: number
    sender_id: number
    content: string
    created_at?: Date | string
  }

  export type GroupMembersUpdateWithoutGroupInput = {
    Member?: UsersUpdateOneRequiredWithoutGroupMembersNestedInput
  }

  export type GroupMembersUncheckedUpdateWithoutGroupInput = {
    member_id?: IntFieldUpdateOperationsInput | number
  }

  export type GroupMembersUncheckedUpdateManyWithoutGroupInput = {
    member_id?: IntFieldUpdateOperationsInput | number
  }

  export type GroupMessagesUpdateWithoutGroupInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UsersUpdateOneRequiredWithoutGroupMessagesNestedInput
    attachments?: GroupMessagesAttachmentUpdateManyWithoutGroupMessageNestedInput
  }

  export type GroupMessagesUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: GroupMessagesAttachmentUncheckedUpdateManyWithoutGroupMessageNestedInput
  }

  export type GroupMessagesUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}